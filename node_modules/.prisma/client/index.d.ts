
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model UsuarioGerenciamento
 * 
 */
export type UsuarioGerenciamento = $Result.DefaultSelection<Prisma.$UsuarioGerenciamentoPayload>
/**
 * Model UsuarioExecucao
 * 
 */
export type UsuarioExecucao = $Result.DefaultSelection<Prisma.$UsuarioExecucaoPayload>
/**
 * Model Obra
 * 
 */
export type Obra = $Result.DefaultSelection<Prisma.$ObraPayload>
/**
 * Model JustificativaAtraso
 * 
 */
export type JustificativaAtraso = $Result.DefaultSelection<Prisma.$JustificativaAtrasoPayload>
/**
 * Model EtapaObra
 * 
 */
export type EtapaObra = $Result.DefaultSelection<Prisma.$EtapaObraPayload>
/**
 * Model Material
 * 
 */
export type Material = $Result.DefaultSelection<Prisma.$MaterialPayload>
/**
 * Model MaterialObra
 * 
 */
export type MaterialObra = $Result.DefaultSelection<Prisma.$MaterialObraPayload>
/**
 * Model LembreteMaterial
 * 
 */
export type LembreteMaterial = $Result.DefaultSelection<Prisma.$LembreteMaterialPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const Role: {
  GERENCIAMENTO: 'GERENCIAMENTO',
  EXECUCAO: 'EXECUCAO'
};

export type Role = (typeof Role)[keyof typeof Role]


export const TipoObra: {
  RESIDENCIAL: 'RESIDENCIAL',
  COMERCIAL: 'COMERCIAL',
  INDUSTRIAL: 'INDUSTRIAL',
  OUTRA: 'OUTRA'
};

export type TipoObra = (typeof TipoObra)[keyof typeof TipoObra]


export const TipoJustificativa: {
  CHUVA: 'CHUVA',
  FALHA_PROJETO: 'FALHA_PROJETO',
  ATRASO_MATERIAIS: 'ATRASO_MATERIAIS',
  OUTRO: 'OUTRO'
};

export type TipoJustificativa = (typeof TipoJustificativa)[keyof typeof TipoJustificativa]


export const EtapaTipo: {
  FUNDACAO: 'FUNDACAO',
  ALVENARIA: 'ALVENARIA',
  COBERTURA: 'COBERTURA',
  INSTALACOES: 'INSTALACOES'
};

export type EtapaTipo = (typeof EtapaTipo)[keyof typeof EtapaTipo]


export const SubEtapaTipo: {
  TERRAPLANAGEM: 'TERRAPLANAGEM',
  PERFURACOES: 'PERFURACOES',
  VIGA_BALDRAME: 'VIGA_BALDRAME',
  PILARES: 'PILARES',
  VIGA_COROAMENTO: 'VIGA_COROAMENTO',
  LAJE: 'LAJE',
  INST_ELETRICAS: 'INST_ELETRICAS',
  INST_HIDRAULICAS: 'INST_HIDRAULICAS'
};

export type SubEtapaTipo = (typeof SubEtapaTipo)[keyof typeof SubEtapaTipo]


export const StatusEtapa: {
  EM_ANDAMENTO: 'EM_ANDAMENTO',
  FINALIZADO: 'FINALIZADO'
};

export type StatusEtapa = (typeof StatusEtapa)[keyof typeof StatusEtapa]


export const StatusPedido: {
  PENDENTE: 'PENDENTE',
  PEDIDO_FEITO: 'PEDIDO_FEITO',
  PEDIDO_RECEBIDO: 'PEDIDO_RECEBIDO'
};

export type StatusPedido = (typeof StatusPedido)[keyof typeof StatusPedido]

}

export type Role = $Enums.Role

export const Role: typeof $Enums.Role

export type TipoObra = $Enums.TipoObra

export const TipoObra: typeof $Enums.TipoObra

export type TipoJustificativa = $Enums.TipoJustificativa

export const TipoJustificativa: typeof $Enums.TipoJustificativa

export type EtapaTipo = $Enums.EtapaTipo

export const EtapaTipo: typeof $Enums.EtapaTipo

export type SubEtapaTipo = $Enums.SubEtapaTipo

export const SubEtapaTipo: typeof $Enums.SubEtapaTipo

export type StatusEtapa = $Enums.StatusEtapa

export const StatusEtapa: typeof $Enums.StatusEtapa

export type StatusPedido = $Enums.StatusPedido

export const StatusPedido: typeof $Enums.StatusPedido

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more UsuarioGerenciamentos
 * const usuarioGerenciamentos = await prisma.usuarioGerenciamento.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more UsuarioGerenciamentos
   * const usuarioGerenciamentos = await prisma.usuarioGerenciamento.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.usuarioGerenciamento`: Exposes CRUD operations for the **UsuarioGerenciamento** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UsuarioGerenciamentos
    * const usuarioGerenciamentos = await prisma.usuarioGerenciamento.findMany()
    * ```
    */
  get usuarioGerenciamento(): Prisma.UsuarioGerenciamentoDelegate<ExtArgs>;

  /**
   * `prisma.usuarioExecucao`: Exposes CRUD operations for the **UsuarioExecucao** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UsuarioExecucaos
    * const usuarioExecucaos = await prisma.usuarioExecucao.findMany()
    * ```
    */
  get usuarioExecucao(): Prisma.UsuarioExecucaoDelegate<ExtArgs>;

  /**
   * `prisma.obra`: Exposes CRUD operations for the **Obra** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Obras
    * const obras = await prisma.obra.findMany()
    * ```
    */
  get obra(): Prisma.ObraDelegate<ExtArgs>;

  /**
   * `prisma.justificativaAtraso`: Exposes CRUD operations for the **JustificativaAtraso** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more JustificativaAtrasos
    * const justificativaAtrasos = await prisma.justificativaAtraso.findMany()
    * ```
    */
  get justificativaAtraso(): Prisma.JustificativaAtrasoDelegate<ExtArgs>;

  /**
   * `prisma.etapaObra`: Exposes CRUD operations for the **EtapaObra** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EtapaObras
    * const etapaObras = await prisma.etapaObra.findMany()
    * ```
    */
  get etapaObra(): Prisma.EtapaObraDelegate<ExtArgs>;

  /**
   * `prisma.material`: Exposes CRUD operations for the **Material** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Materials
    * const materials = await prisma.material.findMany()
    * ```
    */
  get material(): Prisma.MaterialDelegate<ExtArgs>;

  /**
   * `prisma.materialObra`: Exposes CRUD operations for the **MaterialObra** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MaterialObras
    * const materialObras = await prisma.materialObra.findMany()
    * ```
    */
  get materialObra(): Prisma.MaterialObraDelegate<ExtArgs>;

  /**
   * `prisma.lembreteMaterial`: Exposes CRUD operations for the **LembreteMaterial** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LembreteMaterials
    * const lembreteMaterials = await prisma.lembreteMaterial.findMany()
    * ```
    */
  get lembreteMaterial(): Prisma.LembreteMaterialDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.22.0
   * Query Engine version: 605197351a3c8bdd595af2d2a9bc3025bca48ea2
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    UsuarioGerenciamento: 'UsuarioGerenciamento',
    UsuarioExecucao: 'UsuarioExecucao',
    Obra: 'Obra',
    JustificativaAtraso: 'JustificativaAtraso',
    EtapaObra: 'EtapaObra',
    Material: 'Material',
    MaterialObra: 'MaterialObra',
    LembreteMaterial: 'LembreteMaterial'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "usuarioGerenciamento" | "usuarioExecucao" | "obra" | "justificativaAtraso" | "etapaObra" | "material" | "materialObra" | "lembreteMaterial"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      UsuarioGerenciamento: {
        payload: Prisma.$UsuarioGerenciamentoPayload<ExtArgs>
        fields: Prisma.UsuarioGerenciamentoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UsuarioGerenciamentoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioGerenciamentoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UsuarioGerenciamentoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioGerenciamentoPayload>
          }
          findFirst: {
            args: Prisma.UsuarioGerenciamentoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioGerenciamentoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UsuarioGerenciamentoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioGerenciamentoPayload>
          }
          findMany: {
            args: Prisma.UsuarioGerenciamentoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioGerenciamentoPayload>[]
          }
          create: {
            args: Prisma.UsuarioGerenciamentoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioGerenciamentoPayload>
          }
          createMany: {
            args: Prisma.UsuarioGerenciamentoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UsuarioGerenciamentoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioGerenciamentoPayload>[]
          }
          delete: {
            args: Prisma.UsuarioGerenciamentoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioGerenciamentoPayload>
          }
          update: {
            args: Prisma.UsuarioGerenciamentoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioGerenciamentoPayload>
          }
          deleteMany: {
            args: Prisma.UsuarioGerenciamentoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UsuarioGerenciamentoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UsuarioGerenciamentoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioGerenciamentoPayload>
          }
          aggregate: {
            args: Prisma.UsuarioGerenciamentoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUsuarioGerenciamento>
          }
          groupBy: {
            args: Prisma.UsuarioGerenciamentoGroupByArgs<ExtArgs>
            result: $Utils.Optional<UsuarioGerenciamentoGroupByOutputType>[]
          }
          count: {
            args: Prisma.UsuarioGerenciamentoCountArgs<ExtArgs>
            result: $Utils.Optional<UsuarioGerenciamentoCountAggregateOutputType> | number
          }
        }
      }
      UsuarioExecucao: {
        payload: Prisma.$UsuarioExecucaoPayload<ExtArgs>
        fields: Prisma.UsuarioExecucaoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UsuarioExecucaoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioExecucaoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UsuarioExecucaoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioExecucaoPayload>
          }
          findFirst: {
            args: Prisma.UsuarioExecucaoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioExecucaoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UsuarioExecucaoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioExecucaoPayload>
          }
          findMany: {
            args: Prisma.UsuarioExecucaoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioExecucaoPayload>[]
          }
          create: {
            args: Prisma.UsuarioExecucaoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioExecucaoPayload>
          }
          createMany: {
            args: Prisma.UsuarioExecucaoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UsuarioExecucaoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioExecucaoPayload>[]
          }
          delete: {
            args: Prisma.UsuarioExecucaoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioExecucaoPayload>
          }
          update: {
            args: Prisma.UsuarioExecucaoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioExecucaoPayload>
          }
          deleteMany: {
            args: Prisma.UsuarioExecucaoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UsuarioExecucaoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UsuarioExecucaoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioExecucaoPayload>
          }
          aggregate: {
            args: Prisma.UsuarioExecucaoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUsuarioExecucao>
          }
          groupBy: {
            args: Prisma.UsuarioExecucaoGroupByArgs<ExtArgs>
            result: $Utils.Optional<UsuarioExecucaoGroupByOutputType>[]
          }
          count: {
            args: Prisma.UsuarioExecucaoCountArgs<ExtArgs>
            result: $Utils.Optional<UsuarioExecucaoCountAggregateOutputType> | number
          }
        }
      }
      Obra: {
        payload: Prisma.$ObraPayload<ExtArgs>
        fields: Prisma.ObraFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ObraFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ObraPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ObraFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ObraPayload>
          }
          findFirst: {
            args: Prisma.ObraFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ObraPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ObraFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ObraPayload>
          }
          findMany: {
            args: Prisma.ObraFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ObraPayload>[]
          }
          create: {
            args: Prisma.ObraCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ObraPayload>
          }
          createMany: {
            args: Prisma.ObraCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ObraCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ObraPayload>[]
          }
          delete: {
            args: Prisma.ObraDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ObraPayload>
          }
          update: {
            args: Prisma.ObraUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ObraPayload>
          }
          deleteMany: {
            args: Prisma.ObraDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ObraUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ObraUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ObraPayload>
          }
          aggregate: {
            args: Prisma.ObraAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateObra>
          }
          groupBy: {
            args: Prisma.ObraGroupByArgs<ExtArgs>
            result: $Utils.Optional<ObraGroupByOutputType>[]
          }
          count: {
            args: Prisma.ObraCountArgs<ExtArgs>
            result: $Utils.Optional<ObraCountAggregateOutputType> | number
          }
        }
      }
      JustificativaAtraso: {
        payload: Prisma.$JustificativaAtrasoPayload<ExtArgs>
        fields: Prisma.JustificativaAtrasoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.JustificativaAtrasoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JustificativaAtrasoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.JustificativaAtrasoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JustificativaAtrasoPayload>
          }
          findFirst: {
            args: Prisma.JustificativaAtrasoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JustificativaAtrasoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.JustificativaAtrasoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JustificativaAtrasoPayload>
          }
          findMany: {
            args: Prisma.JustificativaAtrasoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JustificativaAtrasoPayload>[]
          }
          create: {
            args: Prisma.JustificativaAtrasoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JustificativaAtrasoPayload>
          }
          createMany: {
            args: Prisma.JustificativaAtrasoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.JustificativaAtrasoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JustificativaAtrasoPayload>[]
          }
          delete: {
            args: Prisma.JustificativaAtrasoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JustificativaAtrasoPayload>
          }
          update: {
            args: Prisma.JustificativaAtrasoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JustificativaAtrasoPayload>
          }
          deleteMany: {
            args: Prisma.JustificativaAtrasoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.JustificativaAtrasoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.JustificativaAtrasoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JustificativaAtrasoPayload>
          }
          aggregate: {
            args: Prisma.JustificativaAtrasoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateJustificativaAtraso>
          }
          groupBy: {
            args: Prisma.JustificativaAtrasoGroupByArgs<ExtArgs>
            result: $Utils.Optional<JustificativaAtrasoGroupByOutputType>[]
          }
          count: {
            args: Prisma.JustificativaAtrasoCountArgs<ExtArgs>
            result: $Utils.Optional<JustificativaAtrasoCountAggregateOutputType> | number
          }
        }
      }
      EtapaObra: {
        payload: Prisma.$EtapaObraPayload<ExtArgs>
        fields: Prisma.EtapaObraFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EtapaObraFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EtapaObraPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EtapaObraFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EtapaObraPayload>
          }
          findFirst: {
            args: Prisma.EtapaObraFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EtapaObraPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EtapaObraFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EtapaObraPayload>
          }
          findMany: {
            args: Prisma.EtapaObraFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EtapaObraPayload>[]
          }
          create: {
            args: Prisma.EtapaObraCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EtapaObraPayload>
          }
          createMany: {
            args: Prisma.EtapaObraCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EtapaObraCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EtapaObraPayload>[]
          }
          delete: {
            args: Prisma.EtapaObraDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EtapaObraPayload>
          }
          update: {
            args: Prisma.EtapaObraUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EtapaObraPayload>
          }
          deleteMany: {
            args: Prisma.EtapaObraDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EtapaObraUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EtapaObraUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EtapaObraPayload>
          }
          aggregate: {
            args: Prisma.EtapaObraAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEtapaObra>
          }
          groupBy: {
            args: Prisma.EtapaObraGroupByArgs<ExtArgs>
            result: $Utils.Optional<EtapaObraGroupByOutputType>[]
          }
          count: {
            args: Prisma.EtapaObraCountArgs<ExtArgs>
            result: $Utils.Optional<EtapaObraCountAggregateOutputType> | number
          }
        }
      }
      Material: {
        payload: Prisma.$MaterialPayload<ExtArgs>
        fields: Prisma.MaterialFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MaterialFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MaterialFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialPayload>
          }
          findFirst: {
            args: Prisma.MaterialFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MaterialFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialPayload>
          }
          findMany: {
            args: Prisma.MaterialFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialPayload>[]
          }
          create: {
            args: Prisma.MaterialCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialPayload>
          }
          createMany: {
            args: Prisma.MaterialCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MaterialCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialPayload>[]
          }
          delete: {
            args: Prisma.MaterialDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialPayload>
          }
          update: {
            args: Prisma.MaterialUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialPayload>
          }
          deleteMany: {
            args: Prisma.MaterialDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MaterialUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MaterialUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialPayload>
          }
          aggregate: {
            args: Prisma.MaterialAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMaterial>
          }
          groupBy: {
            args: Prisma.MaterialGroupByArgs<ExtArgs>
            result: $Utils.Optional<MaterialGroupByOutputType>[]
          }
          count: {
            args: Prisma.MaterialCountArgs<ExtArgs>
            result: $Utils.Optional<MaterialCountAggregateOutputType> | number
          }
        }
      }
      MaterialObra: {
        payload: Prisma.$MaterialObraPayload<ExtArgs>
        fields: Prisma.MaterialObraFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MaterialObraFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialObraPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MaterialObraFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialObraPayload>
          }
          findFirst: {
            args: Prisma.MaterialObraFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialObraPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MaterialObraFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialObraPayload>
          }
          findMany: {
            args: Prisma.MaterialObraFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialObraPayload>[]
          }
          create: {
            args: Prisma.MaterialObraCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialObraPayload>
          }
          createMany: {
            args: Prisma.MaterialObraCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MaterialObraCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialObraPayload>[]
          }
          delete: {
            args: Prisma.MaterialObraDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialObraPayload>
          }
          update: {
            args: Prisma.MaterialObraUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialObraPayload>
          }
          deleteMany: {
            args: Prisma.MaterialObraDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MaterialObraUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MaterialObraUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialObraPayload>
          }
          aggregate: {
            args: Prisma.MaterialObraAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMaterialObra>
          }
          groupBy: {
            args: Prisma.MaterialObraGroupByArgs<ExtArgs>
            result: $Utils.Optional<MaterialObraGroupByOutputType>[]
          }
          count: {
            args: Prisma.MaterialObraCountArgs<ExtArgs>
            result: $Utils.Optional<MaterialObraCountAggregateOutputType> | number
          }
        }
      }
      LembreteMaterial: {
        payload: Prisma.$LembreteMaterialPayload<ExtArgs>
        fields: Prisma.LembreteMaterialFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LembreteMaterialFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LembreteMaterialPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LembreteMaterialFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LembreteMaterialPayload>
          }
          findFirst: {
            args: Prisma.LembreteMaterialFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LembreteMaterialPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LembreteMaterialFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LembreteMaterialPayload>
          }
          findMany: {
            args: Prisma.LembreteMaterialFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LembreteMaterialPayload>[]
          }
          create: {
            args: Prisma.LembreteMaterialCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LembreteMaterialPayload>
          }
          createMany: {
            args: Prisma.LembreteMaterialCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LembreteMaterialCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LembreteMaterialPayload>[]
          }
          delete: {
            args: Prisma.LembreteMaterialDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LembreteMaterialPayload>
          }
          update: {
            args: Prisma.LembreteMaterialUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LembreteMaterialPayload>
          }
          deleteMany: {
            args: Prisma.LembreteMaterialDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LembreteMaterialUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.LembreteMaterialUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LembreteMaterialPayload>
          }
          aggregate: {
            args: Prisma.LembreteMaterialAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLembreteMaterial>
          }
          groupBy: {
            args: Prisma.LembreteMaterialGroupByArgs<ExtArgs>
            result: $Utils.Optional<LembreteMaterialGroupByOutputType>[]
          }
          count: {
            args: Prisma.LembreteMaterialCountArgs<ExtArgs>
            result: $Utils.Optional<LembreteMaterialCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UsuarioGerenciamentoCountOutputType
   */

  export type UsuarioGerenciamentoCountOutputType = {
    obras: number
    usuariosExecucao: number
  }

  export type UsuarioGerenciamentoCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    obras?: boolean | UsuarioGerenciamentoCountOutputTypeCountObrasArgs
    usuariosExecucao?: boolean | UsuarioGerenciamentoCountOutputTypeCountUsuariosExecucaoArgs
  }

  // Custom InputTypes
  /**
   * UsuarioGerenciamentoCountOutputType without action
   */
  export type UsuarioGerenciamentoCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsuarioGerenciamentoCountOutputType
     */
    select?: UsuarioGerenciamentoCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UsuarioGerenciamentoCountOutputType without action
   */
  export type UsuarioGerenciamentoCountOutputTypeCountObrasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ObraWhereInput
  }

  /**
   * UsuarioGerenciamentoCountOutputType without action
   */
  export type UsuarioGerenciamentoCountOutputTypeCountUsuariosExecucaoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UsuarioExecucaoWhereInput
  }


  /**
   * Count Type UsuarioExecucaoCountOutputType
   */

  export type UsuarioExecucaoCountOutputType = {
    obrasResponsavel: number
  }

  export type UsuarioExecucaoCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    obrasResponsavel?: boolean | UsuarioExecucaoCountOutputTypeCountObrasResponsavelArgs
  }

  // Custom InputTypes
  /**
   * UsuarioExecucaoCountOutputType without action
   */
  export type UsuarioExecucaoCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsuarioExecucaoCountOutputType
     */
    select?: UsuarioExecucaoCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UsuarioExecucaoCountOutputType without action
   */
  export type UsuarioExecucaoCountOutputTypeCountObrasResponsavelArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ObraWhereInput
  }


  /**
   * Count Type ObraCountOutputType
   */

  export type ObraCountOutputType = {
    etapas: number
    materiaisPedidos: number
    lembretes: number
  }

  export type ObraCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    etapas?: boolean | ObraCountOutputTypeCountEtapasArgs
    materiaisPedidos?: boolean | ObraCountOutputTypeCountMateriaisPedidosArgs
    lembretes?: boolean | ObraCountOutputTypeCountLembretesArgs
  }

  // Custom InputTypes
  /**
   * ObraCountOutputType without action
   */
  export type ObraCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ObraCountOutputType
     */
    select?: ObraCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ObraCountOutputType without action
   */
  export type ObraCountOutputTypeCountEtapasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EtapaObraWhereInput
  }

  /**
   * ObraCountOutputType without action
   */
  export type ObraCountOutputTypeCountMateriaisPedidosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MaterialObraWhereInput
  }

  /**
   * ObraCountOutputType without action
   */
  export type ObraCountOutputTypeCountLembretesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LembreteMaterialWhereInput
  }


  /**
   * Count Type JustificativaAtrasoCountOutputType
   */

  export type JustificativaAtrasoCountOutputType = {
    etapas: number
  }

  export type JustificativaAtrasoCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    etapas?: boolean | JustificativaAtrasoCountOutputTypeCountEtapasArgs
  }

  // Custom InputTypes
  /**
   * JustificativaAtrasoCountOutputType without action
   */
  export type JustificativaAtrasoCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JustificativaAtrasoCountOutputType
     */
    select?: JustificativaAtrasoCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * JustificativaAtrasoCountOutputType without action
   */
  export type JustificativaAtrasoCountOutputTypeCountEtapasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EtapaObraWhereInput
  }


  /**
   * Count Type MaterialCountOutputType
   */

  export type MaterialCountOutputType = {
    itens: number
    lembretes: number
  }

  export type MaterialCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    itens?: boolean | MaterialCountOutputTypeCountItensArgs
    lembretes?: boolean | MaterialCountOutputTypeCountLembretesArgs
  }

  // Custom InputTypes
  /**
   * MaterialCountOutputType without action
   */
  export type MaterialCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaterialCountOutputType
     */
    select?: MaterialCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MaterialCountOutputType without action
   */
  export type MaterialCountOutputTypeCountItensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MaterialObraWhereInput
  }

  /**
   * MaterialCountOutputType without action
   */
  export type MaterialCountOutputTypeCountLembretesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LembreteMaterialWhereInput
  }


  /**
   * Models
   */

  /**
   * Model UsuarioGerenciamento
   */

  export type AggregateUsuarioGerenciamento = {
    _count: UsuarioGerenciamentoCountAggregateOutputType | null
    _avg: UsuarioGerenciamentoAvgAggregateOutputType | null
    _sum: UsuarioGerenciamentoSumAggregateOutputType | null
    _min: UsuarioGerenciamentoMinAggregateOutputType | null
    _max: UsuarioGerenciamentoMaxAggregateOutputType | null
  }

  export type UsuarioGerenciamentoAvgAggregateOutputType = {
    id: number | null
  }

  export type UsuarioGerenciamentoSumAggregateOutputType = {
    id: number | null
  }

  export type UsuarioGerenciamentoMinAggregateOutputType = {
    id: number | null
    razaoSocial: string | null
    inscricaoEstadual: string | null
    cnpj: string | null
    dataFundacao: Date | null
    telefone: string | null
    email: string | null
    endereco: string | null
    senhaHash: string | null
    role: $Enums.Role | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UsuarioGerenciamentoMaxAggregateOutputType = {
    id: number | null
    razaoSocial: string | null
    inscricaoEstadual: string | null
    cnpj: string | null
    dataFundacao: Date | null
    telefone: string | null
    email: string | null
    endereco: string | null
    senhaHash: string | null
    role: $Enums.Role | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UsuarioGerenciamentoCountAggregateOutputType = {
    id: number
    razaoSocial: number
    inscricaoEstadual: number
    cnpj: number
    dataFundacao: number
    telefone: number
    email: number
    endereco: number
    senhaHash: number
    role: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UsuarioGerenciamentoAvgAggregateInputType = {
    id?: true
  }

  export type UsuarioGerenciamentoSumAggregateInputType = {
    id?: true
  }

  export type UsuarioGerenciamentoMinAggregateInputType = {
    id?: true
    razaoSocial?: true
    inscricaoEstadual?: true
    cnpj?: true
    dataFundacao?: true
    telefone?: true
    email?: true
    endereco?: true
    senhaHash?: true
    role?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UsuarioGerenciamentoMaxAggregateInputType = {
    id?: true
    razaoSocial?: true
    inscricaoEstadual?: true
    cnpj?: true
    dataFundacao?: true
    telefone?: true
    email?: true
    endereco?: true
    senhaHash?: true
    role?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UsuarioGerenciamentoCountAggregateInputType = {
    id?: true
    razaoSocial?: true
    inscricaoEstadual?: true
    cnpj?: true
    dataFundacao?: true
    telefone?: true
    email?: true
    endereco?: true
    senhaHash?: true
    role?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UsuarioGerenciamentoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UsuarioGerenciamento to aggregate.
     */
    where?: UsuarioGerenciamentoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UsuarioGerenciamentos to fetch.
     */
    orderBy?: UsuarioGerenciamentoOrderByWithRelationInput | UsuarioGerenciamentoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UsuarioGerenciamentoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UsuarioGerenciamentos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UsuarioGerenciamentos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UsuarioGerenciamentos
    **/
    _count?: true | UsuarioGerenciamentoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UsuarioGerenciamentoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UsuarioGerenciamentoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UsuarioGerenciamentoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UsuarioGerenciamentoMaxAggregateInputType
  }

  export type GetUsuarioGerenciamentoAggregateType<T extends UsuarioGerenciamentoAggregateArgs> = {
        [P in keyof T & keyof AggregateUsuarioGerenciamento]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUsuarioGerenciamento[P]>
      : GetScalarType<T[P], AggregateUsuarioGerenciamento[P]>
  }




  export type UsuarioGerenciamentoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UsuarioGerenciamentoWhereInput
    orderBy?: UsuarioGerenciamentoOrderByWithAggregationInput | UsuarioGerenciamentoOrderByWithAggregationInput[]
    by: UsuarioGerenciamentoScalarFieldEnum[] | UsuarioGerenciamentoScalarFieldEnum
    having?: UsuarioGerenciamentoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UsuarioGerenciamentoCountAggregateInputType | true
    _avg?: UsuarioGerenciamentoAvgAggregateInputType
    _sum?: UsuarioGerenciamentoSumAggregateInputType
    _min?: UsuarioGerenciamentoMinAggregateInputType
    _max?: UsuarioGerenciamentoMaxAggregateInputType
  }

  export type UsuarioGerenciamentoGroupByOutputType = {
    id: number
    razaoSocial: string
    inscricaoEstadual: string | null
    cnpj: string
    dataFundacao: Date | null
    telefone: string | null
    email: string
    endereco: string
    senhaHash: string
    role: $Enums.Role
    createdAt: Date
    updatedAt: Date
    _count: UsuarioGerenciamentoCountAggregateOutputType | null
    _avg: UsuarioGerenciamentoAvgAggregateOutputType | null
    _sum: UsuarioGerenciamentoSumAggregateOutputType | null
    _min: UsuarioGerenciamentoMinAggregateOutputType | null
    _max: UsuarioGerenciamentoMaxAggregateOutputType | null
  }

  type GetUsuarioGerenciamentoGroupByPayload<T extends UsuarioGerenciamentoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UsuarioGerenciamentoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UsuarioGerenciamentoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UsuarioGerenciamentoGroupByOutputType[P]>
            : GetScalarType<T[P], UsuarioGerenciamentoGroupByOutputType[P]>
        }
      >
    >


  export type UsuarioGerenciamentoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    razaoSocial?: boolean
    inscricaoEstadual?: boolean
    cnpj?: boolean
    dataFundacao?: boolean
    telefone?: boolean
    email?: boolean
    endereco?: boolean
    senhaHash?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    obras?: boolean | UsuarioGerenciamento$obrasArgs<ExtArgs>
    usuariosExecucao?: boolean | UsuarioGerenciamento$usuariosExecucaoArgs<ExtArgs>
    _count?: boolean | UsuarioGerenciamentoCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["usuarioGerenciamento"]>

  export type UsuarioGerenciamentoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    razaoSocial?: boolean
    inscricaoEstadual?: boolean
    cnpj?: boolean
    dataFundacao?: boolean
    telefone?: boolean
    email?: boolean
    endereco?: boolean
    senhaHash?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["usuarioGerenciamento"]>

  export type UsuarioGerenciamentoSelectScalar = {
    id?: boolean
    razaoSocial?: boolean
    inscricaoEstadual?: boolean
    cnpj?: boolean
    dataFundacao?: boolean
    telefone?: boolean
    email?: boolean
    endereco?: boolean
    senhaHash?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UsuarioGerenciamentoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    obras?: boolean | UsuarioGerenciamento$obrasArgs<ExtArgs>
    usuariosExecucao?: boolean | UsuarioGerenciamento$usuariosExecucaoArgs<ExtArgs>
    _count?: boolean | UsuarioGerenciamentoCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UsuarioGerenciamentoIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UsuarioGerenciamentoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UsuarioGerenciamento"
    objects: {
      obras: Prisma.$ObraPayload<ExtArgs>[]
      usuariosExecucao: Prisma.$UsuarioExecucaoPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      razaoSocial: string
      inscricaoEstadual: string | null
      cnpj: string
      dataFundacao: Date | null
      telefone: string | null
      email: string
      endereco: string
      senhaHash: string
      role: $Enums.Role
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["usuarioGerenciamento"]>
    composites: {}
  }

  type UsuarioGerenciamentoGetPayload<S extends boolean | null | undefined | UsuarioGerenciamentoDefaultArgs> = $Result.GetResult<Prisma.$UsuarioGerenciamentoPayload, S>

  type UsuarioGerenciamentoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UsuarioGerenciamentoFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UsuarioGerenciamentoCountAggregateInputType | true
    }

  export interface UsuarioGerenciamentoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UsuarioGerenciamento'], meta: { name: 'UsuarioGerenciamento' } }
    /**
     * Find zero or one UsuarioGerenciamento that matches the filter.
     * @param {UsuarioGerenciamentoFindUniqueArgs} args - Arguments to find a UsuarioGerenciamento
     * @example
     * // Get one UsuarioGerenciamento
     * const usuarioGerenciamento = await prisma.usuarioGerenciamento.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UsuarioGerenciamentoFindUniqueArgs>(args: SelectSubset<T, UsuarioGerenciamentoFindUniqueArgs<ExtArgs>>): Prisma__UsuarioGerenciamentoClient<$Result.GetResult<Prisma.$UsuarioGerenciamentoPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one UsuarioGerenciamento that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UsuarioGerenciamentoFindUniqueOrThrowArgs} args - Arguments to find a UsuarioGerenciamento
     * @example
     * // Get one UsuarioGerenciamento
     * const usuarioGerenciamento = await prisma.usuarioGerenciamento.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UsuarioGerenciamentoFindUniqueOrThrowArgs>(args: SelectSubset<T, UsuarioGerenciamentoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UsuarioGerenciamentoClient<$Result.GetResult<Prisma.$UsuarioGerenciamentoPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first UsuarioGerenciamento that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioGerenciamentoFindFirstArgs} args - Arguments to find a UsuarioGerenciamento
     * @example
     * // Get one UsuarioGerenciamento
     * const usuarioGerenciamento = await prisma.usuarioGerenciamento.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UsuarioGerenciamentoFindFirstArgs>(args?: SelectSubset<T, UsuarioGerenciamentoFindFirstArgs<ExtArgs>>): Prisma__UsuarioGerenciamentoClient<$Result.GetResult<Prisma.$UsuarioGerenciamentoPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first UsuarioGerenciamento that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioGerenciamentoFindFirstOrThrowArgs} args - Arguments to find a UsuarioGerenciamento
     * @example
     * // Get one UsuarioGerenciamento
     * const usuarioGerenciamento = await prisma.usuarioGerenciamento.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UsuarioGerenciamentoFindFirstOrThrowArgs>(args?: SelectSubset<T, UsuarioGerenciamentoFindFirstOrThrowArgs<ExtArgs>>): Prisma__UsuarioGerenciamentoClient<$Result.GetResult<Prisma.$UsuarioGerenciamentoPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more UsuarioGerenciamentos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioGerenciamentoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UsuarioGerenciamentos
     * const usuarioGerenciamentos = await prisma.usuarioGerenciamento.findMany()
     * 
     * // Get first 10 UsuarioGerenciamentos
     * const usuarioGerenciamentos = await prisma.usuarioGerenciamento.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const usuarioGerenciamentoWithIdOnly = await prisma.usuarioGerenciamento.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UsuarioGerenciamentoFindManyArgs>(args?: SelectSubset<T, UsuarioGerenciamentoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsuarioGerenciamentoPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a UsuarioGerenciamento.
     * @param {UsuarioGerenciamentoCreateArgs} args - Arguments to create a UsuarioGerenciamento.
     * @example
     * // Create one UsuarioGerenciamento
     * const UsuarioGerenciamento = await prisma.usuarioGerenciamento.create({
     *   data: {
     *     // ... data to create a UsuarioGerenciamento
     *   }
     * })
     * 
     */
    create<T extends UsuarioGerenciamentoCreateArgs>(args: SelectSubset<T, UsuarioGerenciamentoCreateArgs<ExtArgs>>): Prisma__UsuarioGerenciamentoClient<$Result.GetResult<Prisma.$UsuarioGerenciamentoPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many UsuarioGerenciamentos.
     * @param {UsuarioGerenciamentoCreateManyArgs} args - Arguments to create many UsuarioGerenciamentos.
     * @example
     * // Create many UsuarioGerenciamentos
     * const usuarioGerenciamento = await prisma.usuarioGerenciamento.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UsuarioGerenciamentoCreateManyArgs>(args?: SelectSubset<T, UsuarioGerenciamentoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UsuarioGerenciamentos and returns the data saved in the database.
     * @param {UsuarioGerenciamentoCreateManyAndReturnArgs} args - Arguments to create many UsuarioGerenciamentos.
     * @example
     * // Create many UsuarioGerenciamentos
     * const usuarioGerenciamento = await prisma.usuarioGerenciamento.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UsuarioGerenciamentos and only return the `id`
     * const usuarioGerenciamentoWithIdOnly = await prisma.usuarioGerenciamento.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UsuarioGerenciamentoCreateManyAndReturnArgs>(args?: SelectSubset<T, UsuarioGerenciamentoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsuarioGerenciamentoPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a UsuarioGerenciamento.
     * @param {UsuarioGerenciamentoDeleteArgs} args - Arguments to delete one UsuarioGerenciamento.
     * @example
     * // Delete one UsuarioGerenciamento
     * const UsuarioGerenciamento = await prisma.usuarioGerenciamento.delete({
     *   where: {
     *     // ... filter to delete one UsuarioGerenciamento
     *   }
     * })
     * 
     */
    delete<T extends UsuarioGerenciamentoDeleteArgs>(args: SelectSubset<T, UsuarioGerenciamentoDeleteArgs<ExtArgs>>): Prisma__UsuarioGerenciamentoClient<$Result.GetResult<Prisma.$UsuarioGerenciamentoPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one UsuarioGerenciamento.
     * @param {UsuarioGerenciamentoUpdateArgs} args - Arguments to update one UsuarioGerenciamento.
     * @example
     * // Update one UsuarioGerenciamento
     * const usuarioGerenciamento = await prisma.usuarioGerenciamento.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UsuarioGerenciamentoUpdateArgs>(args: SelectSubset<T, UsuarioGerenciamentoUpdateArgs<ExtArgs>>): Prisma__UsuarioGerenciamentoClient<$Result.GetResult<Prisma.$UsuarioGerenciamentoPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more UsuarioGerenciamentos.
     * @param {UsuarioGerenciamentoDeleteManyArgs} args - Arguments to filter UsuarioGerenciamentos to delete.
     * @example
     * // Delete a few UsuarioGerenciamentos
     * const { count } = await prisma.usuarioGerenciamento.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UsuarioGerenciamentoDeleteManyArgs>(args?: SelectSubset<T, UsuarioGerenciamentoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UsuarioGerenciamentos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioGerenciamentoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UsuarioGerenciamentos
     * const usuarioGerenciamento = await prisma.usuarioGerenciamento.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UsuarioGerenciamentoUpdateManyArgs>(args: SelectSubset<T, UsuarioGerenciamentoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UsuarioGerenciamento.
     * @param {UsuarioGerenciamentoUpsertArgs} args - Arguments to update or create a UsuarioGerenciamento.
     * @example
     * // Update or create a UsuarioGerenciamento
     * const usuarioGerenciamento = await prisma.usuarioGerenciamento.upsert({
     *   create: {
     *     // ... data to create a UsuarioGerenciamento
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UsuarioGerenciamento we want to update
     *   }
     * })
     */
    upsert<T extends UsuarioGerenciamentoUpsertArgs>(args: SelectSubset<T, UsuarioGerenciamentoUpsertArgs<ExtArgs>>): Prisma__UsuarioGerenciamentoClient<$Result.GetResult<Prisma.$UsuarioGerenciamentoPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of UsuarioGerenciamentos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioGerenciamentoCountArgs} args - Arguments to filter UsuarioGerenciamentos to count.
     * @example
     * // Count the number of UsuarioGerenciamentos
     * const count = await prisma.usuarioGerenciamento.count({
     *   where: {
     *     // ... the filter for the UsuarioGerenciamentos we want to count
     *   }
     * })
    **/
    count<T extends UsuarioGerenciamentoCountArgs>(
      args?: Subset<T, UsuarioGerenciamentoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UsuarioGerenciamentoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UsuarioGerenciamento.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioGerenciamentoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UsuarioGerenciamentoAggregateArgs>(args: Subset<T, UsuarioGerenciamentoAggregateArgs>): Prisma.PrismaPromise<GetUsuarioGerenciamentoAggregateType<T>>

    /**
     * Group by UsuarioGerenciamento.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioGerenciamentoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UsuarioGerenciamentoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UsuarioGerenciamentoGroupByArgs['orderBy'] }
        : { orderBy?: UsuarioGerenciamentoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UsuarioGerenciamentoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUsuarioGerenciamentoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UsuarioGerenciamento model
   */
  readonly fields: UsuarioGerenciamentoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UsuarioGerenciamento.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UsuarioGerenciamentoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    obras<T extends UsuarioGerenciamento$obrasArgs<ExtArgs> = {}>(args?: Subset<T, UsuarioGerenciamento$obrasArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ObraPayload<ExtArgs>, T, "findMany"> | Null>
    usuariosExecucao<T extends UsuarioGerenciamento$usuariosExecucaoArgs<ExtArgs> = {}>(args?: Subset<T, UsuarioGerenciamento$usuariosExecucaoArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsuarioExecucaoPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UsuarioGerenciamento model
   */ 
  interface UsuarioGerenciamentoFieldRefs {
    readonly id: FieldRef<"UsuarioGerenciamento", 'Int'>
    readonly razaoSocial: FieldRef<"UsuarioGerenciamento", 'String'>
    readonly inscricaoEstadual: FieldRef<"UsuarioGerenciamento", 'String'>
    readonly cnpj: FieldRef<"UsuarioGerenciamento", 'String'>
    readonly dataFundacao: FieldRef<"UsuarioGerenciamento", 'DateTime'>
    readonly telefone: FieldRef<"UsuarioGerenciamento", 'String'>
    readonly email: FieldRef<"UsuarioGerenciamento", 'String'>
    readonly endereco: FieldRef<"UsuarioGerenciamento", 'String'>
    readonly senhaHash: FieldRef<"UsuarioGerenciamento", 'String'>
    readonly role: FieldRef<"UsuarioGerenciamento", 'Role'>
    readonly createdAt: FieldRef<"UsuarioGerenciamento", 'DateTime'>
    readonly updatedAt: FieldRef<"UsuarioGerenciamento", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UsuarioGerenciamento findUnique
   */
  export type UsuarioGerenciamentoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsuarioGerenciamento
     */
    select?: UsuarioGerenciamentoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioGerenciamentoInclude<ExtArgs> | null
    /**
     * Filter, which UsuarioGerenciamento to fetch.
     */
    where: UsuarioGerenciamentoWhereUniqueInput
  }

  /**
   * UsuarioGerenciamento findUniqueOrThrow
   */
  export type UsuarioGerenciamentoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsuarioGerenciamento
     */
    select?: UsuarioGerenciamentoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioGerenciamentoInclude<ExtArgs> | null
    /**
     * Filter, which UsuarioGerenciamento to fetch.
     */
    where: UsuarioGerenciamentoWhereUniqueInput
  }

  /**
   * UsuarioGerenciamento findFirst
   */
  export type UsuarioGerenciamentoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsuarioGerenciamento
     */
    select?: UsuarioGerenciamentoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioGerenciamentoInclude<ExtArgs> | null
    /**
     * Filter, which UsuarioGerenciamento to fetch.
     */
    where?: UsuarioGerenciamentoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UsuarioGerenciamentos to fetch.
     */
    orderBy?: UsuarioGerenciamentoOrderByWithRelationInput | UsuarioGerenciamentoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UsuarioGerenciamentos.
     */
    cursor?: UsuarioGerenciamentoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UsuarioGerenciamentos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UsuarioGerenciamentos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UsuarioGerenciamentos.
     */
    distinct?: UsuarioGerenciamentoScalarFieldEnum | UsuarioGerenciamentoScalarFieldEnum[]
  }

  /**
   * UsuarioGerenciamento findFirstOrThrow
   */
  export type UsuarioGerenciamentoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsuarioGerenciamento
     */
    select?: UsuarioGerenciamentoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioGerenciamentoInclude<ExtArgs> | null
    /**
     * Filter, which UsuarioGerenciamento to fetch.
     */
    where?: UsuarioGerenciamentoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UsuarioGerenciamentos to fetch.
     */
    orderBy?: UsuarioGerenciamentoOrderByWithRelationInput | UsuarioGerenciamentoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UsuarioGerenciamentos.
     */
    cursor?: UsuarioGerenciamentoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UsuarioGerenciamentos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UsuarioGerenciamentos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UsuarioGerenciamentos.
     */
    distinct?: UsuarioGerenciamentoScalarFieldEnum | UsuarioGerenciamentoScalarFieldEnum[]
  }

  /**
   * UsuarioGerenciamento findMany
   */
  export type UsuarioGerenciamentoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsuarioGerenciamento
     */
    select?: UsuarioGerenciamentoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioGerenciamentoInclude<ExtArgs> | null
    /**
     * Filter, which UsuarioGerenciamentos to fetch.
     */
    where?: UsuarioGerenciamentoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UsuarioGerenciamentos to fetch.
     */
    orderBy?: UsuarioGerenciamentoOrderByWithRelationInput | UsuarioGerenciamentoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UsuarioGerenciamentos.
     */
    cursor?: UsuarioGerenciamentoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UsuarioGerenciamentos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UsuarioGerenciamentos.
     */
    skip?: number
    distinct?: UsuarioGerenciamentoScalarFieldEnum | UsuarioGerenciamentoScalarFieldEnum[]
  }

  /**
   * UsuarioGerenciamento create
   */
  export type UsuarioGerenciamentoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsuarioGerenciamento
     */
    select?: UsuarioGerenciamentoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioGerenciamentoInclude<ExtArgs> | null
    /**
     * The data needed to create a UsuarioGerenciamento.
     */
    data: XOR<UsuarioGerenciamentoCreateInput, UsuarioGerenciamentoUncheckedCreateInput>
  }

  /**
   * UsuarioGerenciamento createMany
   */
  export type UsuarioGerenciamentoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UsuarioGerenciamentos.
     */
    data: UsuarioGerenciamentoCreateManyInput | UsuarioGerenciamentoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UsuarioGerenciamento createManyAndReturn
   */
  export type UsuarioGerenciamentoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsuarioGerenciamento
     */
    select?: UsuarioGerenciamentoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many UsuarioGerenciamentos.
     */
    data: UsuarioGerenciamentoCreateManyInput | UsuarioGerenciamentoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UsuarioGerenciamento update
   */
  export type UsuarioGerenciamentoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsuarioGerenciamento
     */
    select?: UsuarioGerenciamentoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioGerenciamentoInclude<ExtArgs> | null
    /**
     * The data needed to update a UsuarioGerenciamento.
     */
    data: XOR<UsuarioGerenciamentoUpdateInput, UsuarioGerenciamentoUncheckedUpdateInput>
    /**
     * Choose, which UsuarioGerenciamento to update.
     */
    where: UsuarioGerenciamentoWhereUniqueInput
  }

  /**
   * UsuarioGerenciamento updateMany
   */
  export type UsuarioGerenciamentoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UsuarioGerenciamentos.
     */
    data: XOR<UsuarioGerenciamentoUpdateManyMutationInput, UsuarioGerenciamentoUncheckedUpdateManyInput>
    /**
     * Filter which UsuarioGerenciamentos to update
     */
    where?: UsuarioGerenciamentoWhereInput
  }

  /**
   * UsuarioGerenciamento upsert
   */
  export type UsuarioGerenciamentoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsuarioGerenciamento
     */
    select?: UsuarioGerenciamentoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioGerenciamentoInclude<ExtArgs> | null
    /**
     * The filter to search for the UsuarioGerenciamento to update in case it exists.
     */
    where: UsuarioGerenciamentoWhereUniqueInput
    /**
     * In case the UsuarioGerenciamento found by the `where` argument doesn't exist, create a new UsuarioGerenciamento with this data.
     */
    create: XOR<UsuarioGerenciamentoCreateInput, UsuarioGerenciamentoUncheckedCreateInput>
    /**
     * In case the UsuarioGerenciamento was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UsuarioGerenciamentoUpdateInput, UsuarioGerenciamentoUncheckedUpdateInput>
  }

  /**
   * UsuarioGerenciamento delete
   */
  export type UsuarioGerenciamentoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsuarioGerenciamento
     */
    select?: UsuarioGerenciamentoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioGerenciamentoInclude<ExtArgs> | null
    /**
     * Filter which UsuarioGerenciamento to delete.
     */
    where: UsuarioGerenciamentoWhereUniqueInput
  }

  /**
   * UsuarioGerenciamento deleteMany
   */
  export type UsuarioGerenciamentoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UsuarioGerenciamentos to delete
     */
    where?: UsuarioGerenciamentoWhereInput
  }

  /**
   * UsuarioGerenciamento.obras
   */
  export type UsuarioGerenciamento$obrasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Obra
     */
    select?: ObraSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ObraInclude<ExtArgs> | null
    where?: ObraWhereInput
    orderBy?: ObraOrderByWithRelationInput | ObraOrderByWithRelationInput[]
    cursor?: ObraWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ObraScalarFieldEnum | ObraScalarFieldEnum[]
  }

  /**
   * UsuarioGerenciamento.usuariosExecucao
   */
  export type UsuarioGerenciamento$usuariosExecucaoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsuarioExecucao
     */
    select?: UsuarioExecucaoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioExecucaoInclude<ExtArgs> | null
    where?: UsuarioExecucaoWhereInput
    orderBy?: UsuarioExecucaoOrderByWithRelationInput | UsuarioExecucaoOrderByWithRelationInput[]
    cursor?: UsuarioExecucaoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UsuarioExecucaoScalarFieldEnum | UsuarioExecucaoScalarFieldEnum[]
  }

  /**
   * UsuarioGerenciamento without action
   */
  export type UsuarioGerenciamentoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsuarioGerenciamento
     */
    select?: UsuarioGerenciamentoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioGerenciamentoInclude<ExtArgs> | null
  }


  /**
   * Model UsuarioExecucao
   */

  export type AggregateUsuarioExecucao = {
    _count: UsuarioExecucaoCountAggregateOutputType | null
    _avg: UsuarioExecucaoAvgAggregateOutputType | null
    _sum: UsuarioExecucaoSumAggregateOutputType | null
    _min: UsuarioExecucaoMinAggregateOutputType | null
    _max: UsuarioExecucaoMaxAggregateOutputType | null
  }

  export type UsuarioExecucaoAvgAggregateOutputType = {
    id: number | null
    empresaId: number | null
  }

  export type UsuarioExecucaoSumAggregateOutputType = {
    id: number | null
    empresaId: number | null
  }

  export type UsuarioExecucaoMinAggregateOutputType = {
    id: number | null
    nome: string | null
    cpf: string | null
    endereco: string | null
    creaCau: string | null
    telefone: string | null
    email: string | null
    dataNascimento: Date | null
    senhaHash: string | null
    role: $Enums.Role | null
    empresaId: number | null
  }

  export type UsuarioExecucaoMaxAggregateOutputType = {
    id: number | null
    nome: string | null
    cpf: string | null
    endereco: string | null
    creaCau: string | null
    telefone: string | null
    email: string | null
    dataNascimento: Date | null
    senhaHash: string | null
    role: $Enums.Role | null
    empresaId: number | null
  }

  export type UsuarioExecucaoCountAggregateOutputType = {
    id: number
    nome: number
    cpf: number
    endereco: number
    creaCau: number
    telefone: number
    email: number
    dataNascimento: number
    senhaHash: number
    role: number
    empresaId: number
    _all: number
  }


  export type UsuarioExecucaoAvgAggregateInputType = {
    id?: true
    empresaId?: true
  }

  export type UsuarioExecucaoSumAggregateInputType = {
    id?: true
    empresaId?: true
  }

  export type UsuarioExecucaoMinAggregateInputType = {
    id?: true
    nome?: true
    cpf?: true
    endereco?: true
    creaCau?: true
    telefone?: true
    email?: true
    dataNascimento?: true
    senhaHash?: true
    role?: true
    empresaId?: true
  }

  export type UsuarioExecucaoMaxAggregateInputType = {
    id?: true
    nome?: true
    cpf?: true
    endereco?: true
    creaCau?: true
    telefone?: true
    email?: true
    dataNascimento?: true
    senhaHash?: true
    role?: true
    empresaId?: true
  }

  export type UsuarioExecucaoCountAggregateInputType = {
    id?: true
    nome?: true
    cpf?: true
    endereco?: true
    creaCau?: true
    telefone?: true
    email?: true
    dataNascimento?: true
    senhaHash?: true
    role?: true
    empresaId?: true
    _all?: true
  }

  export type UsuarioExecucaoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UsuarioExecucao to aggregate.
     */
    where?: UsuarioExecucaoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UsuarioExecucaos to fetch.
     */
    orderBy?: UsuarioExecucaoOrderByWithRelationInput | UsuarioExecucaoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UsuarioExecucaoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UsuarioExecucaos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UsuarioExecucaos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UsuarioExecucaos
    **/
    _count?: true | UsuarioExecucaoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UsuarioExecucaoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UsuarioExecucaoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UsuarioExecucaoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UsuarioExecucaoMaxAggregateInputType
  }

  export type GetUsuarioExecucaoAggregateType<T extends UsuarioExecucaoAggregateArgs> = {
        [P in keyof T & keyof AggregateUsuarioExecucao]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUsuarioExecucao[P]>
      : GetScalarType<T[P], AggregateUsuarioExecucao[P]>
  }




  export type UsuarioExecucaoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UsuarioExecucaoWhereInput
    orderBy?: UsuarioExecucaoOrderByWithAggregationInput | UsuarioExecucaoOrderByWithAggregationInput[]
    by: UsuarioExecucaoScalarFieldEnum[] | UsuarioExecucaoScalarFieldEnum
    having?: UsuarioExecucaoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UsuarioExecucaoCountAggregateInputType | true
    _avg?: UsuarioExecucaoAvgAggregateInputType
    _sum?: UsuarioExecucaoSumAggregateInputType
    _min?: UsuarioExecucaoMinAggregateInputType
    _max?: UsuarioExecucaoMaxAggregateInputType
  }

  export type UsuarioExecucaoGroupByOutputType = {
    id: number
    nome: string
    cpf: string
    endereco: string
    creaCau: string
    telefone: string | null
    email: string
    dataNascimento: Date | null
    senhaHash: string
    role: $Enums.Role
    empresaId: number
    _count: UsuarioExecucaoCountAggregateOutputType | null
    _avg: UsuarioExecucaoAvgAggregateOutputType | null
    _sum: UsuarioExecucaoSumAggregateOutputType | null
    _min: UsuarioExecucaoMinAggregateOutputType | null
    _max: UsuarioExecucaoMaxAggregateOutputType | null
  }

  type GetUsuarioExecucaoGroupByPayload<T extends UsuarioExecucaoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UsuarioExecucaoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UsuarioExecucaoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UsuarioExecucaoGroupByOutputType[P]>
            : GetScalarType<T[P], UsuarioExecucaoGroupByOutputType[P]>
        }
      >
    >


  export type UsuarioExecucaoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nome?: boolean
    cpf?: boolean
    endereco?: boolean
    creaCau?: boolean
    telefone?: boolean
    email?: boolean
    dataNascimento?: boolean
    senhaHash?: boolean
    role?: boolean
    empresaId?: boolean
    empresa?: boolean | UsuarioGerenciamentoDefaultArgs<ExtArgs>
    obrasResponsavel?: boolean | UsuarioExecucao$obrasResponsavelArgs<ExtArgs>
    _count?: boolean | UsuarioExecucaoCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["usuarioExecucao"]>

  export type UsuarioExecucaoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nome?: boolean
    cpf?: boolean
    endereco?: boolean
    creaCau?: boolean
    telefone?: boolean
    email?: boolean
    dataNascimento?: boolean
    senhaHash?: boolean
    role?: boolean
    empresaId?: boolean
    empresa?: boolean | UsuarioGerenciamentoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["usuarioExecucao"]>

  export type UsuarioExecucaoSelectScalar = {
    id?: boolean
    nome?: boolean
    cpf?: boolean
    endereco?: boolean
    creaCau?: boolean
    telefone?: boolean
    email?: boolean
    dataNascimento?: boolean
    senhaHash?: boolean
    role?: boolean
    empresaId?: boolean
  }

  export type UsuarioExecucaoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    empresa?: boolean | UsuarioGerenciamentoDefaultArgs<ExtArgs>
    obrasResponsavel?: boolean | UsuarioExecucao$obrasResponsavelArgs<ExtArgs>
    _count?: boolean | UsuarioExecucaoCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UsuarioExecucaoIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    empresa?: boolean | UsuarioGerenciamentoDefaultArgs<ExtArgs>
  }

  export type $UsuarioExecucaoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UsuarioExecucao"
    objects: {
      empresa: Prisma.$UsuarioGerenciamentoPayload<ExtArgs>
      obrasResponsavel: Prisma.$ObraPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      nome: string
      cpf: string
      endereco: string
      creaCau: string
      telefone: string | null
      email: string
      dataNascimento: Date | null
      senhaHash: string
      role: $Enums.Role
      empresaId: number
    }, ExtArgs["result"]["usuarioExecucao"]>
    composites: {}
  }

  type UsuarioExecucaoGetPayload<S extends boolean | null | undefined | UsuarioExecucaoDefaultArgs> = $Result.GetResult<Prisma.$UsuarioExecucaoPayload, S>

  type UsuarioExecucaoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UsuarioExecucaoFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UsuarioExecucaoCountAggregateInputType | true
    }

  export interface UsuarioExecucaoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UsuarioExecucao'], meta: { name: 'UsuarioExecucao' } }
    /**
     * Find zero or one UsuarioExecucao that matches the filter.
     * @param {UsuarioExecucaoFindUniqueArgs} args - Arguments to find a UsuarioExecucao
     * @example
     * // Get one UsuarioExecucao
     * const usuarioExecucao = await prisma.usuarioExecucao.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UsuarioExecucaoFindUniqueArgs>(args: SelectSubset<T, UsuarioExecucaoFindUniqueArgs<ExtArgs>>): Prisma__UsuarioExecucaoClient<$Result.GetResult<Prisma.$UsuarioExecucaoPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one UsuarioExecucao that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UsuarioExecucaoFindUniqueOrThrowArgs} args - Arguments to find a UsuarioExecucao
     * @example
     * // Get one UsuarioExecucao
     * const usuarioExecucao = await prisma.usuarioExecucao.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UsuarioExecucaoFindUniqueOrThrowArgs>(args: SelectSubset<T, UsuarioExecucaoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UsuarioExecucaoClient<$Result.GetResult<Prisma.$UsuarioExecucaoPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first UsuarioExecucao that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioExecucaoFindFirstArgs} args - Arguments to find a UsuarioExecucao
     * @example
     * // Get one UsuarioExecucao
     * const usuarioExecucao = await prisma.usuarioExecucao.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UsuarioExecucaoFindFirstArgs>(args?: SelectSubset<T, UsuarioExecucaoFindFirstArgs<ExtArgs>>): Prisma__UsuarioExecucaoClient<$Result.GetResult<Prisma.$UsuarioExecucaoPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first UsuarioExecucao that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioExecucaoFindFirstOrThrowArgs} args - Arguments to find a UsuarioExecucao
     * @example
     * // Get one UsuarioExecucao
     * const usuarioExecucao = await prisma.usuarioExecucao.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UsuarioExecucaoFindFirstOrThrowArgs>(args?: SelectSubset<T, UsuarioExecucaoFindFirstOrThrowArgs<ExtArgs>>): Prisma__UsuarioExecucaoClient<$Result.GetResult<Prisma.$UsuarioExecucaoPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more UsuarioExecucaos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioExecucaoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UsuarioExecucaos
     * const usuarioExecucaos = await prisma.usuarioExecucao.findMany()
     * 
     * // Get first 10 UsuarioExecucaos
     * const usuarioExecucaos = await prisma.usuarioExecucao.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const usuarioExecucaoWithIdOnly = await prisma.usuarioExecucao.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UsuarioExecucaoFindManyArgs>(args?: SelectSubset<T, UsuarioExecucaoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsuarioExecucaoPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a UsuarioExecucao.
     * @param {UsuarioExecucaoCreateArgs} args - Arguments to create a UsuarioExecucao.
     * @example
     * // Create one UsuarioExecucao
     * const UsuarioExecucao = await prisma.usuarioExecucao.create({
     *   data: {
     *     // ... data to create a UsuarioExecucao
     *   }
     * })
     * 
     */
    create<T extends UsuarioExecucaoCreateArgs>(args: SelectSubset<T, UsuarioExecucaoCreateArgs<ExtArgs>>): Prisma__UsuarioExecucaoClient<$Result.GetResult<Prisma.$UsuarioExecucaoPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many UsuarioExecucaos.
     * @param {UsuarioExecucaoCreateManyArgs} args - Arguments to create many UsuarioExecucaos.
     * @example
     * // Create many UsuarioExecucaos
     * const usuarioExecucao = await prisma.usuarioExecucao.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UsuarioExecucaoCreateManyArgs>(args?: SelectSubset<T, UsuarioExecucaoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UsuarioExecucaos and returns the data saved in the database.
     * @param {UsuarioExecucaoCreateManyAndReturnArgs} args - Arguments to create many UsuarioExecucaos.
     * @example
     * // Create many UsuarioExecucaos
     * const usuarioExecucao = await prisma.usuarioExecucao.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UsuarioExecucaos and only return the `id`
     * const usuarioExecucaoWithIdOnly = await prisma.usuarioExecucao.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UsuarioExecucaoCreateManyAndReturnArgs>(args?: SelectSubset<T, UsuarioExecucaoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsuarioExecucaoPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a UsuarioExecucao.
     * @param {UsuarioExecucaoDeleteArgs} args - Arguments to delete one UsuarioExecucao.
     * @example
     * // Delete one UsuarioExecucao
     * const UsuarioExecucao = await prisma.usuarioExecucao.delete({
     *   where: {
     *     // ... filter to delete one UsuarioExecucao
     *   }
     * })
     * 
     */
    delete<T extends UsuarioExecucaoDeleteArgs>(args: SelectSubset<T, UsuarioExecucaoDeleteArgs<ExtArgs>>): Prisma__UsuarioExecucaoClient<$Result.GetResult<Prisma.$UsuarioExecucaoPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one UsuarioExecucao.
     * @param {UsuarioExecucaoUpdateArgs} args - Arguments to update one UsuarioExecucao.
     * @example
     * // Update one UsuarioExecucao
     * const usuarioExecucao = await prisma.usuarioExecucao.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UsuarioExecucaoUpdateArgs>(args: SelectSubset<T, UsuarioExecucaoUpdateArgs<ExtArgs>>): Prisma__UsuarioExecucaoClient<$Result.GetResult<Prisma.$UsuarioExecucaoPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more UsuarioExecucaos.
     * @param {UsuarioExecucaoDeleteManyArgs} args - Arguments to filter UsuarioExecucaos to delete.
     * @example
     * // Delete a few UsuarioExecucaos
     * const { count } = await prisma.usuarioExecucao.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UsuarioExecucaoDeleteManyArgs>(args?: SelectSubset<T, UsuarioExecucaoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UsuarioExecucaos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioExecucaoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UsuarioExecucaos
     * const usuarioExecucao = await prisma.usuarioExecucao.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UsuarioExecucaoUpdateManyArgs>(args: SelectSubset<T, UsuarioExecucaoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UsuarioExecucao.
     * @param {UsuarioExecucaoUpsertArgs} args - Arguments to update or create a UsuarioExecucao.
     * @example
     * // Update or create a UsuarioExecucao
     * const usuarioExecucao = await prisma.usuarioExecucao.upsert({
     *   create: {
     *     // ... data to create a UsuarioExecucao
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UsuarioExecucao we want to update
     *   }
     * })
     */
    upsert<T extends UsuarioExecucaoUpsertArgs>(args: SelectSubset<T, UsuarioExecucaoUpsertArgs<ExtArgs>>): Prisma__UsuarioExecucaoClient<$Result.GetResult<Prisma.$UsuarioExecucaoPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of UsuarioExecucaos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioExecucaoCountArgs} args - Arguments to filter UsuarioExecucaos to count.
     * @example
     * // Count the number of UsuarioExecucaos
     * const count = await prisma.usuarioExecucao.count({
     *   where: {
     *     // ... the filter for the UsuarioExecucaos we want to count
     *   }
     * })
    **/
    count<T extends UsuarioExecucaoCountArgs>(
      args?: Subset<T, UsuarioExecucaoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UsuarioExecucaoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UsuarioExecucao.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioExecucaoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UsuarioExecucaoAggregateArgs>(args: Subset<T, UsuarioExecucaoAggregateArgs>): Prisma.PrismaPromise<GetUsuarioExecucaoAggregateType<T>>

    /**
     * Group by UsuarioExecucao.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioExecucaoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UsuarioExecucaoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UsuarioExecucaoGroupByArgs['orderBy'] }
        : { orderBy?: UsuarioExecucaoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UsuarioExecucaoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUsuarioExecucaoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UsuarioExecucao model
   */
  readonly fields: UsuarioExecucaoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UsuarioExecucao.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UsuarioExecucaoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    empresa<T extends UsuarioGerenciamentoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsuarioGerenciamentoDefaultArgs<ExtArgs>>): Prisma__UsuarioGerenciamentoClient<$Result.GetResult<Prisma.$UsuarioGerenciamentoPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    obrasResponsavel<T extends UsuarioExecucao$obrasResponsavelArgs<ExtArgs> = {}>(args?: Subset<T, UsuarioExecucao$obrasResponsavelArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ObraPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UsuarioExecucao model
   */ 
  interface UsuarioExecucaoFieldRefs {
    readonly id: FieldRef<"UsuarioExecucao", 'Int'>
    readonly nome: FieldRef<"UsuarioExecucao", 'String'>
    readonly cpf: FieldRef<"UsuarioExecucao", 'String'>
    readonly endereco: FieldRef<"UsuarioExecucao", 'String'>
    readonly creaCau: FieldRef<"UsuarioExecucao", 'String'>
    readonly telefone: FieldRef<"UsuarioExecucao", 'String'>
    readonly email: FieldRef<"UsuarioExecucao", 'String'>
    readonly dataNascimento: FieldRef<"UsuarioExecucao", 'DateTime'>
    readonly senhaHash: FieldRef<"UsuarioExecucao", 'String'>
    readonly role: FieldRef<"UsuarioExecucao", 'Role'>
    readonly empresaId: FieldRef<"UsuarioExecucao", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * UsuarioExecucao findUnique
   */
  export type UsuarioExecucaoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsuarioExecucao
     */
    select?: UsuarioExecucaoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioExecucaoInclude<ExtArgs> | null
    /**
     * Filter, which UsuarioExecucao to fetch.
     */
    where: UsuarioExecucaoWhereUniqueInput
  }

  /**
   * UsuarioExecucao findUniqueOrThrow
   */
  export type UsuarioExecucaoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsuarioExecucao
     */
    select?: UsuarioExecucaoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioExecucaoInclude<ExtArgs> | null
    /**
     * Filter, which UsuarioExecucao to fetch.
     */
    where: UsuarioExecucaoWhereUniqueInput
  }

  /**
   * UsuarioExecucao findFirst
   */
  export type UsuarioExecucaoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsuarioExecucao
     */
    select?: UsuarioExecucaoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioExecucaoInclude<ExtArgs> | null
    /**
     * Filter, which UsuarioExecucao to fetch.
     */
    where?: UsuarioExecucaoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UsuarioExecucaos to fetch.
     */
    orderBy?: UsuarioExecucaoOrderByWithRelationInput | UsuarioExecucaoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UsuarioExecucaos.
     */
    cursor?: UsuarioExecucaoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UsuarioExecucaos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UsuarioExecucaos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UsuarioExecucaos.
     */
    distinct?: UsuarioExecucaoScalarFieldEnum | UsuarioExecucaoScalarFieldEnum[]
  }

  /**
   * UsuarioExecucao findFirstOrThrow
   */
  export type UsuarioExecucaoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsuarioExecucao
     */
    select?: UsuarioExecucaoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioExecucaoInclude<ExtArgs> | null
    /**
     * Filter, which UsuarioExecucao to fetch.
     */
    where?: UsuarioExecucaoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UsuarioExecucaos to fetch.
     */
    orderBy?: UsuarioExecucaoOrderByWithRelationInput | UsuarioExecucaoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UsuarioExecucaos.
     */
    cursor?: UsuarioExecucaoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UsuarioExecucaos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UsuarioExecucaos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UsuarioExecucaos.
     */
    distinct?: UsuarioExecucaoScalarFieldEnum | UsuarioExecucaoScalarFieldEnum[]
  }

  /**
   * UsuarioExecucao findMany
   */
  export type UsuarioExecucaoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsuarioExecucao
     */
    select?: UsuarioExecucaoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioExecucaoInclude<ExtArgs> | null
    /**
     * Filter, which UsuarioExecucaos to fetch.
     */
    where?: UsuarioExecucaoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UsuarioExecucaos to fetch.
     */
    orderBy?: UsuarioExecucaoOrderByWithRelationInput | UsuarioExecucaoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UsuarioExecucaos.
     */
    cursor?: UsuarioExecucaoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UsuarioExecucaos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UsuarioExecucaos.
     */
    skip?: number
    distinct?: UsuarioExecucaoScalarFieldEnum | UsuarioExecucaoScalarFieldEnum[]
  }

  /**
   * UsuarioExecucao create
   */
  export type UsuarioExecucaoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsuarioExecucao
     */
    select?: UsuarioExecucaoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioExecucaoInclude<ExtArgs> | null
    /**
     * The data needed to create a UsuarioExecucao.
     */
    data: XOR<UsuarioExecucaoCreateInput, UsuarioExecucaoUncheckedCreateInput>
  }

  /**
   * UsuarioExecucao createMany
   */
  export type UsuarioExecucaoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UsuarioExecucaos.
     */
    data: UsuarioExecucaoCreateManyInput | UsuarioExecucaoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UsuarioExecucao createManyAndReturn
   */
  export type UsuarioExecucaoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsuarioExecucao
     */
    select?: UsuarioExecucaoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many UsuarioExecucaos.
     */
    data: UsuarioExecucaoCreateManyInput | UsuarioExecucaoCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioExecucaoIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UsuarioExecucao update
   */
  export type UsuarioExecucaoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsuarioExecucao
     */
    select?: UsuarioExecucaoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioExecucaoInclude<ExtArgs> | null
    /**
     * The data needed to update a UsuarioExecucao.
     */
    data: XOR<UsuarioExecucaoUpdateInput, UsuarioExecucaoUncheckedUpdateInput>
    /**
     * Choose, which UsuarioExecucao to update.
     */
    where: UsuarioExecucaoWhereUniqueInput
  }

  /**
   * UsuarioExecucao updateMany
   */
  export type UsuarioExecucaoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UsuarioExecucaos.
     */
    data: XOR<UsuarioExecucaoUpdateManyMutationInput, UsuarioExecucaoUncheckedUpdateManyInput>
    /**
     * Filter which UsuarioExecucaos to update
     */
    where?: UsuarioExecucaoWhereInput
  }

  /**
   * UsuarioExecucao upsert
   */
  export type UsuarioExecucaoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsuarioExecucao
     */
    select?: UsuarioExecucaoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioExecucaoInclude<ExtArgs> | null
    /**
     * The filter to search for the UsuarioExecucao to update in case it exists.
     */
    where: UsuarioExecucaoWhereUniqueInput
    /**
     * In case the UsuarioExecucao found by the `where` argument doesn't exist, create a new UsuarioExecucao with this data.
     */
    create: XOR<UsuarioExecucaoCreateInput, UsuarioExecucaoUncheckedCreateInput>
    /**
     * In case the UsuarioExecucao was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UsuarioExecucaoUpdateInput, UsuarioExecucaoUncheckedUpdateInput>
  }

  /**
   * UsuarioExecucao delete
   */
  export type UsuarioExecucaoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsuarioExecucao
     */
    select?: UsuarioExecucaoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioExecucaoInclude<ExtArgs> | null
    /**
     * Filter which UsuarioExecucao to delete.
     */
    where: UsuarioExecucaoWhereUniqueInput
  }

  /**
   * UsuarioExecucao deleteMany
   */
  export type UsuarioExecucaoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UsuarioExecucaos to delete
     */
    where?: UsuarioExecucaoWhereInput
  }

  /**
   * UsuarioExecucao.obrasResponsavel
   */
  export type UsuarioExecucao$obrasResponsavelArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Obra
     */
    select?: ObraSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ObraInclude<ExtArgs> | null
    where?: ObraWhereInput
    orderBy?: ObraOrderByWithRelationInput | ObraOrderByWithRelationInput[]
    cursor?: ObraWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ObraScalarFieldEnum | ObraScalarFieldEnum[]
  }

  /**
   * UsuarioExecucao without action
   */
  export type UsuarioExecucaoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsuarioExecucao
     */
    select?: UsuarioExecucaoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioExecucaoInclude<ExtArgs> | null
  }


  /**
   * Model Obra
   */

  export type AggregateObra = {
    _count: ObraCountAggregateOutputType | null
    _avg: ObraAvgAggregateOutputType | null
    _sum: ObraSumAggregateOutputType | null
    _min: ObraMinAggregateOutputType | null
    _max: ObraMaxAggregateOutputType | null
  }

  export type ObraAvgAggregateOutputType = {
    id: number | null
    gerenteId: number | null
    responsavelId: number | null
  }

  export type ObraSumAggregateOutputType = {
    id: number | null
    gerenteId: number | null
    responsavelId: number | null
  }

  export type ObraMinAggregateOutputType = {
    id: number | null
    tipoObra: $Enums.TipoObra | null
    endereco: string | null
    creaCauResponsavel: string | null
    cno: string | null
    gerenteId: number | null
    responsavelId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ObraMaxAggregateOutputType = {
    id: number | null
    tipoObra: $Enums.TipoObra | null
    endereco: string | null
    creaCauResponsavel: string | null
    cno: string | null
    gerenteId: number | null
    responsavelId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ObraCountAggregateOutputType = {
    id: number
    tipoObra: number
    endereco: number
    creaCauResponsavel: number
    cno: number
    gerenteId: number
    responsavelId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ObraAvgAggregateInputType = {
    id?: true
    gerenteId?: true
    responsavelId?: true
  }

  export type ObraSumAggregateInputType = {
    id?: true
    gerenteId?: true
    responsavelId?: true
  }

  export type ObraMinAggregateInputType = {
    id?: true
    tipoObra?: true
    endereco?: true
    creaCauResponsavel?: true
    cno?: true
    gerenteId?: true
    responsavelId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ObraMaxAggregateInputType = {
    id?: true
    tipoObra?: true
    endereco?: true
    creaCauResponsavel?: true
    cno?: true
    gerenteId?: true
    responsavelId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ObraCountAggregateInputType = {
    id?: true
    tipoObra?: true
    endereco?: true
    creaCauResponsavel?: true
    cno?: true
    gerenteId?: true
    responsavelId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ObraAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Obra to aggregate.
     */
    where?: ObraWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Obras to fetch.
     */
    orderBy?: ObraOrderByWithRelationInput | ObraOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ObraWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Obras from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Obras.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Obras
    **/
    _count?: true | ObraCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ObraAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ObraSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ObraMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ObraMaxAggregateInputType
  }

  export type GetObraAggregateType<T extends ObraAggregateArgs> = {
        [P in keyof T & keyof AggregateObra]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateObra[P]>
      : GetScalarType<T[P], AggregateObra[P]>
  }




  export type ObraGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ObraWhereInput
    orderBy?: ObraOrderByWithAggregationInput | ObraOrderByWithAggregationInput[]
    by: ObraScalarFieldEnum[] | ObraScalarFieldEnum
    having?: ObraScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ObraCountAggregateInputType | true
    _avg?: ObraAvgAggregateInputType
    _sum?: ObraSumAggregateInputType
    _min?: ObraMinAggregateInputType
    _max?: ObraMaxAggregateInputType
  }

  export type ObraGroupByOutputType = {
    id: number
    tipoObra: $Enums.TipoObra
    endereco: string
    creaCauResponsavel: string
    cno: string
    gerenteId: number
    responsavelId: number
    createdAt: Date
    updatedAt: Date
    _count: ObraCountAggregateOutputType | null
    _avg: ObraAvgAggregateOutputType | null
    _sum: ObraSumAggregateOutputType | null
    _min: ObraMinAggregateOutputType | null
    _max: ObraMaxAggregateOutputType | null
  }

  type GetObraGroupByPayload<T extends ObraGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ObraGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ObraGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ObraGroupByOutputType[P]>
            : GetScalarType<T[P], ObraGroupByOutputType[P]>
        }
      >
    >


  export type ObraSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tipoObra?: boolean
    endereco?: boolean
    creaCauResponsavel?: boolean
    cno?: boolean
    gerenteId?: boolean
    responsavelId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    gerente?: boolean | UsuarioGerenciamentoDefaultArgs<ExtArgs>
    responsavel?: boolean | UsuarioExecucaoDefaultArgs<ExtArgs>
    etapas?: boolean | Obra$etapasArgs<ExtArgs>
    materiaisPedidos?: boolean | Obra$materiaisPedidosArgs<ExtArgs>
    lembretes?: boolean | Obra$lembretesArgs<ExtArgs>
    _count?: boolean | ObraCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["obra"]>

  export type ObraSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tipoObra?: boolean
    endereco?: boolean
    creaCauResponsavel?: boolean
    cno?: boolean
    gerenteId?: boolean
    responsavelId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    gerente?: boolean | UsuarioGerenciamentoDefaultArgs<ExtArgs>
    responsavel?: boolean | UsuarioExecucaoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["obra"]>

  export type ObraSelectScalar = {
    id?: boolean
    tipoObra?: boolean
    endereco?: boolean
    creaCauResponsavel?: boolean
    cno?: boolean
    gerenteId?: boolean
    responsavelId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ObraInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    gerente?: boolean | UsuarioGerenciamentoDefaultArgs<ExtArgs>
    responsavel?: boolean | UsuarioExecucaoDefaultArgs<ExtArgs>
    etapas?: boolean | Obra$etapasArgs<ExtArgs>
    materiaisPedidos?: boolean | Obra$materiaisPedidosArgs<ExtArgs>
    lembretes?: boolean | Obra$lembretesArgs<ExtArgs>
    _count?: boolean | ObraCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ObraIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    gerente?: boolean | UsuarioGerenciamentoDefaultArgs<ExtArgs>
    responsavel?: boolean | UsuarioExecucaoDefaultArgs<ExtArgs>
  }

  export type $ObraPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Obra"
    objects: {
      gerente: Prisma.$UsuarioGerenciamentoPayload<ExtArgs>
      responsavel: Prisma.$UsuarioExecucaoPayload<ExtArgs>
      etapas: Prisma.$EtapaObraPayload<ExtArgs>[]
      materiaisPedidos: Prisma.$MaterialObraPayload<ExtArgs>[]
      lembretes: Prisma.$LembreteMaterialPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      tipoObra: $Enums.TipoObra
      endereco: string
      creaCauResponsavel: string
      cno: string
      gerenteId: number
      responsavelId: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["obra"]>
    composites: {}
  }

  type ObraGetPayload<S extends boolean | null | undefined | ObraDefaultArgs> = $Result.GetResult<Prisma.$ObraPayload, S>

  type ObraCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ObraFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ObraCountAggregateInputType | true
    }

  export interface ObraDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Obra'], meta: { name: 'Obra' } }
    /**
     * Find zero or one Obra that matches the filter.
     * @param {ObraFindUniqueArgs} args - Arguments to find a Obra
     * @example
     * // Get one Obra
     * const obra = await prisma.obra.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ObraFindUniqueArgs>(args: SelectSubset<T, ObraFindUniqueArgs<ExtArgs>>): Prisma__ObraClient<$Result.GetResult<Prisma.$ObraPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Obra that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ObraFindUniqueOrThrowArgs} args - Arguments to find a Obra
     * @example
     * // Get one Obra
     * const obra = await prisma.obra.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ObraFindUniqueOrThrowArgs>(args: SelectSubset<T, ObraFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ObraClient<$Result.GetResult<Prisma.$ObraPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Obra that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ObraFindFirstArgs} args - Arguments to find a Obra
     * @example
     * // Get one Obra
     * const obra = await prisma.obra.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ObraFindFirstArgs>(args?: SelectSubset<T, ObraFindFirstArgs<ExtArgs>>): Prisma__ObraClient<$Result.GetResult<Prisma.$ObraPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Obra that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ObraFindFirstOrThrowArgs} args - Arguments to find a Obra
     * @example
     * // Get one Obra
     * const obra = await prisma.obra.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ObraFindFirstOrThrowArgs>(args?: SelectSubset<T, ObraFindFirstOrThrowArgs<ExtArgs>>): Prisma__ObraClient<$Result.GetResult<Prisma.$ObraPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Obras that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ObraFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Obras
     * const obras = await prisma.obra.findMany()
     * 
     * // Get first 10 Obras
     * const obras = await prisma.obra.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const obraWithIdOnly = await prisma.obra.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ObraFindManyArgs>(args?: SelectSubset<T, ObraFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ObraPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Obra.
     * @param {ObraCreateArgs} args - Arguments to create a Obra.
     * @example
     * // Create one Obra
     * const Obra = await prisma.obra.create({
     *   data: {
     *     // ... data to create a Obra
     *   }
     * })
     * 
     */
    create<T extends ObraCreateArgs>(args: SelectSubset<T, ObraCreateArgs<ExtArgs>>): Prisma__ObraClient<$Result.GetResult<Prisma.$ObraPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Obras.
     * @param {ObraCreateManyArgs} args - Arguments to create many Obras.
     * @example
     * // Create many Obras
     * const obra = await prisma.obra.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ObraCreateManyArgs>(args?: SelectSubset<T, ObraCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Obras and returns the data saved in the database.
     * @param {ObraCreateManyAndReturnArgs} args - Arguments to create many Obras.
     * @example
     * // Create many Obras
     * const obra = await prisma.obra.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Obras and only return the `id`
     * const obraWithIdOnly = await prisma.obra.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ObraCreateManyAndReturnArgs>(args?: SelectSubset<T, ObraCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ObraPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Obra.
     * @param {ObraDeleteArgs} args - Arguments to delete one Obra.
     * @example
     * // Delete one Obra
     * const Obra = await prisma.obra.delete({
     *   where: {
     *     // ... filter to delete one Obra
     *   }
     * })
     * 
     */
    delete<T extends ObraDeleteArgs>(args: SelectSubset<T, ObraDeleteArgs<ExtArgs>>): Prisma__ObraClient<$Result.GetResult<Prisma.$ObraPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Obra.
     * @param {ObraUpdateArgs} args - Arguments to update one Obra.
     * @example
     * // Update one Obra
     * const obra = await prisma.obra.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ObraUpdateArgs>(args: SelectSubset<T, ObraUpdateArgs<ExtArgs>>): Prisma__ObraClient<$Result.GetResult<Prisma.$ObraPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Obras.
     * @param {ObraDeleteManyArgs} args - Arguments to filter Obras to delete.
     * @example
     * // Delete a few Obras
     * const { count } = await prisma.obra.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ObraDeleteManyArgs>(args?: SelectSubset<T, ObraDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Obras.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ObraUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Obras
     * const obra = await prisma.obra.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ObraUpdateManyArgs>(args: SelectSubset<T, ObraUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Obra.
     * @param {ObraUpsertArgs} args - Arguments to update or create a Obra.
     * @example
     * // Update or create a Obra
     * const obra = await prisma.obra.upsert({
     *   create: {
     *     // ... data to create a Obra
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Obra we want to update
     *   }
     * })
     */
    upsert<T extends ObraUpsertArgs>(args: SelectSubset<T, ObraUpsertArgs<ExtArgs>>): Prisma__ObraClient<$Result.GetResult<Prisma.$ObraPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Obras.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ObraCountArgs} args - Arguments to filter Obras to count.
     * @example
     * // Count the number of Obras
     * const count = await prisma.obra.count({
     *   where: {
     *     // ... the filter for the Obras we want to count
     *   }
     * })
    **/
    count<T extends ObraCountArgs>(
      args?: Subset<T, ObraCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ObraCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Obra.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ObraAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ObraAggregateArgs>(args: Subset<T, ObraAggregateArgs>): Prisma.PrismaPromise<GetObraAggregateType<T>>

    /**
     * Group by Obra.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ObraGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ObraGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ObraGroupByArgs['orderBy'] }
        : { orderBy?: ObraGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ObraGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetObraGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Obra model
   */
  readonly fields: ObraFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Obra.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ObraClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    gerente<T extends UsuarioGerenciamentoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsuarioGerenciamentoDefaultArgs<ExtArgs>>): Prisma__UsuarioGerenciamentoClient<$Result.GetResult<Prisma.$UsuarioGerenciamentoPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    responsavel<T extends UsuarioExecucaoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsuarioExecucaoDefaultArgs<ExtArgs>>): Prisma__UsuarioExecucaoClient<$Result.GetResult<Prisma.$UsuarioExecucaoPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    etapas<T extends Obra$etapasArgs<ExtArgs> = {}>(args?: Subset<T, Obra$etapasArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EtapaObraPayload<ExtArgs>, T, "findMany"> | Null>
    materiaisPedidos<T extends Obra$materiaisPedidosArgs<ExtArgs> = {}>(args?: Subset<T, Obra$materiaisPedidosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MaterialObraPayload<ExtArgs>, T, "findMany"> | Null>
    lembretes<T extends Obra$lembretesArgs<ExtArgs> = {}>(args?: Subset<T, Obra$lembretesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LembreteMaterialPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Obra model
   */ 
  interface ObraFieldRefs {
    readonly id: FieldRef<"Obra", 'Int'>
    readonly tipoObra: FieldRef<"Obra", 'TipoObra'>
    readonly endereco: FieldRef<"Obra", 'String'>
    readonly creaCauResponsavel: FieldRef<"Obra", 'String'>
    readonly cno: FieldRef<"Obra", 'String'>
    readonly gerenteId: FieldRef<"Obra", 'Int'>
    readonly responsavelId: FieldRef<"Obra", 'Int'>
    readonly createdAt: FieldRef<"Obra", 'DateTime'>
    readonly updatedAt: FieldRef<"Obra", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Obra findUnique
   */
  export type ObraFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Obra
     */
    select?: ObraSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ObraInclude<ExtArgs> | null
    /**
     * Filter, which Obra to fetch.
     */
    where: ObraWhereUniqueInput
  }

  /**
   * Obra findUniqueOrThrow
   */
  export type ObraFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Obra
     */
    select?: ObraSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ObraInclude<ExtArgs> | null
    /**
     * Filter, which Obra to fetch.
     */
    where: ObraWhereUniqueInput
  }

  /**
   * Obra findFirst
   */
  export type ObraFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Obra
     */
    select?: ObraSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ObraInclude<ExtArgs> | null
    /**
     * Filter, which Obra to fetch.
     */
    where?: ObraWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Obras to fetch.
     */
    orderBy?: ObraOrderByWithRelationInput | ObraOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Obras.
     */
    cursor?: ObraWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Obras from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Obras.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Obras.
     */
    distinct?: ObraScalarFieldEnum | ObraScalarFieldEnum[]
  }

  /**
   * Obra findFirstOrThrow
   */
  export type ObraFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Obra
     */
    select?: ObraSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ObraInclude<ExtArgs> | null
    /**
     * Filter, which Obra to fetch.
     */
    where?: ObraWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Obras to fetch.
     */
    orderBy?: ObraOrderByWithRelationInput | ObraOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Obras.
     */
    cursor?: ObraWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Obras from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Obras.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Obras.
     */
    distinct?: ObraScalarFieldEnum | ObraScalarFieldEnum[]
  }

  /**
   * Obra findMany
   */
  export type ObraFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Obra
     */
    select?: ObraSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ObraInclude<ExtArgs> | null
    /**
     * Filter, which Obras to fetch.
     */
    where?: ObraWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Obras to fetch.
     */
    orderBy?: ObraOrderByWithRelationInput | ObraOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Obras.
     */
    cursor?: ObraWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Obras from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Obras.
     */
    skip?: number
    distinct?: ObraScalarFieldEnum | ObraScalarFieldEnum[]
  }

  /**
   * Obra create
   */
  export type ObraCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Obra
     */
    select?: ObraSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ObraInclude<ExtArgs> | null
    /**
     * The data needed to create a Obra.
     */
    data: XOR<ObraCreateInput, ObraUncheckedCreateInput>
  }

  /**
   * Obra createMany
   */
  export type ObraCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Obras.
     */
    data: ObraCreateManyInput | ObraCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Obra createManyAndReturn
   */
  export type ObraCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Obra
     */
    select?: ObraSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Obras.
     */
    data: ObraCreateManyInput | ObraCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ObraIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Obra update
   */
  export type ObraUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Obra
     */
    select?: ObraSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ObraInclude<ExtArgs> | null
    /**
     * The data needed to update a Obra.
     */
    data: XOR<ObraUpdateInput, ObraUncheckedUpdateInput>
    /**
     * Choose, which Obra to update.
     */
    where: ObraWhereUniqueInput
  }

  /**
   * Obra updateMany
   */
  export type ObraUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Obras.
     */
    data: XOR<ObraUpdateManyMutationInput, ObraUncheckedUpdateManyInput>
    /**
     * Filter which Obras to update
     */
    where?: ObraWhereInput
  }

  /**
   * Obra upsert
   */
  export type ObraUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Obra
     */
    select?: ObraSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ObraInclude<ExtArgs> | null
    /**
     * The filter to search for the Obra to update in case it exists.
     */
    where: ObraWhereUniqueInput
    /**
     * In case the Obra found by the `where` argument doesn't exist, create a new Obra with this data.
     */
    create: XOR<ObraCreateInput, ObraUncheckedCreateInput>
    /**
     * In case the Obra was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ObraUpdateInput, ObraUncheckedUpdateInput>
  }

  /**
   * Obra delete
   */
  export type ObraDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Obra
     */
    select?: ObraSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ObraInclude<ExtArgs> | null
    /**
     * Filter which Obra to delete.
     */
    where: ObraWhereUniqueInput
  }

  /**
   * Obra deleteMany
   */
  export type ObraDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Obras to delete
     */
    where?: ObraWhereInput
  }

  /**
   * Obra.etapas
   */
  export type Obra$etapasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EtapaObra
     */
    select?: EtapaObraSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EtapaObraInclude<ExtArgs> | null
    where?: EtapaObraWhereInput
    orderBy?: EtapaObraOrderByWithRelationInput | EtapaObraOrderByWithRelationInput[]
    cursor?: EtapaObraWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EtapaObraScalarFieldEnum | EtapaObraScalarFieldEnum[]
  }

  /**
   * Obra.materiaisPedidos
   */
  export type Obra$materiaisPedidosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaterialObra
     */
    select?: MaterialObraSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialObraInclude<ExtArgs> | null
    where?: MaterialObraWhereInput
    orderBy?: MaterialObraOrderByWithRelationInput | MaterialObraOrderByWithRelationInput[]
    cursor?: MaterialObraWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MaterialObraScalarFieldEnum | MaterialObraScalarFieldEnum[]
  }

  /**
   * Obra.lembretes
   */
  export type Obra$lembretesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LembreteMaterial
     */
    select?: LembreteMaterialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LembreteMaterialInclude<ExtArgs> | null
    where?: LembreteMaterialWhereInput
    orderBy?: LembreteMaterialOrderByWithRelationInput | LembreteMaterialOrderByWithRelationInput[]
    cursor?: LembreteMaterialWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LembreteMaterialScalarFieldEnum | LembreteMaterialScalarFieldEnum[]
  }

  /**
   * Obra without action
   */
  export type ObraDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Obra
     */
    select?: ObraSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ObraInclude<ExtArgs> | null
  }


  /**
   * Model JustificativaAtraso
   */

  export type AggregateJustificativaAtraso = {
    _count: JustificativaAtrasoCountAggregateOutputType | null
    _avg: JustificativaAtrasoAvgAggregateOutputType | null
    _sum: JustificativaAtrasoSumAggregateOutputType | null
    _min: JustificativaAtrasoMinAggregateOutputType | null
    _max: JustificativaAtrasoMaxAggregateOutputType | null
  }

  export type JustificativaAtrasoAvgAggregateOutputType = {
    id: number | null
  }

  export type JustificativaAtrasoSumAggregateOutputType = {
    id: number | null
  }

  export type JustificativaAtrasoMinAggregateOutputType = {
    id: number | null
    tipo: $Enums.TipoJustificativa | null
    descricao: string | null
    createdAt: Date | null
  }

  export type JustificativaAtrasoMaxAggregateOutputType = {
    id: number | null
    tipo: $Enums.TipoJustificativa | null
    descricao: string | null
    createdAt: Date | null
  }

  export type JustificativaAtrasoCountAggregateOutputType = {
    id: number
    tipo: number
    descricao: number
    createdAt: number
    _all: number
  }


  export type JustificativaAtrasoAvgAggregateInputType = {
    id?: true
  }

  export type JustificativaAtrasoSumAggregateInputType = {
    id?: true
  }

  export type JustificativaAtrasoMinAggregateInputType = {
    id?: true
    tipo?: true
    descricao?: true
    createdAt?: true
  }

  export type JustificativaAtrasoMaxAggregateInputType = {
    id?: true
    tipo?: true
    descricao?: true
    createdAt?: true
  }

  export type JustificativaAtrasoCountAggregateInputType = {
    id?: true
    tipo?: true
    descricao?: true
    createdAt?: true
    _all?: true
  }

  export type JustificativaAtrasoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which JustificativaAtraso to aggregate.
     */
    where?: JustificativaAtrasoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JustificativaAtrasos to fetch.
     */
    orderBy?: JustificativaAtrasoOrderByWithRelationInput | JustificativaAtrasoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: JustificativaAtrasoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JustificativaAtrasos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JustificativaAtrasos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned JustificativaAtrasos
    **/
    _count?: true | JustificativaAtrasoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: JustificativaAtrasoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: JustificativaAtrasoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: JustificativaAtrasoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: JustificativaAtrasoMaxAggregateInputType
  }

  export type GetJustificativaAtrasoAggregateType<T extends JustificativaAtrasoAggregateArgs> = {
        [P in keyof T & keyof AggregateJustificativaAtraso]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateJustificativaAtraso[P]>
      : GetScalarType<T[P], AggregateJustificativaAtraso[P]>
  }




  export type JustificativaAtrasoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JustificativaAtrasoWhereInput
    orderBy?: JustificativaAtrasoOrderByWithAggregationInput | JustificativaAtrasoOrderByWithAggregationInput[]
    by: JustificativaAtrasoScalarFieldEnum[] | JustificativaAtrasoScalarFieldEnum
    having?: JustificativaAtrasoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: JustificativaAtrasoCountAggregateInputType | true
    _avg?: JustificativaAtrasoAvgAggregateInputType
    _sum?: JustificativaAtrasoSumAggregateInputType
    _min?: JustificativaAtrasoMinAggregateInputType
    _max?: JustificativaAtrasoMaxAggregateInputType
  }

  export type JustificativaAtrasoGroupByOutputType = {
    id: number
    tipo: $Enums.TipoJustificativa
    descricao: string | null
    createdAt: Date
    _count: JustificativaAtrasoCountAggregateOutputType | null
    _avg: JustificativaAtrasoAvgAggregateOutputType | null
    _sum: JustificativaAtrasoSumAggregateOutputType | null
    _min: JustificativaAtrasoMinAggregateOutputType | null
    _max: JustificativaAtrasoMaxAggregateOutputType | null
  }

  type GetJustificativaAtrasoGroupByPayload<T extends JustificativaAtrasoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<JustificativaAtrasoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof JustificativaAtrasoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], JustificativaAtrasoGroupByOutputType[P]>
            : GetScalarType<T[P], JustificativaAtrasoGroupByOutputType[P]>
        }
      >
    >


  export type JustificativaAtrasoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tipo?: boolean
    descricao?: boolean
    createdAt?: boolean
    etapas?: boolean | JustificativaAtraso$etapasArgs<ExtArgs>
    _count?: boolean | JustificativaAtrasoCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["justificativaAtraso"]>

  export type JustificativaAtrasoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tipo?: boolean
    descricao?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["justificativaAtraso"]>

  export type JustificativaAtrasoSelectScalar = {
    id?: boolean
    tipo?: boolean
    descricao?: boolean
    createdAt?: boolean
  }

  export type JustificativaAtrasoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    etapas?: boolean | JustificativaAtraso$etapasArgs<ExtArgs>
    _count?: boolean | JustificativaAtrasoCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type JustificativaAtrasoIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $JustificativaAtrasoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "JustificativaAtraso"
    objects: {
      etapas: Prisma.$EtapaObraPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      tipo: $Enums.TipoJustificativa
      descricao: string | null
      createdAt: Date
    }, ExtArgs["result"]["justificativaAtraso"]>
    composites: {}
  }

  type JustificativaAtrasoGetPayload<S extends boolean | null | undefined | JustificativaAtrasoDefaultArgs> = $Result.GetResult<Prisma.$JustificativaAtrasoPayload, S>

  type JustificativaAtrasoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<JustificativaAtrasoFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: JustificativaAtrasoCountAggregateInputType | true
    }

  export interface JustificativaAtrasoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['JustificativaAtraso'], meta: { name: 'JustificativaAtraso' } }
    /**
     * Find zero or one JustificativaAtraso that matches the filter.
     * @param {JustificativaAtrasoFindUniqueArgs} args - Arguments to find a JustificativaAtraso
     * @example
     * // Get one JustificativaAtraso
     * const justificativaAtraso = await prisma.justificativaAtraso.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends JustificativaAtrasoFindUniqueArgs>(args: SelectSubset<T, JustificativaAtrasoFindUniqueArgs<ExtArgs>>): Prisma__JustificativaAtrasoClient<$Result.GetResult<Prisma.$JustificativaAtrasoPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one JustificativaAtraso that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {JustificativaAtrasoFindUniqueOrThrowArgs} args - Arguments to find a JustificativaAtraso
     * @example
     * // Get one JustificativaAtraso
     * const justificativaAtraso = await prisma.justificativaAtraso.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends JustificativaAtrasoFindUniqueOrThrowArgs>(args: SelectSubset<T, JustificativaAtrasoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__JustificativaAtrasoClient<$Result.GetResult<Prisma.$JustificativaAtrasoPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first JustificativaAtraso that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JustificativaAtrasoFindFirstArgs} args - Arguments to find a JustificativaAtraso
     * @example
     * // Get one JustificativaAtraso
     * const justificativaAtraso = await prisma.justificativaAtraso.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends JustificativaAtrasoFindFirstArgs>(args?: SelectSubset<T, JustificativaAtrasoFindFirstArgs<ExtArgs>>): Prisma__JustificativaAtrasoClient<$Result.GetResult<Prisma.$JustificativaAtrasoPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first JustificativaAtraso that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JustificativaAtrasoFindFirstOrThrowArgs} args - Arguments to find a JustificativaAtraso
     * @example
     * // Get one JustificativaAtraso
     * const justificativaAtraso = await prisma.justificativaAtraso.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends JustificativaAtrasoFindFirstOrThrowArgs>(args?: SelectSubset<T, JustificativaAtrasoFindFirstOrThrowArgs<ExtArgs>>): Prisma__JustificativaAtrasoClient<$Result.GetResult<Prisma.$JustificativaAtrasoPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more JustificativaAtrasos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JustificativaAtrasoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all JustificativaAtrasos
     * const justificativaAtrasos = await prisma.justificativaAtraso.findMany()
     * 
     * // Get first 10 JustificativaAtrasos
     * const justificativaAtrasos = await prisma.justificativaAtraso.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const justificativaAtrasoWithIdOnly = await prisma.justificativaAtraso.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends JustificativaAtrasoFindManyArgs>(args?: SelectSubset<T, JustificativaAtrasoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JustificativaAtrasoPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a JustificativaAtraso.
     * @param {JustificativaAtrasoCreateArgs} args - Arguments to create a JustificativaAtraso.
     * @example
     * // Create one JustificativaAtraso
     * const JustificativaAtraso = await prisma.justificativaAtraso.create({
     *   data: {
     *     // ... data to create a JustificativaAtraso
     *   }
     * })
     * 
     */
    create<T extends JustificativaAtrasoCreateArgs>(args: SelectSubset<T, JustificativaAtrasoCreateArgs<ExtArgs>>): Prisma__JustificativaAtrasoClient<$Result.GetResult<Prisma.$JustificativaAtrasoPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many JustificativaAtrasos.
     * @param {JustificativaAtrasoCreateManyArgs} args - Arguments to create many JustificativaAtrasos.
     * @example
     * // Create many JustificativaAtrasos
     * const justificativaAtraso = await prisma.justificativaAtraso.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends JustificativaAtrasoCreateManyArgs>(args?: SelectSubset<T, JustificativaAtrasoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many JustificativaAtrasos and returns the data saved in the database.
     * @param {JustificativaAtrasoCreateManyAndReturnArgs} args - Arguments to create many JustificativaAtrasos.
     * @example
     * // Create many JustificativaAtrasos
     * const justificativaAtraso = await prisma.justificativaAtraso.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many JustificativaAtrasos and only return the `id`
     * const justificativaAtrasoWithIdOnly = await prisma.justificativaAtraso.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends JustificativaAtrasoCreateManyAndReturnArgs>(args?: SelectSubset<T, JustificativaAtrasoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JustificativaAtrasoPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a JustificativaAtraso.
     * @param {JustificativaAtrasoDeleteArgs} args - Arguments to delete one JustificativaAtraso.
     * @example
     * // Delete one JustificativaAtraso
     * const JustificativaAtraso = await prisma.justificativaAtraso.delete({
     *   where: {
     *     // ... filter to delete one JustificativaAtraso
     *   }
     * })
     * 
     */
    delete<T extends JustificativaAtrasoDeleteArgs>(args: SelectSubset<T, JustificativaAtrasoDeleteArgs<ExtArgs>>): Prisma__JustificativaAtrasoClient<$Result.GetResult<Prisma.$JustificativaAtrasoPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one JustificativaAtraso.
     * @param {JustificativaAtrasoUpdateArgs} args - Arguments to update one JustificativaAtraso.
     * @example
     * // Update one JustificativaAtraso
     * const justificativaAtraso = await prisma.justificativaAtraso.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends JustificativaAtrasoUpdateArgs>(args: SelectSubset<T, JustificativaAtrasoUpdateArgs<ExtArgs>>): Prisma__JustificativaAtrasoClient<$Result.GetResult<Prisma.$JustificativaAtrasoPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more JustificativaAtrasos.
     * @param {JustificativaAtrasoDeleteManyArgs} args - Arguments to filter JustificativaAtrasos to delete.
     * @example
     * // Delete a few JustificativaAtrasos
     * const { count } = await prisma.justificativaAtraso.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends JustificativaAtrasoDeleteManyArgs>(args?: SelectSubset<T, JustificativaAtrasoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more JustificativaAtrasos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JustificativaAtrasoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many JustificativaAtrasos
     * const justificativaAtraso = await prisma.justificativaAtraso.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends JustificativaAtrasoUpdateManyArgs>(args: SelectSubset<T, JustificativaAtrasoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one JustificativaAtraso.
     * @param {JustificativaAtrasoUpsertArgs} args - Arguments to update or create a JustificativaAtraso.
     * @example
     * // Update or create a JustificativaAtraso
     * const justificativaAtraso = await prisma.justificativaAtraso.upsert({
     *   create: {
     *     // ... data to create a JustificativaAtraso
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the JustificativaAtraso we want to update
     *   }
     * })
     */
    upsert<T extends JustificativaAtrasoUpsertArgs>(args: SelectSubset<T, JustificativaAtrasoUpsertArgs<ExtArgs>>): Prisma__JustificativaAtrasoClient<$Result.GetResult<Prisma.$JustificativaAtrasoPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of JustificativaAtrasos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JustificativaAtrasoCountArgs} args - Arguments to filter JustificativaAtrasos to count.
     * @example
     * // Count the number of JustificativaAtrasos
     * const count = await prisma.justificativaAtraso.count({
     *   where: {
     *     // ... the filter for the JustificativaAtrasos we want to count
     *   }
     * })
    **/
    count<T extends JustificativaAtrasoCountArgs>(
      args?: Subset<T, JustificativaAtrasoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], JustificativaAtrasoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a JustificativaAtraso.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JustificativaAtrasoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends JustificativaAtrasoAggregateArgs>(args: Subset<T, JustificativaAtrasoAggregateArgs>): Prisma.PrismaPromise<GetJustificativaAtrasoAggregateType<T>>

    /**
     * Group by JustificativaAtraso.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JustificativaAtrasoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends JustificativaAtrasoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: JustificativaAtrasoGroupByArgs['orderBy'] }
        : { orderBy?: JustificativaAtrasoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, JustificativaAtrasoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetJustificativaAtrasoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the JustificativaAtraso model
   */
  readonly fields: JustificativaAtrasoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for JustificativaAtraso.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__JustificativaAtrasoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    etapas<T extends JustificativaAtraso$etapasArgs<ExtArgs> = {}>(args?: Subset<T, JustificativaAtraso$etapasArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EtapaObraPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the JustificativaAtraso model
   */ 
  interface JustificativaAtrasoFieldRefs {
    readonly id: FieldRef<"JustificativaAtraso", 'Int'>
    readonly tipo: FieldRef<"JustificativaAtraso", 'TipoJustificativa'>
    readonly descricao: FieldRef<"JustificativaAtraso", 'String'>
    readonly createdAt: FieldRef<"JustificativaAtraso", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * JustificativaAtraso findUnique
   */
  export type JustificativaAtrasoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JustificativaAtraso
     */
    select?: JustificativaAtrasoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JustificativaAtrasoInclude<ExtArgs> | null
    /**
     * Filter, which JustificativaAtraso to fetch.
     */
    where: JustificativaAtrasoWhereUniqueInput
  }

  /**
   * JustificativaAtraso findUniqueOrThrow
   */
  export type JustificativaAtrasoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JustificativaAtraso
     */
    select?: JustificativaAtrasoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JustificativaAtrasoInclude<ExtArgs> | null
    /**
     * Filter, which JustificativaAtraso to fetch.
     */
    where: JustificativaAtrasoWhereUniqueInput
  }

  /**
   * JustificativaAtraso findFirst
   */
  export type JustificativaAtrasoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JustificativaAtraso
     */
    select?: JustificativaAtrasoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JustificativaAtrasoInclude<ExtArgs> | null
    /**
     * Filter, which JustificativaAtraso to fetch.
     */
    where?: JustificativaAtrasoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JustificativaAtrasos to fetch.
     */
    orderBy?: JustificativaAtrasoOrderByWithRelationInput | JustificativaAtrasoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for JustificativaAtrasos.
     */
    cursor?: JustificativaAtrasoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JustificativaAtrasos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JustificativaAtrasos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of JustificativaAtrasos.
     */
    distinct?: JustificativaAtrasoScalarFieldEnum | JustificativaAtrasoScalarFieldEnum[]
  }

  /**
   * JustificativaAtraso findFirstOrThrow
   */
  export type JustificativaAtrasoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JustificativaAtraso
     */
    select?: JustificativaAtrasoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JustificativaAtrasoInclude<ExtArgs> | null
    /**
     * Filter, which JustificativaAtraso to fetch.
     */
    where?: JustificativaAtrasoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JustificativaAtrasos to fetch.
     */
    orderBy?: JustificativaAtrasoOrderByWithRelationInput | JustificativaAtrasoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for JustificativaAtrasos.
     */
    cursor?: JustificativaAtrasoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JustificativaAtrasos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JustificativaAtrasos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of JustificativaAtrasos.
     */
    distinct?: JustificativaAtrasoScalarFieldEnum | JustificativaAtrasoScalarFieldEnum[]
  }

  /**
   * JustificativaAtraso findMany
   */
  export type JustificativaAtrasoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JustificativaAtraso
     */
    select?: JustificativaAtrasoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JustificativaAtrasoInclude<ExtArgs> | null
    /**
     * Filter, which JustificativaAtrasos to fetch.
     */
    where?: JustificativaAtrasoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JustificativaAtrasos to fetch.
     */
    orderBy?: JustificativaAtrasoOrderByWithRelationInput | JustificativaAtrasoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing JustificativaAtrasos.
     */
    cursor?: JustificativaAtrasoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JustificativaAtrasos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JustificativaAtrasos.
     */
    skip?: number
    distinct?: JustificativaAtrasoScalarFieldEnum | JustificativaAtrasoScalarFieldEnum[]
  }

  /**
   * JustificativaAtraso create
   */
  export type JustificativaAtrasoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JustificativaAtraso
     */
    select?: JustificativaAtrasoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JustificativaAtrasoInclude<ExtArgs> | null
    /**
     * The data needed to create a JustificativaAtraso.
     */
    data: XOR<JustificativaAtrasoCreateInput, JustificativaAtrasoUncheckedCreateInput>
  }

  /**
   * JustificativaAtraso createMany
   */
  export type JustificativaAtrasoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many JustificativaAtrasos.
     */
    data: JustificativaAtrasoCreateManyInput | JustificativaAtrasoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * JustificativaAtraso createManyAndReturn
   */
  export type JustificativaAtrasoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JustificativaAtraso
     */
    select?: JustificativaAtrasoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many JustificativaAtrasos.
     */
    data: JustificativaAtrasoCreateManyInput | JustificativaAtrasoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * JustificativaAtraso update
   */
  export type JustificativaAtrasoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JustificativaAtraso
     */
    select?: JustificativaAtrasoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JustificativaAtrasoInclude<ExtArgs> | null
    /**
     * The data needed to update a JustificativaAtraso.
     */
    data: XOR<JustificativaAtrasoUpdateInput, JustificativaAtrasoUncheckedUpdateInput>
    /**
     * Choose, which JustificativaAtraso to update.
     */
    where: JustificativaAtrasoWhereUniqueInput
  }

  /**
   * JustificativaAtraso updateMany
   */
  export type JustificativaAtrasoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update JustificativaAtrasos.
     */
    data: XOR<JustificativaAtrasoUpdateManyMutationInput, JustificativaAtrasoUncheckedUpdateManyInput>
    /**
     * Filter which JustificativaAtrasos to update
     */
    where?: JustificativaAtrasoWhereInput
  }

  /**
   * JustificativaAtraso upsert
   */
  export type JustificativaAtrasoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JustificativaAtraso
     */
    select?: JustificativaAtrasoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JustificativaAtrasoInclude<ExtArgs> | null
    /**
     * The filter to search for the JustificativaAtraso to update in case it exists.
     */
    where: JustificativaAtrasoWhereUniqueInput
    /**
     * In case the JustificativaAtraso found by the `where` argument doesn't exist, create a new JustificativaAtraso with this data.
     */
    create: XOR<JustificativaAtrasoCreateInput, JustificativaAtrasoUncheckedCreateInput>
    /**
     * In case the JustificativaAtraso was found with the provided `where` argument, update it with this data.
     */
    update: XOR<JustificativaAtrasoUpdateInput, JustificativaAtrasoUncheckedUpdateInput>
  }

  /**
   * JustificativaAtraso delete
   */
  export type JustificativaAtrasoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JustificativaAtraso
     */
    select?: JustificativaAtrasoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JustificativaAtrasoInclude<ExtArgs> | null
    /**
     * Filter which JustificativaAtraso to delete.
     */
    where: JustificativaAtrasoWhereUniqueInput
  }

  /**
   * JustificativaAtraso deleteMany
   */
  export type JustificativaAtrasoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which JustificativaAtrasos to delete
     */
    where?: JustificativaAtrasoWhereInput
  }

  /**
   * JustificativaAtraso.etapas
   */
  export type JustificativaAtraso$etapasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EtapaObra
     */
    select?: EtapaObraSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EtapaObraInclude<ExtArgs> | null
    where?: EtapaObraWhereInput
    orderBy?: EtapaObraOrderByWithRelationInput | EtapaObraOrderByWithRelationInput[]
    cursor?: EtapaObraWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EtapaObraScalarFieldEnum | EtapaObraScalarFieldEnum[]
  }

  /**
   * JustificativaAtraso without action
   */
  export type JustificativaAtrasoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JustificativaAtraso
     */
    select?: JustificativaAtrasoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JustificativaAtrasoInclude<ExtArgs> | null
  }


  /**
   * Model EtapaObra
   */

  export type AggregateEtapaObra = {
    _count: EtapaObraCountAggregateOutputType | null
    _avg: EtapaObraAvgAggregateOutputType | null
    _sum: EtapaObraSumAggregateOutputType | null
    _min: EtapaObraMinAggregateOutputType | null
    _max: EtapaObraMaxAggregateOutputType | null
  }

  export type EtapaObraAvgAggregateOutputType = {
    id: number | null
    obraId: number | null
    justificativaId: number | null
  }

  export type EtapaObraSumAggregateOutputType = {
    id: number | null
    obraId: number | null
    justificativaId: number | null
  }

  export type EtapaObraMinAggregateOutputType = {
    id: number | null
    obraId: number | null
    tipo: $Enums.EtapaTipo | null
    subEtapa: $Enums.SubEtapaTipo | null
    status: $Enums.StatusEtapa | null
    dataPrevistaInicio: Date | null
    dataPrevistaFim: Date | null
    dataRealInicio: Date | null
    dataRealFim: Date | null
    justificativaId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EtapaObraMaxAggregateOutputType = {
    id: number | null
    obraId: number | null
    tipo: $Enums.EtapaTipo | null
    subEtapa: $Enums.SubEtapaTipo | null
    status: $Enums.StatusEtapa | null
    dataPrevistaInicio: Date | null
    dataPrevistaFim: Date | null
    dataRealInicio: Date | null
    dataRealFim: Date | null
    justificativaId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EtapaObraCountAggregateOutputType = {
    id: number
    obraId: number
    tipo: number
    subEtapa: number
    status: number
    dataPrevistaInicio: number
    dataPrevistaFim: number
    dataRealInicio: number
    dataRealFim: number
    justificativaId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type EtapaObraAvgAggregateInputType = {
    id?: true
    obraId?: true
    justificativaId?: true
  }

  export type EtapaObraSumAggregateInputType = {
    id?: true
    obraId?: true
    justificativaId?: true
  }

  export type EtapaObraMinAggregateInputType = {
    id?: true
    obraId?: true
    tipo?: true
    subEtapa?: true
    status?: true
    dataPrevistaInicio?: true
    dataPrevistaFim?: true
    dataRealInicio?: true
    dataRealFim?: true
    justificativaId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EtapaObraMaxAggregateInputType = {
    id?: true
    obraId?: true
    tipo?: true
    subEtapa?: true
    status?: true
    dataPrevistaInicio?: true
    dataPrevistaFim?: true
    dataRealInicio?: true
    dataRealFim?: true
    justificativaId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EtapaObraCountAggregateInputType = {
    id?: true
    obraId?: true
    tipo?: true
    subEtapa?: true
    status?: true
    dataPrevistaInicio?: true
    dataPrevistaFim?: true
    dataRealInicio?: true
    dataRealFim?: true
    justificativaId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type EtapaObraAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EtapaObra to aggregate.
     */
    where?: EtapaObraWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EtapaObras to fetch.
     */
    orderBy?: EtapaObraOrderByWithRelationInput | EtapaObraOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EtapaObraWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EtapaObras from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EtapaObras.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EtapaObras
    **/
    _count?: true | EtapaObraCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EtapaObraAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EtapaObraSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EtapaObraMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EtapaObraMaxAggregateInputType
  }

  export type GetEtapaObraAggregateType<T extends EtapaObraAggregateArgs> = {
        [P in keyof T & keyof AggregateEtapaObra]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEtapaObra[P]>
      : GetScalarType<T[P], AggregateEtapaObra[P]>
  }




  export type EtapaObraGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EtapaObraWhereInput
    orderBy?: EtapaObraOrderByWithAggregationInput | EtapaObraOrderByWithAggregationInput[]
    by: EtapaObraScalarFieldEnum[] | EtapaObraScalarFieldEnum
    having?: EtapaObraScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EtapaObraCountAggregateInputType | true
    _avg?: EtapaObraAvgAggregateInputType
    _sum?: EtapaObraSumAggregateInputType
    _min?: EtapaObraMinAggregateInputType
    _max?: EtapaObraMaxAggregateInputType
  }

  export type EtapaObraGroupByOutputType = {
    id: number
    obraId: number
    tipo: $Enums.EtapaTipo
    subEtapa: $Enums.SubEtapaTipo | null
    status: $Enums.StatusEtapa
    dataPrevistaInicio: Date | null
    dataPrevistaFim: Date | null
    dataRealInicio: Date | null
    dataRealFim: Date | null
    justificativaId: number | null
    createdAt: Date
    updatedAt: Date
    _count: EtapaObraCountAggregateOutputType | null
    _avg: EtapaObraAvgAggregateOutputType | null
    _sum: EtapaObraSumAggregateOutputType | null
    _min: EtapaObraMinAggregateOutputType | null
    _max: EtapaObraMaxAggregateOutputType | null
  }

  type GetEtapaObraGroupByPayload<T extends EtapaObraGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EtapaObraGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EtapaObraGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EtapaObraGroupByOutputType[P]>
            : GetScalarType<T[P], EtapaObraGroupByOutputType[P]>
        }
      >
    >


  export type EtapaObraSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    obraId?: boolean
    tipo?: boolean
    subEtapa?: boolean
    status?: boolean
    dataPrevistaInicio?: boolean
    dataPrevistaFim?: boolean
    dataRealInicio?: boolean
    dataRealFim?: boolean
    justificativaId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    obra?: boolean | ObraDefaultArgs<ExtArgs>
    justificativa?: boolean | EtapaObra$justificativaArgs<ExtArgs>
  }, ExtArgs["result"]["etapaObra"]>

  export type EtapaObraSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    obraId?: boolean
    tipo?: boolean
    subEtapa?: boolean
    status?: boolean
    dataPrevistaInicio?: boolean
    dataPrevistaFim?: boolean
    dataRealInicio?: boolean
    dataRealFim?: boolean
    justificativaId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    obra?: boolean | ObraDefaultArgs<ExtArgs>
    justificativa?: boolean | EtapaObra$justificativaArgs<ExtArgs>
  }, ExtArgs["result"]["etapaObra"]>

  export type EtapaObraSelectScalar = {
    id?: boolean
    obraId?: boolean
    tipo?: boolean
    subEtapa?: boolean
    status?: boolean
    dataPrevistaInicio?: boolean
    dataPrevistaFim?: boolean
    dataRealInicio?: boolean
    dataRealFim?: boolean
    justificativaId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type EtapaObraInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    obra?: boolean | ObraDefaultArgs<ExtArgs>
    justificativa?: boolean | EtapaObra$justificativaArgs<ExtArgs>
  }
  export type EtapaObraIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    obra?: boolean | ObraDefaultArgs<ExtArgs>
    justificativa?: boolean | EtapaObra$justificativaArgs<ExtArgs>
  }

  export type $EtapaObraPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EtapaObra"
    objects: {
      obra: Prisma.$ObraPayload<ExtArgs>
      justificativa: Prisma.$JustificativaAtrasoPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      obraId: number
      tipo: $Enums.EtapaTipo
      subEtapa: $Enums.SubEtapaTipo | null
      status: $Enums.StatusEtapa
      dataPrevistaInicio: Date | null
      dataPrevistaFim: Date | null
      dataRealInicio: Date | null
      dataRealFim: Date | null
      justificativaId: number | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["etapaObra"]>
    composites: {}
  }

  type EtapaObraGetPayload<S extends boolean | null | undefined | EtapaObraDefaultArgs> = $Result.GetResult<Prisma.$EtapaObraPayload, S>

  type EtapaObraCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EtapaObraFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EtapaObraCountAggregateInputType | true
    }

  export interface EtapaObraDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EtapaObra'], meta: { name: 'EtapaObra' } }
    /**
     * Find zero or one EtapaObra that matches the filter.
     * @param {EtapaObraFindUniqueArgs} args - Arguments to find a EtapaObra
     * @example
     * // Get one EtapaObra
     * const etapaObra = await prisma.etapaObra.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EtapaObraFindUniqueArgs>(args: SelectSubset<T, EtapaObraFindUniqueArgs<ExtArgs>>): Prisma__EtapaObraClient<$Result.GetResult<Prisma.$EtapaObraPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one EtapaObra that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {EtapaObraFindUniqueOrThrowArgs} args - Arguments to find a EtapaObra
     * @example
     * // Get one EtapaObra
     * const etapaObra = await prisma.etapaObra.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EtapaObraFindUniqueOrThrowArgs>(args: SelectSubset<T, EtapaObraFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EtapaObraClient<$Result.GetResult<Prisma.$EtapaObraPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first EtapaObra that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EtapaObraFindFirstArgs} args - Arguments to find a EtapaObra
     * @example
     * // Get one EtapaObra
     * const etapaObra = await prisma.etapaObra.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EtapaObraFindFirstArgs>(args?: SelectSubset<T, EtapaObraFindFirstArgs<ExtArgs>>): Prisma__EtapaObraClient<$Result.GetResult<Prisma.$EtapaObraPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first EtapaObra that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EtapaObraFindFirstOrThrowArgs} args - Arguments to find a EtapaObra
     * @example
     * // Get one EtapaObra
     * const etapaObra = await prisma.etapaObra.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EtapaObraFindFirstOrThrowArgs>(args?: SelectSubset<T, EtapaObraFindFirstOrThrowArgs<ExtArgs>>): Prisma__EtapaObraClient<$Result.GetResult<Prisma.$EtapaObraPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more EtapaObras that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EtapaObraFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EtapaObras
     * const etapaObras = await prisma.etapaObra.findMany()
     * 
     * // Get first 10 EtapaObras
     * const etapaObras = await prisma.etapaObra.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const etapaObraWithIdOnly = await prisma.etapaObra.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EtapaObraFindManyArgs>(args?: SelectSubset<T, EtapaObraFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EtapaObraPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a EtapaObra.
     * @param {EtapaObraCreateArgs} args - Arguments to create a EtapaObra.
     * @example
     * // Create one EtapaObra
     * const EtapaObra = await prisma.etapaObra.create({
     *   data: {
     *     // ... data to create a EtapaObra
     *   }
     * })
     * 
     */
    create<T extends EtapaObraCreateArgs>(args: SelectSubset<T, EtapaObraCreateArgs<ExtArgs>>): Prisma__EtapaObraClient<$Result.GetResult<Prisma.$EtapaObraPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many EtapaObras.
     * @param {EtapaObraCreateManyArgs} args - Arguments to create many EtapaObras.
     * @example
     * // Create many EtapaObras
     * const etapaObra = await prisma.etapaObra.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EtapaObraCreateManyArgs>(args?: SelectSubset<T, EtapaObraCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EtapaObras and returns the data saved in the database.
     * @param {EtapaObraCreateManyAndReturnArgs} args - Arguments to create many EtapaObras.
     * @example
     * // Create many EtapaObras
     * const etapaObra = await prisma.etapaObra.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EtapaObras and only return the `id`
     * const etapaObraWithIdOnly = await prisma.etapaObra.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EtapaObraCreateManyAndReturnArgs>(args?: SelectSubset<T, EtapaObraCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EtapaObraPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a EtapaObra.
     * @param {EtapaObraDeleteArgs} args - Arguments to delete one EtapaObra.
     * @example
     * // Delete one EtapaObra
     * const EtapaObra = await prisma.etapaObra.delete({
     *   where: {
     *     // ... filter to delete one EtapaObra
     *   }
     * })
     * 
     */
    delete<T extends EtapaObraDeleteArgs>(args: SelectSubset<T, EtapaObraDeleteArgs<ExtArgs>>): Prisma__EtapaObraClient<$Result.GetResult<Prisma.$EtapaObraPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one EtapaObra.
     * @param {EtapaObraUpdateArgs} args - Arguments to update one EtapaObra.
     * @example
     * // Update one EtapaObra
     * const etapaObra = await prisma.etapaObra.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EtapaObraUpdateArgs>(args: SelectSubset<T, EtapaObraUpdateArgs<ExtArgs>>): Prisma__EtapaObraClient<$Result.GetResult<Prisma.$EtapaObraPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more EtapaObras.
     * @param {EtapaObraDeleteManyArgs} args - Arguments to filter EtapaObras to delete.
     * @example
     * // Delete a few EtapaObras
     * const { count } = await prisma.etapaObra.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EtapaObraDeleteManyArgs>(args?: SelectSubset<T, EtapaObraDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EtapaObras.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EtapaObraUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EtapaObras
     * const etapaObra = await prisma.etapaObra.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EtapaObraUpdateManyArgs>(args: SelectSubset<T, EtapaObraUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one EtapaObra.
     * @param {EtapaObraUpsertArgs} args - Arguments to update or create a EtapaObra.
     * @example
     * // Update or create a EtapaObra
     * const etapaObra = await prisma.etapaObra.upsert({
     *   create: {
     *     // ... data to create a EtapaObra
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EtapaObra we want to update
     *   }
     * })
     */
    upsert<T extends EtapaObraUpsertArgs>(args: SelectSubset<T, EtapaObraUpsertArgs<ExtArgs>>): Prisma__EtapaObraClient<$Result.GetResult<Prisma.$EtapaObraPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of EtapaObras.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EtapaObraCountArgs} args - Arguments to filter EtapaObras to count.
     * @example
     * // Count the number of EtapaObras
     * const count = await prisma.etapaObra.count({
     *   where: {
     *     // ... the filter for the EtapaObras we want to count
     *   }
     * })
    **/
    count<T extends EtapaObraCountArgs>(
      args?: Subset<T, EtapaObraCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EtapaObraCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EtapaObra.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EtapaObraAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EtapaObraAggregateArgs>(args: Subset<T, EtapaObraAggregateArgs>): Prisma.PrismaPromise<GetEtapaObraAggregateType<T>>

    /**
     * Group by EtapaObra.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EtapaObraGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EtapaObraGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EtapaObraGroupByArgs['orderBy'] }
        : { orderBy?: EtapaObraGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EtapaObraGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEtapaObraGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EtapaObra model
   */
  readonly fields: EtapaObraFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EtapaObra.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EtapaObraClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    obra<T extends ObraDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ObraDefaultArgs<ExtArgs>>): Prisma__ObraClient<$Result.GetResult<Prisma.$ObraPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    justificativa<T extends EtapaObra$justificativaArgs<ExtArgs> = {}>(args?: Subset<T, EtapaObra$justificativaArgs<ExtArgs>>): Prisma__JustificativaAtrasoClient<$Result.GetResult<Prisma.$JustificativaAtrasoPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EtapaObra model
   */ 
  interface EtapaObraFieldRefs {
    readonly id: FieldRef<"EtapaObra", 'Int'>
    readonly obraId: FieldRef<"EtapaObra", 'Int'>
    readonly tipo: FieldRef<"EtapaObra", 'EtapaTipo'>
    readonly subEtapa: FieldRef<"EtapaObra", 'SubEtapaTipo'>
    readonly status: FieldRef<"EtapaObra", 'StatusEtapa'>
    readonly dataPrevistaInicio: FieldRef<"EtapaObra", 'DateTime'>
    readonly dataPrevistaFim: FieldRef<"EtapaObra", 'DateTime'>
    readonly dataRealInicio: FieldRef<"EtapaObra", 'DateTime'>
    readonly dataRealFim: FieldRef<"EtapaObra", 'DateTime'>
    readonly justificativaId: FieldRef<"EtapaObra", 'Int'>
    readonly createdAt: FieldRef<"EtapaObra", 'DateTime'>
    readonly updatedAt: FieldRef<"EtapaObra", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * EtapaObra findUnique
   */
  export type EtapaObraFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EtapaObra
     */
    select?: EtapaObraSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EtapaObraInclude<ExtArgs> | null
    /**
     * Filter, which EtapaObra to fetch.
     */
    where: EtapaObraWhereUniqueInput
  }

  /**
   * EtapaObra findUniqueOrThrow
   */
  export type EtapaObraFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EtapaObra
     */
    select?: EtapaObraSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EtapaObraInclude<ExtArgs> | null
    /**
     * Filter, which EtapaObra to fetch.
     */
    where: EtapaObraWhereUniqueInput
  }

  /**
   * EtapaObra findFirst
   */
  export type EtapaObraFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EtapaObra
     */
    select?: EtapaObraSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EtapaObraInclude<ExtArgs> | null
    /**
     * Filter, which EtapaObra to fetch.
     */
    where?: EtapaObraWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EtapaObras to fetch.
     */
    orderBy?: EtapaObraOrderByWithRelationInput | EtapaObraOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EtapaObras.
     */
    cursor?: EtapaObraWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EtapaObras from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EtapaObras.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EtapaObras.
     */
    distinct?: EtapaObraScalarFieldEnum | EtapaObraScalarFieldEnum[]
  }

  /**
   * EtapaObra findFirstOrThrow
   */
  export type EtapaObraFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EtapaObra
     */
    select?: EtapaObraSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EtapaObraInclude<ExtArgs> | null
    /**
     * Filter, which EtapaObra to fetch.
     */
    where?: EtapaObraWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EtapaObras to fetch.
     */
    orderBy?: EtapaObraOrderByWithRelationInput | EtapaObraOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EtapaObras.
     */
    cursor?: EtapaObraWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EtapaObras from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EtapaObras.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EtapaObras.
     */
    distinct?: EtapaObraScalarFieldEnum | EtapaObraScalarFieldEnum[]
  }

  /**
   * EtapaObra findMany
   */
  export type EtapaObraFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EtapaObra
     */
    select?: EtapaObraSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EtapaObraInclude<ExtArgs> | null
    /**
     * Filter, which EtapaObras to fetch.
     */
    where?: EtapaObraWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EtapaObras to fetch.
     */
    orderBy?: EtapaObraOrderByWithRelationInput | EtapaObraOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EtapaObras.
     */
    cursor?: EtapaObraWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EtapaObras from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EtapaObras.
     */
    skip?: number
    distinct?: EtapaObraScalarFieldEnum | EtapaObraScalarFieldEnum[]
  }

  /**
   * EtapaObra create
   */
  export type EtapaObraCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EtapaObra
     */
    select?: EtapaObraSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EtapaObraInclude<ExtArgs> | null
    /**
     * The data needed to create a EtapaObra.
     */
    data: XOR<EtapaObraCreateInput, EtapaObraUncheckedCreateInput>
  }

  /**
   * EtapaObra createMany
   */
  export type EtapaObraCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EtapaObras.
     */
    data: EtapaObraCreateManyInput | EtapaObraCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EtapaObra createManyAndReturn
   */
  export type EtapaObraCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EtapaObra
     */
    select?: EtapaObraSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many EtapaObras.
     */
    data: EtapaObraCreateManyInput | EtapaObraCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EtapaObraIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * EtapaObra update
   */
  export type EtapaObraUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EtapaObra
     */
    select?: EtapaObraSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EtapaObraInclude<ExtArgs> | null
    /**
     * The data needed to update a EtapaObra.
     */
    data: XOR<EtapaObraUpdateInput, EtapaObraUncheckedUpdateInput>
    /**
     * Choose, which EtapaObra to update.
     */
    where: EtapaObraWhereUniqueInput
  }

  /**
   * EtapaObra updateMany
   */
  export type EtapaObraUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EtapaObras.
     */
    data: XOR<EtapaObraUpdateManyMutationInput, EtapaObraUncheckedUpdateManyInput>
    /**
     * Filter which EtapaObras to update
     */
    where?: EtapaObraWhereInput
  }

  /**
   * EtapaObra upsert
   */
  export type EtapaObraUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EtapaObra
     */
    select?: EtapaObraSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EtapaObraInclude<ExtArgs> | null
    /**
     * The filter to search for the EtapaObra to update in case it exists.
     */
    where: EtapaObraWhereUniqueInput
    /**
     * In case the EtapaObra found by the `where` argument doesn't exist, create a new EtapaObra with this data.
     */
    create: XOR<EtapaObraCreateInput, EtapaObraUncheckedCreateInput>
    /**
     * In case the EtapaObra was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EtapaObraUpdateInput, EtapaObraUncheckedUpdateInput>
  }

  /**
   * EtapaObra delete
   */
  export type EtapaObraDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EtapaObra
     */
    select?: EtapaObraSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EtapaObraInclude<ExtArgs> | null
    /**
     * Filter which EtapaObra to delete.
     */
    where: EtapaObraWhereUniqueInput
  }

  /**
   * EtapaObra deleteMany
   */
  export type EtapaObraDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EtapaObras to delete
     */
    where?: EtapaObraWhereInput
  }

  /**
   * EtapaObra.justificativa
   */
  export type EtapaObra$justificativaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JustificativaAtraso
     */
    select?: JustificativaAtrasoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JustificativaAtrasoInclude<ExtArgs> | null
    where?: JustificativaAtrasoWhereInput
  }

  /**
   * EtapaObra without action
   */
  export type EtapaObraDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EtapaObra
     */
    select?: EtapaObraSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EtapaObraInclude<ExtArgs> | null
  }


  /**
   * Model Material
   */

  export type AggregateMaterial = {
    _count: MaterialCountAggregateOutputType | null
    _avg: MaterialAvgAggregateOutputType | null
    _sum: MaterialSumAggregateOutputType | null
    _min: MaterialMinAggregateOutputType | null
    _max: MaterialMaxAggregateOutputType | null
  }

  export type MaterialAvgAggregateOutputType = {
    id: number | null
  }

  export type MaterialSumAggregateOutputType = {
    id: number | null
  }

  export type MaterialMinAggregateOutputType = {
    id: number | null
    nome: string | null
    etapaDefault: $Enums.EtapaTipo | null
    unidade: string | null
  }

  export type MaterialMaxAggregateOutputType = {
    id: number | null
    nome: string | null
    etapaDefault: $Enums.EtapaTipo | null
    unidade: string | null
  }

  export type MaterialCountAggregateOutputType = {
    id: number
    nome: number
    etapaDefault: number
    unidade: number
    _all: number
  }


  export type MaterialAvgAggregateInputType = {
    id?: true
  }

  export type MaterialSumAggregateInputType = {
    id?: true
  }

  export type MaterialMinAggregateInputType = {
    id?: true
    nome?: true
    etapaDefault?: true
    unidade?: true
  }

  export type MaterialMaxAggregateInputType = {
    id?: true
    nome?: true
    etapaDefault?: true
    unidade?: true
  }

  export type MaterialCountAggregateInputType = {
    id?: true
    nome?: true
    etapaDefault?: true
    unidade?: true
    _all?: true
  }

  export type MaterialAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Material to aggregate.
     */
    where?: MaterialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Materials to fetch.
     */
    orderBy?: MaterialOrderByWithRelationInput | MaterialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MaterialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Materials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Materials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Materials
    **/
    _count?: true | MaterialCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MaterialAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MaterialSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MaterialMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MaterialMaxAggregateInputType
  }

  export type GetMaterialAggregateType<T extends MaterialAggregateArgs> = {
        [P in keyof T & keyof AggregateMaterial]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMaterial[P]>
      : GetScalarType<T[P], AggregateMaterial[P]>
  }




  export type MaterialGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MaterialWhereInput
    orderBy?: MaterialOrderByWithAggregationInput | MaterialOrderByWithAggregationInput[]
    by: MaterialScalarFieldEnum[] | MaterialScalarFieldEnum
    having?: MaterialScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MaterialCountAggregateInputType | true
    _avg?: MaterialAvgAggregateInputType
    _sum?: MaterialSumAggregateInputType
    _min?: MaterialMinAggregateInputType
    _max?: MaterialMaxAggregateInputType
  }

  export type MaterialGroupByOutputType = {
    id: number
    nome: string
    etapaDefault: $Enums.EtapaTipo | null
    unidade: string
    _count: MaterialCountAggregateOutputType | null
    _avg: MaterialAvgAggregateOutputType | null
    _sum: MaterialSumAggregateOutputType | null
    _min: MaterialMinAggregateOutputType | null
    _max: MaterialMaxAggregateOutputType | null
  }

  type GetMaterialGroupByPayload<T extends MaterialGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MaterialGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MaterialGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MaterialGroupByOutputType[P]>
            : GetScalarType<T[P], MaterialGroupByOutputType[P]>
        }
      >
    >


  export type MaterialSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nome?: boolean
    etapaDefault?: boolean
    unidade?: boolean
    itens?: boolean | Material$itensArgs<ExtArgs>
    lembretes?: boolean | Material$lembretesArgs<ExtArgs>
    _count?: boolean | MaterialCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["material"]>

  export type MaterialSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nome?: boolean
    etapaDefault?: boolean
    unidade?: boolean
  }, ExtArgs["result"]["material"]>

  export type MaterialSelectScalar = {
    id?: boolean
    nome?: boolean
    etapaDefault?: boolean
    unidade?: boolean
  }

  export type MaterialInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    itens?: boolean | Material$itensArgs<ExtArgs>
    lembretes?: boolean | Material$lembretesArgs<ExtArgs>
    _count?: boolean | MaterialCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type MaterialIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $MaterialPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Material"
    objects: {
      itens: Prisma.$MaterialObraPayload<ExtArgs>[]
      lembretes: Prisma.$LembreteMaterialPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      nome: string
      etapaDefault: $Enums.EtapaTipo | null
      unidade: string
    }, ExtArgs["result"]["material"]>
    composites: {}
  }

  type MaterialGetPayload<S extends boolean | null | undefined | MaterialDefaultArgs> = $Result.GetResult<Prisma.$MaterialPayload, S>

  type MaterialCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MaterialFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MaterialCountAggregateInputType | true
    }

  export interface MaterialDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Material'], meta: { name: 'Material' } }
    /**
     * Find zero or one Material that matches the filter.
     * @param {MaterialFindUniqueArgs} args - Arguments to find a Material
     * @example
     * // Get one Material
     * const material = await prisma.material.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MaterialFindUniqueArgs>(args: SelectSubset<T, MaterialFindUniqueArgs<ExtArgs>>): Prisma__MaterialClient<$Result.GetResult<Prisma.$MaterialPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Material that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {MaterialFindUniqueOrThrowArgs} args - Arguments to find a Material
     * @example
     * // Get one Material
     * const material = await prisma.material.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MaterialFindUniqueOrThrowArgs>(args: SelectSubset<T, MaterialFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MaterialClient<$Result.GetResult<Prisma.$MaterialPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Material that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterialFindFirstArgs} args - Arguments to find a Material
     * @example
     * // Get one Material
     * const material = await prisma.material.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MaterialFindFirstArgs>(args?: SelectSubset<T, MaterialFindFirstArgs<ExtArgs>>): Prisma__MaterialClient<$Result.GetResult<Prisma.$MaterialPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Material that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterialFindFirstOrThrowArgs} args - Arguments to find a Material
     * @example
     * // Get one Material
     * const material = await prisma.material.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MaterialFindFirstOrThrowArgs>(args?: SelectSubset<T, MaterialFindFirstOrThrowArgs<ExtArgs>>): Prisma__MaterialClient<$Result.GetResult<Prisma.$MaterialPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Materials that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterialFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Materials
     * const materials = await prisma.material.findMany()
     * 
     * // Get first 10 Materials
     * const materials = await prisma.material.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const materialWithIdOnly = await prisma.material.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MaterialFindManyArgs>(args?: SelectSubset<T, MaterialFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MaterialPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Material.
     * @param {MaterialCreateArgs} args - Arguments to create a Material.
     * @example
     * // Create one Material
     * const Material = await prisma.material.create({
     *   data: {
     *     // ... data to create a Material
     *   }
     * })
     * 
     */
    create<T extends MaterialCreateArgs>(args: SelectSubset<T, MaterialCreateArgs<ExtArgs>>): Prisma__MaterialClient<$Result.GetResult<Prisma.$MaterialPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Materials.
     * @param {MaterialCreateManyArgs} args - Arguments to create many Materials.
     * @example
     * // Create many Materials
     * const material = await prisma.material.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MaterialCreateManyArgs>(args?: SelectSubset<T, MaterialCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Materials and returns the data saved in the database.
     * @param {MaterialCreateManyAndReturnArgs} args - Arguments to create many Materials.
     * @example
     * // Create many Materials
     * const material = await prisma.material.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Materials and only return the `id`
     * const materialWithIdOnly = await prisma.material.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MaterialCreateManyAndReturnArgs>(args?: SelectSubset<T, MaterialCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MaterialPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Material.
     * @param {MaterialDeleteArgs} args - Arguments to delete one Material.
     * @example
     * // Delete one Material
     * const Material = await prisma.material.delete({
     *   where: {
     *     // ... filter to delete one Material
     *   }
     * })
     * 
     */
    delete<T extends MaterialDeleteArgs>(args: SelectSubset<T, MaterialDeleteArgs<ExtArgs>>): Prisma__MaterialClient<$Result.GetResult<Prisma.$MaterialPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Material.
     * @param {MaterialUpdateArgs} args - Arguments to update one Material.
     * @example
     * // Update one Material
     * const material = await prisma.material.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MaterialUpdateArgs>(args: SelectSubset<T, MaterialUpdateArgs<ExtArgs>>): Prisma__MaterialClient<$Result.GetResult<Prisma.$MaterialPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Materials.
     * @param {MaterialDeleteManyArgs} args - Arguments to filter Materials to delete.
     * @example
     * // Delete a few Materials
     * const { count } = await prisma.material.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MaterialDeleteManyArgs>(args?: SelectSubset<T, MaterialDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Materials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterialUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Materials
     * const material = await prisma.material.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MaterialUpdateManyArgs>(args: SelectSubset<T, MaterialUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Material.
     * @param {MaterialUpsertArgs} args - Arguments to update or create a Material.
     * @example
     * // Update or create a Material
     * const material = await prisma.material.upsert({
     *   create: {
     *     // ... data to create a Material
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Material we want to update
     *   }
     * })
     */
    upsert<T extends MaterialUpsertArgs>(args: SelectSubset<T, MaterialUpsertArgs<ExtArgs>>): Prisma__MaterialClient<$Result.GetResult<Prisma.$MaterialPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Materials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterialCountArgs} args - Arguments to filter Materials to count.
     * @example
     * // Count the number of Materials
     * const count = await prisma.material.count({
     *   where: {
     *     // ... the filter for the Materials we want to count
     *   }
     * })
    **/
    count<T extends MaterialCountArgs>(
      args?: Subset<T, MaterialCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MaterialCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Material.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterialAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MaterialAggregateArgs>(args: Subset<T, MaterialAggregateArgs>): Prisma.PrismaPromise<GetMaterialAggregateType<T>>

    /**
     * Group by Material.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterialGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MaterialGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MaterialGroupByArgs['orderBy'] }
        : { orderBy?: MaterialGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MaterialGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMaterialGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Material model
   */
  readonly fields: MaterialFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Material.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MaterialClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    itens<T extends Material$itensArgs<ExtArgs> = {}>(args?: Subset<T, Material$itensArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MaterialObraPayload<ExtArgs>, T, "findMany"> | Null>
    lembretes<T extends Material$lembretesArgs<ExtArgs> = {}>(args?: Subset<T, Material$lembretesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LembreteMaterialPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Material model
   */ 
  interface MaterialFieldRefs {
    readonly id: FieldRef<"Material", 'Int'>
    readonly nome: FieldRef<"Material", 'String'>
    readonly etapaDefault: FieldRef<"Material", 'EtapaTipo'>
    readonly unidade: FieldRef<"Material", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Material findUnique
   */
  export type MaterialFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Material
     */
    select?: MaterialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialInclude<ExtArgs> | null
    /**
     * Filter, which Material to fetch.
     */
    where: MaterialWhereUniqueInput
  }

  /**
   * Material findUniqueOrThrow
   */
  export type MaterialFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Material
     */
    select?: MaterialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialInclude<ExtArgs> | null
    /**
     * Filter, which Material to fetch.
     */
    where: MaterialWhereUniqueInput
  }

  /**
   * Material findFirst
   */
  export type MaterialFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Material
     */
    select?: MaterialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialInclude<ExtArgs> | null
    /**
     * Filter, which Material to fetch.
     */
    where?: MaterialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Materials to fetch.
     */
    orderBy?: MaterialOrderByWithRelationInput | MaterialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Materials.
     */
    cursor?: MaterialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Materials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Materials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Materials.
     */
    distinct?: MaterialScalarFieldEnum | MaterialScalarFieldEnum[]
  }

  /**
   * Material findFirstOrThrow
   */
  export type MaterialFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Material
     */
    select?: MaterialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialInclude<ExtArgs> | null
    /**
     * Filter, which Material to fetch.
     */
    where?: MaterialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Materials to fetch.
     */
    orderBy?: MaterialOrderByWithRelationInput | MaterialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Materials.
     */
    cursor?: MaterialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Materials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Materials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Materials.
     */
    distinct?: MaterialScalarFieldEnum | MaterialScalarFieldEnum[]
  }

  /**
   * Material findMany
   */
  export type MaterialFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Material
     */
    select?: MaterialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialInclude<ExtArgs> | null
    /**
     * Filter, which Materials to fetch.
     */
    where?: MaterialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Materials to fetch.
     */
    orderBy?: MaterialOrderByWithRelationInput | MaterialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Materials.
     */
    cursor?: MaterialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Materials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Materials.
     */
    skip?: number
    distinct?: MaterialScalarFieldEnum | MaterialScalarFieldEnum[]
  }

  /**
   * Material create
   */
  export type MaterialCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Material
     */
    select?: MaterialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialInclude<ExtArgs> | null
    /**
     * The data needed to create a Material.
     */
    data: XOR<MaterialCreateInput, MaterialUncheckedCreateInput>
  }

  /**
   * Material createMany
   */
  export type MaterialCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Materials.
     */
    data: MaterialCreateManyInput | MaterialCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Material createManyAndReturn
   */
  export type MaterialCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Material
     */
    select?: MaterialSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Materials.
     */
    data: MaterialCreateManyInput | MaterialCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Material update
   */
  export type MaterialUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Material
     */
    select?: MaterialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialInclude<ExtArgs> | null
    /**
     * The data needed to update a Material.
     */
    data: XOR<MaterialUpdateInput, MaterialUncheckedUpdateInput>
    /**
     * Choose, which Material to update.
     */
    where: MaterialWhereUniqueInput
  }

  /**
   * Material updateMany
   */
  export type MaterialUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Materials.
     */
    data: XOR<MaterialUpdateManyMutationInput, MaterialUncheckedUpdateManyInput>
    /**
     * Filter which Materials to update
     */
    where?: MaterialWhereInput
  }

  /**
   * Material upsert
   */
  export type MaterialUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Material
     */
    select?: MaterialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialInclude<ExtArgs> | null
    /**
     * The filter to search for the Material to update in case it exists.
     */
    where: MaterialWhereUniqueInput
    /**
     * In case the Material found by the `where` argument doesn't exist, create a new Material with this data.
     */
    create: XOR<MaterialCreateInput, MaterialUncheckedCreateInput>
    /**
     * In case the Material was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MaterialUpdateInput, MaterialUncheckedUpdateInput>
  }

  /**
   * Material delete
   */
  export type MaterialDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Material
     */
    select?: MaterialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialInclude<ExtArgs> | null
    /**
     * Filter which Material to delete.
     */
    where: MaterialWhereUniqueInput
  }

  /**
   * Material deleteMany
   */
  export type MaterialDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Materials to delete
     */
    where?: MaterialWhereInput
  }

  /**
   * Material.itens
   */
  export type Material$itensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaterialObra
     */
    select?: MaterialObraSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialObraInclude<ExtArgs> | null
    where?: MaterialObraWhereInput
    orderBy?: MaterialObraOrderByWithRelationInput | MaterialObraOrderByWithRelationInput[]
    cursor?: MaterialObraWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MaterialObraScalarFieldEnum | MaterialObraScalarFieldEnum[]
  }

  /**
   * Material.lembretes
   */
  export type Material$lembretesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LembreteMaterial
     */
    select?: LembreteMaterialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LembreteMaterialInclude<ExtArgs> | null
    where?: LembreteMaterialWhereInput
    orderBy?: LembreteMaterialOrderByWithRelationInput | LembreteMaterialOrderByWithRelationInput[]
    cursor?: LembreteMaterialWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LembreteMaterialScalarFieldEnum | LembreteMaterialScalarFieldEnum[]
  }

  /**
   * Material without action
   */
  export type MaterialDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Material
     */
    select?: MaterialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialInclude<ExtArgs> | null
  }


  /**
   * Model MaterialObra
   */

  export type AggregateMaterialObra = {
    _count: MaterialObraCountAggregateOutputType | null
    _avg: MaterialObraAvgAggregateOutputType | null
    _sum: MaterialObraSumAggregateOutputType | null
    _min: MaterialObraMinAggregateOutputType | null
    _max: MaterialObraMaxAggregateOutputType | null
  }

  export type MaterialObraAvgAggregateOutputType = {
    id: number | null
    obraId: number | null
    materialId: number | null
    quantidade: number | null
  }

  export type MaterialObraSumAggregateOutputType = {
    id: number | null
    obraId: number | null
    materialId: number | null
    quantidade: number | null
  }

  export type MaterialObraMinAggregateOutputType = {
    id: number | null
    obraId: number | null
    materialId: number | null
    etapa: $Enums.EtapaTipo | null
    quantidade: number | null
    statusPedido: $Enums.StatusPedido | null
    dataPedido: Date | null
    dataEntrega: Date | null
  }

  export type MaterialObraMaxAggregateOutputType = {
    id: number | null
    obraId: number | null
    materialId: number | null
    etapa: $Enums.EtapaTipo | null
    quantidade: number | null
    statusPedido: $Enums.StatusPedido | null
    dataPedido: Date | null
    dataEntrega: Date | null
  }

  export type MaterialObraCountAggregateOutputType = {
    id: number
    obraId: number
    materialId: number
    etapa: number
    quantidade: number
    statusPedido: number
    dataPedido: number
    dataEntrega: number
    _all: number
  }


  export type MaterialObraAvgAggregateInputType = {
    id?: true
    obraId?: true
    materialId?: true
    quantidade?: true
  }

  export type MaterialObraSumAggregateInputType = {
    id?: true
    obraId?: true
    materialId?: true
    quantidade?: true
  }

  export type MaterialObraMinAggregateInputType = {
    id?: true
    obraId?: true
    materialId?: true
    etapa?: true
    quantidade?: true
    statusPedido?: true
    dataPedido?: true
    dataEntrega?: true
  }

  export type MaterialObraMaxAggregateInputType = {
    id?: true
    obraId?: true
    materialId?: true
    etapa?: true
    quantidade?: true
    statusPedido?: true
    dataPedido?: true
    dataEntrega?: true
  }

  export type MaterialObraCountAggregateInputType = {
    id?: true
    obraId?: true
    materialId?: true
    etapa?: true
    quantidade?: true
    statusPedido?: true
    dataPedido?: true
    dataEntrega?: true
    _all?: true
  }

  export type MaterialObraAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MaterialObra to aggregate.
     */
    where?: MaterialObraWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MaterialObras to fetch.
     */
    orderBy?: MaterialObraOrderByWithRelationInput | MaterialObraOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MaterialObraWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MaterialObras from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MaterialObras.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MaterialObras
    **/
    _count?: true | MaterialObraCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MaterialObraAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MaterialObraSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MaterialObraMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MaterialObraMaxAggregateInputType
  }

  export type GetMaterialObraAggregateType<T extends MaterialObraAggregateArgs> = {
        [P in keyof T & keyof AggregateMaterialObra]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMaterialObra[P]>
      : GetScalarType<T[P], AggregateMaterialObra[P]>
  }




  export type MaterialObraGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MaterialObraWhereInput
    orderBy?: MaterialObraOrderByWithAggregationInput | MaterialObraOrderByWithAggregationInput[]
    by: MaterialObraScalarFieldEnum[] | MaterialObraScalarFieldEnum
    having?: MaterialObraScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MaterialObraCountAggregateInputType | true
    _avg?: MaterialObraAvgAggregateInputType
    _sum?: MaterialObraSumAggregateInputType
    _min?: MaterialObraMinAggregateInputType
    _max?: MaterialObraMaxAggregateInputType
  }

  export type MaterialObraGroupByOutputType = {
    id: number
    obraId: number
    materialId: number
    etapa: $Enums.EtapaTipo
    quantidade: number
    statusPedido: $Enums.StatusPedido
    dataPedido: Date | null
    dataEntrega: Date | null
    _count: MaterialObraCountAggregateOutputType | null
    _avg: MaterialObraAvgAggregateOutputType | null
    _sum: MaterialObraSumAggregateOutputType | null
    _min: MaterialObraMinAggregateOutputType | null
    _max: MaterialObraMaxAggregateOutputType | null
  }

  type GetMaterialObraGroupByPayload<T extends MaterialObraGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MaterialObraGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MaterialObraGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MaterialObraGroupByOutputType[P]>
            : GetScalarType<T[P], MaterialObraGroupByOutputType[P]>
        }
      >
    >


  export type MaterialObraSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    obraId?: boolean
    materialId?: boolean
    etapa?: boolean
    quantidade?: boolean
    statusPedido?: boolean
    dataPedido?: boolean
    dataEntrega?: boolean
    obra?: boolean | ObraDefaultArgs<ExtArgs>
    material?: boolean | MaterialDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["materialObra"]>

  export type MaterialObraSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    obraId?: boolean
    materialId?: boolean
    etapa?: boolean
    quantidade?: boolean
    statusPedido?: boolean
    dataPedido?: boolean
    dataEntrega?: boolean
    obra?: boolean | ObraDefaultArgs<ExtArgs>
    material?: boolean | MaterialDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["materialObra"]>

  export type MaterialObraSelectScalar = {
    id?: boolean
    obraId?: boolean
    materialId?: boolean
    etapa?: boolean
    quantidade?: boolean
    statusPedido?: boolean
    dataPedido?: boolean
    dataEntrega?: boolean
  }

  export type MaterialObraInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    obra?: boolean | ObraDefaultArgs<ExtArgs>
    material?: boolean | MaterialDefaultArgs<ExtArgs>
  }
  export type MaterialObraIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    obra?: boolean | ObraDefaultArgs<ExtArgs>
    material?: boolean | MaterialDefaultArgs<ExtArgs>
  }

  export type $MaterialObraPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MaterialObra"
    objects: {
      obra: Prisma.$ObraPayload<ExtArgs>
      material: Prisma.$MaterialPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      obraId: number
      materialId: number
      etapa: $Enums.EtapaTipo
      quantidade: number
      statusPedido: $Enums.StatusPedido
      dataPedido: Date | null
      dataEntrega: Date | null
    }, ExtArgs["result"]["materialObra"]>
    composites: {}
  }

  type MaterialObraGetPayload<S extends boolean | null | undefined | MaterialObraDefaultArgs> = $Result.GetResult<Prisma.$MaterialObraPayload, S>

  type MaterialObraCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MaterialObraFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MaterialObraCountAggregateInputType | true
    }

  export interface MaterialObraDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MaterialObra'], meta: { name: 'MaterialObra' } }
    /**
     * Find zero or one MaterialObra that matches the filter.
     * @param {MaterialObraFindUniqueArgs} args - Arguments to find a MaterialObra
     * @example
     * // Get one MaterialObra
     * const materialObra = await prisma.materialObra.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MaterialObraFindUniqueArgs>(args: SelectSubset<T, MaterialObraFindUniqueArgs<ExtArgs>>): Prisma__MaterialObraClient<$Result.GetResult<Prisma.$MaterialObraPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one MaterialObra that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {MaterialObraFindUniqueOrThrowArgs} args - Arguments to find a MaterialObra
     * @example
     * // Get one MaterialObra
     * const materialObra = await prisma.materialObra.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MaterialObraFindUniqueOrThrowArgs>(args: SelectSubset<T, MaterialObraFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MaterialObraClient<$Result.GetResult<Prisma.$MaterialObraPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first MaterialObra that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterialObraFindFirstArgs} args - Arguments to find a MaterialObra
     * @example
     * // Get one MaterialObra
     * const materialObra = await prisma.materialObra.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MaterialObraFindFirstArgs>(args?: SelectSubset<T, MaterialObraFindFirstArgs<ExtArgs>>): Prisma__MaterialObraClient<$Result.GetResult<Prisma.$MaterialObraPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first MaterialObra that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterialObraFindFirstOrThrowArgs} args - Arguments to find a MaterialObra
     * @example
     * // Get one MaterialObra
     * const materialObra = await prisma.materialObra.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MaterialObraFindFirstOrThrowArgs>(args?: SelectSubset<T, MaterialObraFindFirstOrThrowArgs<ExtArgs>>): Prisma__MaterialObraClient<$Result.GetResult<Prisma.$MaterialObraPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more MaterialObras that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterialObraFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MaterialObras
     * const materialObras = await prisma.materialObra.findMany()
     * 
     * // Get first 10 MaterialObras
     * const materialObras = await prisma.materialObra.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const materialObraWithIdOnly = await prisma.materialObra.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MaterialObraFindManyArgs>(args?: SelectSubset<T, MaterialObraFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MaterialObraPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a MaterialObra.
     * @param {MaterialObraCreateArgs} args - Arguments to create a MaterialObra.
     * @example
     * // Create one MaterialObra
     * const MaterialObra = await prisma.materialObra.create({
     *   data: {
     *     // ... data to create a MaterialObra
     *   }
     * })
     * 
     */
    create<T extends MaterialObraCreateArgs>(args: SelectSubset<T, MaterialObraCreateArgs<ExtArgs>>): Prisma__MaterialObraClient<$Result.GetResult<Prisma.$MaterialObraPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many MaterialObras.
     * @param {MaterialObraCreateManyArgs} args - Arguments to create many MaterialObras.
     * @example
     * // Create many MaterialObras
     * const materialObra = await prisma.materialObra.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MaterialObraCreateManyArgs>(args?: SelectSubset<T, MaterialObraCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MaterialObras and returns the data saved in the database.
     * @param {MaterialObraCreateManyAndReturnArgs} args - Arguments to create many MaterialObras.
     * @example
     * // Create many MaterialObras
     * const materialObra = await prisma.materialObra.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MaterialObras and only return the `id`
     * const materialObraWithIdOnly = await prisma.materialObra.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MaterialObraCreateManyAndReturnArgs>(args?: SelectSubset<T, MaterialObraCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MaterialObraPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a MaterialObra.
     * @param {MaterialObraDeleteArgs} args - Arguments to delete one MaterialObra.
     * @example
     * // Delete one MaterialObra
     * const MaterialObra = await prisma.materialObra.delete({
     *   where: {
     *     // ... filter to delete one MaterialObra
     *   }
     * })
     * 
     */
    delete<T extends MaterialObraDeleteArgs>(args: SelectSubset<T, MaterialObraDeleteArgs<ExtArgs>>): Prisma__MaterialObraClient<$Result.GetResult<Prisma.$MaterialObraPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one MaterialObra.
     * @param {MaterialObraUpdateArgs} args - Arguments to update one MaterialObra.
     * @example
     * // Update one MaterialObra
     * const materialObra = await prisma.materialObra.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MaterialObraUpdateArgs>(args: SelectSubset<T, MaterialObraUpdateArgs<ExtArgs>>): Prisma__MaterialObraClient<$Result.GetResult<Prisma.$MaterialObraPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more MaterialObras.
     * @param {MaterialObraDeleteManyArgs} args - Arguments to filter MaterialObras to delete.
     * @example
     * // Delete a few MaterialObras
     * const { count } = await prisma.materialObra.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MaterialObraDeleteManyArgs>(args?: SelectSubset<T, MaterialObraDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MaterialObras.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterialObraUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MaterialObras
     * const materialObra = await prisma.materialObra.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MaterialObraUpdateManyArgs>(args: SelectSubset<T, MaterialObraUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MaterialObra.
     * @param {MaterialObraUpsertArgs} args - Arguments to update or create a MaterialObra.
     * @example
     * // Update or create a MaterialObra
     * const materialObra = await prisma.materialObra.upsert({
     *   create: {
     *     // ... data to create a MaterialObra
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MaterialObra we want to update
     *   }
     * })
     */
    upsert<T extends MaterialObraUpsertArgs>(args: SelectSubset<T, MaterialObraUpsertArgs<ExtArgs>>): Prisma__MaterialObraClient<$Result.GetResult<Prisma.$MaterialObraPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of MaterialObras.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterialObraCountArgs} args - Arguments to filter MaterialObras to count.
     * @example
     * // Count the number of MaterialObras
     * const count = await prisma.materialObra.count({
     *   where: {
     *     // ... the filter for the MaterialObras we want to count
     *   }
     * })
    **/
    count<T extends MaterialObraCountArgs>(
      args?: Subset<T, MaterialObraCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MaterialObraCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MaterialObra.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterialObraAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MaterialObraAggregateArgs>(args: Subset<T, MaterialObraAggregateArgs>): Prisma.PrismaPromise<GetMaterialObraAggregateType<T>>

    /**
     * Group by MaterialObra.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterialObraGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MaterialObraGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MaterialObraGroupByArgs['orderBy'] }
        : { orderBy?: MaterialObraGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MaterialObraGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMaterialObraGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MaterialObra model
   */
  readonly fields: MaterialObraFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MaterialObra.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MaterialObraClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    obra<T extends ObraDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ObraDefaultArgs<ExtArgs>>): Prisma__ObraClient<$Result.GetResult<Prisma.$ObraPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    material<T extends MaterialDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MaterialDefaultArgs<ExtArgs>>): Prisma__MaterialClient<$Result.GetResult<Prisma.$MaterialPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MaterialObra model
   */ 
  interface MaterialObraFieldRefs {
    readonly id: FieldRef<"MaterialObra", 'Int'>
    readonly obraId: FieldRef<"MaterialObra", 'Int'>
    readonly materialId: FieldRef<"MaterialObra", 'Int'>
    readonly etapa: FieldRef<"MaterialObra", 'EtapaTipo'>
    readonly quantidade: FieldRef<"MaterialObra", 'Float'>
    readonly statusPedido: FieldRef<"MaterialObra", 'StatusPedido'>
    readonly dataPedido: FieldRef<"MaterialObra", 'DateTime'>
    readonly dataEntrega: FieldRef<"MaterialObra", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MaterialObra findUnique
   */
  export type MaterialObraFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaterialObra
     */
    select?: MaterialObraSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialObraInclude<ExtArgs> | null
    /**
     * Filter, which MaterialObra to fetch.
     */
    where: MaterialObraWhereUniqueInput
  }

  /**
   * MaterialObra findUniqueOrThrow
   */
  export type MaterialObraFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaterialObra
     */
    select?: MaterialObraSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialObraInclude<ExtArgs> | null
    /**
     * Filter, which MaterialObra to fetch.
     */
    where: MaterialObraWhereUniqueInput
  }

  /**
   * MaterialObra findFirst
   */
  export type MaterialObraFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaterialObra
     */
    select?: MaterialObraSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialObraInclude<ExtArgs> | null
    /**
     * Filter, which MaterialObra to fetch.
     */
    where?: MaterialObraWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MaterialObras to fetch.
     */
    orderBy?: MaterialObraOrderByWithRelationInput | MaterialObraOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MaterialObras.
     */
    cursor?: MaterialObraWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MaterialObras from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MaterialObras.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MaterialObras.
     */
    distinct?: MaterialObraScalarFieldEnum | MaterialObraScalarFieldEnum[]
  }

  /**
   * MaterialObra findFirstOrThrow
   */
  export type MaterialObraFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaterialObra
     */
    select?: MaterialObraSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialObraInclude<ExtArgs> | null
    /**
     * Filter, which MaterialObra to fetch.
     */
    where?: MaterialObraWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MaterialObras to fetch.
     */
    orderBy?: MaterialObraOrderByWithRelationInput | MaterialObraOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MaterialObras.
     */
    cursor?: MaterialObraWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MaterialObras from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MaterialObras.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MaterialObras.
     */
    distinct?: MaterialObraScalarFieldEnum | MaterialObraScalarFieldEnum[]
  }

  /**
   * MaterialObra findMany
   */
  export type MaterialObraFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaterialObra
     */
    select?: MaterialObraSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialObraInclude<ExtArgs> | null
    /**
     * Filter, which MaterialObras to fetch.
     */
    where?: MaterialObraWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MaterialObras to fetch.
     */
    orderBy?: MaterialObraOrderByWithRelationInput | MaterialObraOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MaterialObras.
     */
    cursor?: MaterialObraWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MaterialObras from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MaterialObras.
     */
    skip?: number
    distinct?: MaterialObraScalarFieldEnum | MaterialObraScalarFieldEnum[]
  }

  /**
   * MaterialObra create
   */
  export type MaterialObraCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaterialObra
     */
    select?: MaterialObraSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialObraInclude<ExtArgs> | null
    /**
     * The data needed to create a MaterialObra.
     */
    data: XOR<MaterialObraCreateInput, MaterialObraUncheckedCreateInput>
  }

  /**
   * MaterialObra createMany
   */
  export type MaterialObraCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MaterialObras.
     */
    data: MaterialObraCreateManyInput | MaterialObraCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MaterialObra createManyAndReturn
   */
  export type MaterialObraCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaterialObra
     */
    select?: MaterialObraSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many MaterialObras.
     */
    data: MaterialObraCreateManyInput | MaterialObraCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialObraIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MaterialObra update
   */
  export type MaterialObraUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaterialObra
     */
    select?: MaterialObraSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialObraInclude<ExtArgs> | null
    /**
     * The data needed to update a MaterialObra.
     */
    data: XOR<MaterialObraUpdateInput, MaterialObraUncheckedUpdateInput>
    /**
     * Choose, which MaterialObra to update.
     */
    where: MaterialObraWhereUniqueInput
  }

  /**
   * MaterialObra updateMany
   */
  export type MaterialObraUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MaterialObras.
     */
    data: XOR<MaterialObraUpdateManyMutationInput, MaterialObraUncheckedUpdateManyInput>
    /**
     * Filter which MaterialObras to update
     */
    where?: MaterialObraWhereInput
  }

  /**
   * MaterialObra upsert
   */
  export type MaterialObraUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaterialObra
     */
    select?: MaterialObraSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialObraInclude<ExtArgs> | null
    /**
     * The filter to search for the MaterialObra to update in case it exists.
     */
    where: MaterialObraWhereUniqueInput
    /**
     * In case the MaterialObra found by the `where` argument doesn't exist, create a new MaterialObra with this data.
     */
    create: XOR<MaterialObraCreateInput, MaterialObraUncheckedCreateInput>
    /**
     * In case the MaterialObra was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MaterialObraUpdateInput, MaterialObraUncheckedUpdateInput>
  }

  /**
   * MaterialObra delete
   */
  export type MaterialObraDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaterialObra
     */
    select?: MaterialObraSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialObraInclude<ExtArgs> | null
    /**
     * Filter which MaterialObra to delete.
     */
    where: MaterialObraWhereUniqueInput
  }

  /**
   * MaterialObra deleteMany
   */
  export type MaterialObraDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MaterialObras to delete
     */
    where?: MaterialObraWhereInput
  }

  /**
   * MaterialObra without action
   */
  export type MaterialObraDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaterialObra
     */
    select?: MaterialObraSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialObraInclude<ExtArgs> | null
  }


  /**
   * Model LembreteMaterial
   */

  export type AggregateLembreteMaterial = {
    _count: LembreteMaterialCountAggregateOutputType | null
    _avg: LembreteMaterialAvgAggregateOutputType | null
    _sum: LembreteMaterialSumAggregateOutputType | null
    _min: LembreteMaterialMinAggregateOutputType | null
    _max: LembreteMaterialMaxAggregateOutputType | null
  }

  export type LembreteMaterialAvgAggregateOutputType = {
    id: number | null
    obraId: number | null
    materialId: number | null
  }

  export type LembreteMaterialSumAggregateOutputType = {
    id: number | null
    obraId: number | null
    materialId: number | null
  }

  export type LembreteMaterialMinAggregateOutputType = {
    id: number | null
    obraId: number | null
    materialId: number | null
    etapa: $Enums.EtapaTipo | null
    dataLembrete: Date | null
    enviado: boolean | null
    createdAt: Date | null
  }

  export type LembreteMaterialMaxAggregateOutputType = {
    id: number | null
    obraId: number | null
    materialId: number | null
    etapa: $Enums.EtapaTipo | null
    dataLembrete: Date | null
    enviado: boolean | null
    createdAt: Date | null
  }

  export type LembreteMaterialCountAggregateOutputType = {
    id: number
    obraId: number
    materialId: number
    etapa: number
    dataLembrete: number
    enviado: number
    createdAt: number
    _all: number
  }


  export type LembreteMaterialAvgAggregateInputType = {
    id?: true
    obraId?: true
    materialId?: true
  }

  export type LembreteMaterialSumAggregateInputType = {
    id?: true
    obraId?: true
    materialId?: true
  }

  export type LembreteMaterialMinAggregateInputType = {
    id?: true
    obraId?: true
    materialId?: true
    etapa?: true
    dataLembrete?: true
    enviado?: true
    createdAt?: true
  }

  export type LembreteMaterialMaxAggregateInputType = {
    id?: true
    obraId?: true
    materialId?: true
    etapa?: true
    dataLembrete?: true
    enviado?: true
    createdAt?: true
  }

  export type LembreteMaterialCountAggregateInputType = {
    id?: true
    obraId?: true
    materialId?: true
    etapa?: true
    dataLembrete?: true
    enviado?: true
    createdAt?: true
    _all?: true
  }

  export type LembreteMaterialAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LembreteMaterial to aggregate.
     */
    where?: LembreteMaterialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LembreteMaterials to fetch.
     */
    orderBy?: LembreteMaterialOrderByWithRelationInput | LembreteMaterialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LembreteMaterialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LembreteMaterials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LembreteMaterials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LembreteMaterials
    **/
    _count?: true | LembreteMaterialCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LembreteMaterialAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LembreteMaterialSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LembreteMaterialMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LembreteMaterialMaxAggregateInputType
  }

  export type GetLembreteMaterialAggregateType<T extends LembreteMaterialAggregateArgs> = {
        [P in keyof T & keyof AggregateLembreteMaterial]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLembreteMaterial[P]>
      : GetScalarType<T[P], AggregateLembreteMaterial[P]>
  }




  export type LembreteMaterialGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LembreteMaterialWhereInput
    orderBy?: LembreteMaterialOrderByWithAggregationInput | LembreteMaterialOrderByWithAggregationInput[]
    by: LembreteMaterialScalarFieldEnum[] | LembreteMaterialScalarFieldEnum
    having?: LembreteMaterialScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LembreteMaterialCountAggregateInputType | true
    _avg?: LembreteMaterialAvgAggregateInputType
    _sum?: LembreteMaterialSumAggregateInputType
    _min?: LembreteMaterialMinAggregateInputType
    _max?: LembreteMaterialMaxAggregateInputType
  }

  export type LembreteMaterialGroupByOutputType = {
    id: number
    obraId: number
    materialId: number
    etapa: $Enums.EtapaTipo
    dataLembrete: Date
    enviado: boolean
    createdAt: Date
    _count: LembreteMaterialCountAggregateOutputType | null
    _avg: LembreteMaterialAvgAggregateOutputType | null
    _sum: LembreteMaterialSumAggregateOutputType | null
    _min: LembreteMaterialMinAggregateOutputType | null
    _max: LembreteMaterialMaxAggregateOutputType | null
  }

  type GetLembreteMaterialGroupByPayload<T extends LembreteMaterialGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LembreteMaterialGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LembreteMaterialGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LembreteMaterialGroupByOutputType[P]>
            : GetScalarType<T[P], LembreteMaterialGroupByOutputType[P]>
        }
      >
    >


  export type LembreteMaterialSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    obraId?: boolean
    materialId?: boolean
    etapa?: boolean
    dataLembrete?: boolean
    enviado?: boolean
    createdAt?: boolean
    obra?: boolean | ObraDefaultArgs<ExtArgs>
    material?: boolean | MaterialDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["lembreteMaterial"]>

  export type LembreteMaterialSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    obraId?: boolean
    materialId?: boolean
    etapa?: boolean
    dataLembrete?: boolean
    enviado?: boolean
    createdAt?: boolean
    obra?: boolean | ObraDefaultArgs<ExtArgs>
    material?: boolean | MaterialDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["lembreteMaterial"]>

  export type LembreteMaterialSelectScalar = {
    id?: boolean
    obraId?: boolean
    materialId?: boolean
    etapa?: boolean
    dataLembrete?: boolean
    enviado?: boolean
    createdAt?: boolean
  }

  export type LembreteMaterialInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    obra?: boolean | ObraDefaultArgs<ExtArgs>
    material?: boolean | MaterialDefaultArgs<ExtArgs>
  }
  export type LembreteMaterialIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    obra?: boolean | ObraDefaultArgs<ExtArgs>
    material?: boolean | MaterialDefaultArgs<ExtArgs>
  }

  export type $LembreteMaterialPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LembreteMaterial"
    objects: {
      obra: Prisma.$ObraPayload<ExtArgs>
      material: Prisma.$MaterialPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      obraId: number
      materialId: number
      etapa: $Enums.EtapaTipo
      dataLembrete: Date
      enviado: boolean
      createdAt: Date
    }, ExtArgs["result"]["lembreteMaterial"]>
    composites: {}
  }

  type LembreteMaterialGetPayload<S extends boolean | null | undefined | LembreteMaterialDefaultArgs> = $Result.GetResult<Prisma.$LembreteMaterialPayload, S>

  type LembreteMaterialCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<LembreteMaterialFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: LembreteMaterialCountAggregateInputType | true
    }

  export interface LembreteMaterialDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LembreteMaterial'], meta: { name: 'LembreteMaterial' } }
    /**
     * Find zero or one LembreteMaterial that matches the filter.
     * @param {LembreteMaterialFindUniqueArgs} args - Arguments to find a LembreteMaterial
     * @example
     * // Get one LembreteMaterial
     * const lembreteMaterial = await prisma.lembreteMaterial.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LembreteMaterialFindUniqueArgs>(args: SelectSubset<T, LembreteMaterialFindUniqueArgs<ExtArgs>>): Prisma__LembreteMaterialClient<$Result.GetResult<Prisma.$LembreteMaterialPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one LembreteMaterial that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {LembreteMaterialFindUniqueOrThrowArgs} args - Arguments to find a LembreteMaterial
     * @example
     * // Get one LembreteMaterial
     * const lembreteMaterial = await prisma.lembreteMaterial.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LembreteMaterialFindUniqueOrThrowArgs>(args: SelectSubset<T, LembreteMaterialFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LembreteMaterialClient<$Result.GetResult<Prisma.$LembreteMaterialPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first LembreteMaterial that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LembreteMaterialFindFirstArgs} args - Arguments to find a LembreteMaterial
     * @example
     * // Get one LembreteMaterial
     * const lembreteMaterial = await prisma.lembreteMaterial.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LembreteMaterialFindFirstArgs>(args?: SelectSubset<T, LembreteMaterialFindFirstArgs<ExtArgs>>): Prisma__LembreteMaterialClient<$Result.GetResult<Prisma.$LembreteMaterialPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first LembreteMaterial that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LembreteMaterialFindFirstOrThrowArgs} args - Arguments to find a LembreteMaterial
     * @example
     * // Get one LembreteMaterial
     * const lembreteMaterial = await prisma.lembreteMaterial.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LembreteMaterialFindFirstOrThrowArgs>(args?: SelectSubset<T, LembreteMaterialFindFirstOrThrowArgs<ExtArgs>>): Prisma__LembreteMaterialClient<$Result.GetResult<Prisma.$LembreteMaterialPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more LembreteMaterials that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LembreteMaterialFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LembreteMaterials
     * const lembreteMaterials = await prisma.lembreteMaterial.findMany()
     * 
     * // Get first 10 LembreteMaterials
     * const lembreteMaterials = await prisma.lembreteMaterial.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const lembreteMaterialWithIdOnly = await prisma.lembreteMaterial.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LembreteMaterialFindManyArgs>(args?: SelectSubset<T, LembreteMaterialFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LembreteMaterialPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a LembreteMaterial.
     * @param {LembreteMaterialCreateArgs} args - Arguments to create a LembreteMaterial.
     * @example
     * // Create one LembreteMaterial
     * const LembreteMaterial = await prisma.lembreteMaterial.create({
     *   data: {
     *     // ... data to create a LembreteMaterial
     *   }
     * })
     * 
     */
    create<T extends LembreteMaterialCreateArgs>(args: SelectSubset<T, LembreteMaterialCreateArgs<ExtArgs>>): Prisma__LembreteMaterialClient<$Result.GetResult<Prisma.$LembreteMaterialPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many LembreteMaterials.
     * @param {LembreteMaterialCreateManyArgs} args - Arguments to create many LembreteMaterials.
     * @example
     * // Create many LembreteMaterials
     * const lembreteMaterial = await prisma.lembreteMaterial.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LembreteMaterialCreateManyArgs>(args?: SelectSubset<T, LembreteMaterialCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LembreteMaterials and returns the data saved in the database.
     * @param {LembreteMaterialCreateManyAndReturnArgs} args - Arguments to create many LembreteMaterials.
     * @example
     * // Create many LembreteMaterials
     * const lembreteMaterial = await prisma.lembreteMaterial.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LembreteMaterials and only return the `id`
     * const lembreteMaterialWithIdOnly = await prisma.lembreteMaterial.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LembreteMaterialCreateManyAndReturnArgs>(args?: SelectSubset<T, LembreteMaterialCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LembreteMaterialPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a LembreteMaterial.
     * @param {LembreteMaterialDeleteArgs} args - Arguments to delete one LembreteMaterial.
     * @example
     * // Delete one LembreteMaterial
     * const LembreteMaterial = await prisma.lembreteMaterial.delete({
     *   where: {
     *     // ... filter to delete one LembreteMaterial
     *   }
     * })
     * 
     */
    delete<T extends LembreteMaterialDeleteArgs>(args: SelectSubset<T, LembreteMaterialDeleteArgs<ExtArgs>>): Prisma__LembreteMaterialClient<$Result.GetResult<Prisma.$LembreteMaterialPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one LembreteMaterial.
     * @param {LembreteMaterialUpdateArgs} args - Arguments to update one LembreteMaterial.
     * @example
     * // Update one LembreteMaterial
     * const lembreteMaterial = await prisma.lembreteMaterial.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LembreteMaterialUpdateArgs>(args: SelectSubset<T, LembreteMaterialUpdateArgs<ExtArgs>>): Prisma__LembreteMaterialClient<$Result.GetResult<Prisma.$LembreteMaterialPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more LembreteMaterials.
     * @param {LembreteMaterialDeleteManyArgs} args - Arguments to filter LembreteMaterials to delete.
     * @example
     * // Delete a few LembreteMaterials
     * const { count } = await prisma.lembreteMaterial.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LembreteMaterialDeleteManyArgs>(args?: SelectSubset<T, LembreteMaterialDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LembreteMaterials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LembreteMaterialUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LembreteMaterials
     * const lembreteMaterial = await prisma.lembreteMaterial.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LembreteMaterialUpdateManyArgs>(args: SelectSubset<T, LembreteMaterialUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one LembreteMaterial.
     * @param {LembreteMaterialUpsertArgs} args - Arguments to update or create a LembreteMaterial.
     * @example
     * // Update or create a LembreteMaterial
     * const lembreteMaterial = await prisma.lembreteMaterial.upsert({
     *   create: {
     *     // ... data to create a LembreteMaterial
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LembreteMaterial we want to update
     *   }
     * })
     */
    upsert<T extends LembreteMaterialUpsertArgs>(args: SelectSubset<T, LembreteMaterialUpsertArgs<ExtArgs>>): Prisma__LembreteMaterialClient<$Result.GetResult<Prisma.$LembreteMaterialPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of LembreteMaterials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LembreteMaterialCountArgs} args - Arguments to filter LembreteMaterials to count.
     * @example
     * // Count the number of LembreteMaterials
     * const count = await prisma.lembreteMaterial.count({
     *   where: {
     *     // ... the filter for the LembreteMaterials we want to count
     *   }
     * })
    **/
    count<T extends LembreteMaterialCountArgs>(
      args?: Subset<T, LembreteMaterialCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LembreteMaterialCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LembreteMaterial.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LembreteMaterialAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LembreteMaterialAggregateArgs>(args: Subset<T, LembreteMaterialAggregateArgs>): Prisma.PrismaPromise<GetLembreteMaterialAggregateType<T>>

    /**
     * Group by LembreteMaterial.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LembreteMaterialGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LembreteMaterialGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LembreteMaterialGroupByArgs['orderBy'] }
        : { orderBy?: LembreteMaterialGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LembreteMaterialGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLembreteMaterialGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LembreteMaterial model
   */
  readonly fields: LembreteMaterialFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LembreteMaterial.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LembreteMaterialClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    obra<T extends ObraDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ObraDefaultArgs<ExtArgs>>): Prisma__ObraClient<$Result.GetResult<Prisma.$ObraPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    material<T extends MaterialDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MaterialDefaultArgs<ExtArgs>>): Prisma__MaterialClient<$Result.GetResult<Prisma.$MaterialPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LembreteMaterial model
   */ 
  interface LembreteMaterialFieldRefs {
    readonly id: FieldRef<"LembreteMaterial", 'Int'>
    readonly obraId: FieldRef<"LembreteMaterial", 'Int'>
    readonly materialId: FieldRef<"LembreteMaterial", 'Int'>
    readonly etapa: FieldRef<"LembreteMaterial", 'EtapaTipo'>
    readonly dataLembrete: FieldRef<"LembreteMaterial", 'DateTime'>
    readonly enviado: FieldRef<"LembreteMaterial", 'Boolean'>
    readonly createdAt: FieldRef<"LembreteMaterial", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * LembreteMaterial findUnique
   */
  export type LembreteMaterialFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LembreteMaterial
     */
    select?: LembreteMaterialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LembreteMaterialInclude<ExtArgs> | null
    /**
     * Filter, which LembreteMaterial to fetch.
     */
    where: LembreteMaterialWhereUniqueInput
  }

  /**
   * LembreteMaterial findUniqueOrThrow
   */
  export type LembreteMaterialFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LembreteMaterial
     */
    select?: LembreteMaterialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LembreteMaterialInclude<ExtArgs> | null
    /**
     * Filter, which LembreteMaterial to fetch.
     */
    where: LembreteMaterialWhereUniqueInput
  }

  /**
   * LembreteMaterial findFirst
   */
  export type LembreteMaterialFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LembreteMaterial
     */
    select?: LembreteMaterialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LembreteMaterialInclude<ExtArgs> | null
    /**
     * Filter, which LembreteMaterial to fetch.
     */
    where?: LembreteMaterialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LembreteMaterials to fetch.
     */
    orderBy?: LembreteMaterialOrderByWithRelationInput | LembreteMaterialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LembreteMaterials.
     */
    cursor?: LembreteMaterialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LembreteMaterials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LembreteMaterials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LembreteMaterials.
     */
    distinct?: LembreteMaterialScalarFieldEnum | LembreteMaterialScalarFieldEnum[]
  }

  /**
   * LembreteMaterial findFirstOrThrow
   */
  export type LembreteMaterialFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LembreteMaterial
     */
    select?: LembreteMaterialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LembreteMaterialInclude<ExtArgs> | null
    /**
     * Filter, which LembreteMaterial to fetch.
     */
    where?: LembreteMaterialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LembreteMaterials to fetch.
     */
    orderBy?: LembreteMaterialOrderByWithRelationInput | LembreteMaterialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LembreteMaterials.
     */
    cursor?: LembreteMaterialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LembreteMaterials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LembreteMaterials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LembreteMaterials.
     */
    distinct?: LembreteMaterialScalarFieldEnum | LembreteMaterialScalarFieldEnum[]
  }

  /**
   * LembreteMaterial findMany
   */
  export type LembreteMaterialFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LembreteMaterial
     */
    select?: LembreteMaterialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LembreteMaterialInclude<ExtArgs> | null
    /**
     * Filter, which LembreteMaterials to fetch.
     */
    where?: LembreteMaterialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LembreteMaterials to fetch.
     */
    orderBy?: LembreteMaterialOrderByWithRelationInput | LembreteMaterialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LembreteMaterials.
     */
    cursor?: LembreteMaterialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LembreteMaterials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LembreteMaterials.
     */
    skip?: number
    distinct?: LembreteMaterialScalarFieldEnum | LembreteMaterialScalarFieldEnum[]
  }

  /**
   * LembreteMaterial create
   */
  export type LembreteMaterialCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LembreteMaterial
     */
    select?: LembreteMaterialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LembreteMaterialInclude<ExtArgs> | null
    /**
     * The data needed to create a LembreteMaterial.
     */
    data: XOR<LembreteMaterialCreateInput, LembreteMaterialUncheckedCreateInput>
  }

  /**
   * LembreteMaterial createMany
   */
  export type LembreteMaterialCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LembreteMaterials.
     */
    data: LembreteMaterialCreateManyInput | LembreteMaterialCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LembreteMaterial createManyAndReturn
   */
  export type LembreteMaterialCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LembreteMaterial
     */
    select?: LembreteMaterialSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many LembreteMaterials.
     */
    data: LembreteMaterialCreateManyInput | LembreteMaterialCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LembreteMaterialIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * LembreteMaterial update
   */
  export type LembreteMaterialUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LembreteMaterial
     */
    select?: LembreteMaterialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LembreteMaterialInclude<ExtArgs> | null
    /**
     * The data needed to update a LembreteMaterial.
     */
    data: XOR<LembreteMaterialUpdateInput, LembreteMaterialUncheckedUpdateInput>
    /**
     * Choose, which LembreteMaterial to update.
     */
    where: LembreteMaterialWhereUniqueInput
  }

  /**
   * LembreteMaterial updateMany
   */
  export type LembreteMaterialUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LembreteMaterials.
     */
    data: XOR<LembreteMaterialUpdateManyMutationInput, LembreteMaterialUncheckedUpdateManyInput>
    /**
     * Filter which LembreteMaterials to update
     */
    where?: LembreteMaterialWhereInput
  }

  /**
   * LembreteMaterial upsert
   */
  export type LembreteMaterialUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LembreteMaterial
     */
    select?: LembreteMaterialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LembreteMaterialInclude<ExtArgs> | null
    /**
     * The filter to search for the LembreteMaterial to update in case it exists.
     */
    where: LembreteMaterialWhereUniqueInput
    /**
     * In case the LembreteMaterial found by the `where` argument doesn't exist, create a new LembreteMaterial with this data.
     */
    create: XOR<LembreteMaterialCreateInput, LembreteMaterialUncheckedCreateInput>
    /**
     * In case the LembreteMaterial was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LembreteMaterialUpdateInput, LembreteMaterialUncheckedUpdateInput>
  }

  /**
   * LembreteMaterial delete
   */
  export type LembreteMaterialDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LembreteMaterial
     */
    select?: LembreteMaterialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LembreteMaterialInclude<ExtArgs> | null
    /**
     * Filter which LembreteMaterial to delete.
     */
    where: LembreteMaterialWhereUniqueInput
  }

  /**
   * LembreteMaterial deleteMany
   */
  export type LembreteMaterialDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LembreteMaterials to delete
     */
    where?: LembreteMaterialWhereInput
  }

  /**
   * LembreteMaterial without action
   */
  export type LembreteMaterialDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LembreteMaterial
     */
    select?: LembreteMaterialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LembreteMaterialInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UsuarioGerenciamentoScalarFieldEnum: {
    id: 'id',
    razaoSocial: 'razaoSocial',
    inscricaoEstadual: 'inscricaoEstadual',
    cnpj: 'cnpj',
    dataFundacao: 'dataFundacao',
    telefone: 'telefone',
    email: 'email',
    endereco: 'endereco',
    senhaHash: 'senhaHash',
    role: 'role',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UsuarioGerenciamentoScalarFieldEnum = (typeof UsuarioGerenciamentoScalarFieldEnum)[keyof typeof UsuarioGerenciamentoScalarFieldEnum]


  export const UsuarioExecucaoScalarFieldEnum: {
    id: 'id',
    nome: 'nome',
    cpf: 'cpf',
    endereco: 'endereco',
    creaCau: 'creaCau',
    telefone: 'telefone',
    email: 'email',
    dataNascimento: 'dataNascimento',
    senhaHash: 'senhaHash',
    role: 'role',
    empresaId: 'empresaId'
  };

  export type UsuarioExecucaoScalarFieldEnum = (typeof UsuarioExecucaoScalarFieldEnum)[keyof typeof UsuarioExecucaoScalarFieldEnum]


  export const ObraScalarFieldEnum: {
    id: 'id',
    tipoObra: 'tipoObra',
    endereco: 'endereco',
    creaCauResponsavel: 'creaCauResponsavel',
    cno: 'cno',
    gerenteId: 'gerenteId',
    responsavelId: 'responsavelId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ObraScalarFieldEnum = (typeof ObraScalarFieldEnum)[keyof typeof ObraScalarFieldEnum]


  export const JustificativaAtrasoScalarFieldEnum: {
    id: 'id',
    tipo: 'tipo',
    descricao: 'descricao',
    createdAt: 'createdAt'
  };

  export type JustificativaAtrasoScalarFieldEnum = (typeof JustificativaAtrasoScalarFieldEnum)[keyof typeof JustificativaAtrasoScalarFieldEnum]


  export const EtapaObraScalarFieldEnum: {
    id: 'id',
    obraId: 'obraId',
    tipo: 'tipo',
    subEtapa: 'subEtapa',
    status: 'status',
    dataPrevistaInicio: 'dataPrevistaInicio',
    dataPrevistaFim: 'dataPrevistaFim',
    dataRealInicio: 'dataRealInicio',
    dataRealFim: 'dataRealFim',
    justificativaId: 'justificativaId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type EtapaObraScalarFieldEnum = (typeof EtapaObraScalarFieldEnum)[keyof typeof EtapaObraScalarFieldEnum]


  export const MaterialScalarFieldEnum: {
    id: 'id',
    nome: 'nome',
    etapaDefault: 'etapaDefault',
    unidade: 'unidade'
  };

  export type MaterialScalarFieldEnum = (typeof MaterialScalarFieldEnum)[keyof typeof MaterialScalarFieldEnum]


  export const MaterialObraScalarFieldEnum: {
    id: 'id',
    obraId: 'obraId',
    materialId: 'materialId',
    etapa: 'etapa',
    quantidade: 'quantidade',
    statusPedido: 'statusPedido',
    dataPedido: 'dataPedido',
    dataEntrega: 'dataEntrega'
  };

  export type MaterialObraScalarFieldEnum = (typeof MaterialObraScalarFieldEnum)[keyof typeof MaterialObraScalarFieldEnum]


  export const LembreteMaterialScalarFieldEnum: {
    id: 'id',
    obraId: 'obraId',
    materialId: 'materialId',
    etapa: 'etapa',
    dataLembrete: 'dataLembrete',
    enviado: 'enviado',
    createdAt: 'createdAt'
  };

  export type LembreteMaterialScalarFieldEnum = (typeof LembreteMaterialScalarFieldEnum)[keyof typeof LembreteMaterialScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Role'
   */
  export type EnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Role'>
    


  /**
   * Reference to a field of type 'Role[]'
   */
  export type ListEnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Role[]'>
    


  /**
   * Reference to a field of type 'TipoObra'
   */
  export type EnumTipoObraFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TipoObra'>
    


  /**
   * Reference to a field of type 'TipoObra[]'
   */
  export type ListEnumTipoObraFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TipoObra[]'>
    


  /**
   * Reference to a field of type 'TipoJustificativa'
   */
  export type EnumTipoJustificativaFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TipoJustificativa'>
    


  /**
   * Reference to a field of type 'TipoJustificativa[]'
   */
  export type ListEnumTipoJustificativaFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TipoJustificativa[]'>
    


  /**
   * Reference to a field of type 'EtapaTipo'
   */
  export type EnumEtapaTipoFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EtapaTipo'>
    


  /**
   * Reference to a field of type 'EtapaTipo[]'
   */
  export type ListEnumEtapaTipoFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EtapaTipo[]'>
    


  /**
   * Reference to a field of type 'SubEtapaTipo'
   */
  export type EnumSubEtapaTipoFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SubEtapaTipo'>
    


  /**
   * Reference to a field of type 'SubEtapaTipo[]'
   */
  export type ListEnumSubEtapaTipoFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SubEtapaTipo[]'>
    


  /**
   * Reference to a field of type 'StatusEtapa'
   */
  export type EnumStatusEtapaFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'StatusEtapa'>
    


  /**
   * Reference to a field of type 'StatusEtapa[]'
   */
  export type ListEnumStatusEtapaFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'StatusEtapa[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'StatusPedido'
   */
  export type EnumStatusPedidoFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'StatusPedido'>
    


  /**
   * Reference to a field of type 'StatusPedido[]'
   */
  export type ListEnumStatusPedidoFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'StatusPedido[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    
  /**
   * Deep Input Types
   */


  export type UsuarioGerenciamentoWhereInput = {
    AND?: UsuarioGerenciamentoWhereInput | UsuarioGerenciamentoWhereInput[]
    OR?: UsuarioGerenciamentoWhereInput[]
    NOT?: UsuarioGerenciamentoWhereInput | UsuarioGerenciamentoWhereInput[]
    id?: IntFilter<"UsuarioGerenciamento"> | number
    razaoSocial?: StringFilter<"UsuarioGerenciamento"> | string
    inscricaoEstadual?: StringNullableFilter<"UsuarioGerenciamento"> | string | null
    cnpj?: StringFilter<"UsuarioGerenciamento"> | string
    dataFundacao?: DateTimeNullableFilter<"UsuarioGerenciamento"> | Date | string | null
    telefone?: StringNullableFilter<"UsuarioGerenciamento"> | string | null
    email?: StringFilter<"UsuarioGerenciamento"> | string
    endereco?: StringFilter<"UsuarioGerenciamento"> | string
    senhaHash?: StringFilter<"UsuarioGerenciamento"> | string
    role?: EnumRoleFilter<"UsuarioGerenciamento"> | $Enums.Role
    createdAt?: DateTimeFilter<"UsuarioGerenciamento"> | Date | string
    updatedAt?: DateTimeFilter<"UsuarioGerenciamento"> | Date | string
    obras?: ObraListRelationFilter
    usuariosExecucao?: UsuarioExecucaoListRelationFilter
  }

  export type UsuarioGerenciamentoOrderByWithRelationInput = {
    id?: SortOrder
    razaoSocial?: SortOrder
    inscricaoEstadual?: SortOrderInput | SortOrder
    cnpj?: SortOrder
    dataFundacao?: SortOrderInput | SortOrder
    telefone?: SortOrderInput | SortOrder
    email?: SortOrder
    endereco?: SortOrder
    senhaHash?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    obras?: ObraOrderByRelationAggregateInput
    usuariosExecucao?: UsuarioExecucaoOrderByRelationAggregateInput
  }

  export type UsuarioGerenciamentoWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    cnpj?: string
    email?: string
    AND?: UsuarioGerenciamentoWhereInput | UsuarioGerenciamentoWhereInput[]
    OR?: UsuarioGerenciamentoWhereInput[]
    NOT?: UsuarioGerenciamentoWhereInput | UsuarioGerenciamentoWhereInput[]
    razaoSocial?: StringFilter<"UsuarioGerenciamento"> | string
    inscricaoEstadual?: StringNullableFilter<"UsuarioGerenciamento"> | string | null
    dataFundacao?: DateTimeNullableFilter<"UsuarioGerenciamento"> | Date | string | null
    telefone?: StringNullableFilter<"UsuarioGerenciamento"> | string | null
    endereco?: StringFilter<"UsuarioGerenciamento"> | string
    senhaHash?: StringFilter<"UsuarioGerenciamento"> | string
    role?: EnumRoleFilter<"UsuarioGerenciamento"> | $Enums.Role
    createdAt?: DateTimeFilter<"UsuarioGerenciamento"> | Date | string
    updatedAt?: DateTimeFilter<"UsuarioGerenciamento"> | Date | string
    obras?: ObraListRelationFilter
    usuariosExecucao?: UsuarioExecucaoListRelationFilter
  }, "id" | "cnpj" | "email">

  export type UsuarioGerenciamentoOrderByWithAggregationInput = {
    id?: SortOrder
    razaoSocial?: SortOrder
    inscricaoEstadual?: SortOrderInput | SortOrder
    cnpj?: SortOrder
    dataFundacao?: SortOrderInput | SortOrder
    telefone?: SortOrderInput | SortOrder
    email?: SortOrder
    endereco?: SortOrder
    senhaHash?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UsuarioGerenciamentoCountOrderByAggregateInput
    _avg?: UsuarioGerenciamentoAvgOrderByAggregateInput
    _max?: UsuarioGerenciamentoMaxOrderByAggregateInput
    _min?: UsuarioGerenciamentoMinOrderByAggregateInput
    _sum?: UsuarioGerenciamentoSumOrderByAggregateInput
  }

  export type UsuarioGerenciamentoScalarWhereWithAggregatesInput = {
    AND?: UsuarioGerenciamentoScalarWhereWithAggregatesInput | UsuarioGerenciamentoScalarWhereWithAggregatesInput[]
    OR?: UsuarioGerenciamentoScalarWhereWithAggregatesInput[]
    NOT?: UsuarioGerenciamentoScalarWhereWithAggregatesInput | UsuarioGerenciamentoScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"UsuarioGerenciamento"> | number
    razaoSocial?: StringWithAggregatesFilter<"UsuarioGerenciamento"> | string
    inscricaoEstadual?: StringNullableWithAggregatesFilter<"UsuarioGerenciamento"> | string | null
    cnpj?: StringWithAggregatesFilter<"UsuarioGerenciamento"> | string
    dataFundacao?: DateTimeNullableWithAggregatesFilter<"UsuarioGerenciamento"> | Date | string | null
    telefone?: StringNullableWithAggregatesFilter<"UsuarioGerenciamento"> | string | null
    email?: StringWithAggregatesFilter<"UsuarioGerenciamento"> | string
    endereco?: StringWithAggregatesFilter<"UsuarioGerenciamento"> | string
    senhaHash?: StringWithAggregatesFilter<"UsuarioGerenciamento"> | string
    role?: EnumRoleWithAggregatesFilter<"UsuarioGerenciamento"> | $Enums.Role
    createdAt?: DateTimeWithAggregatesFilter<"UsuarioGerenciamento"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"UsuarioGerenciamento"> | Date | string
  }

  export type UsuarioExecucaoWhereInput = {
    AND?: UsuarioExecucaoWhereInput | UsuarioExecucaoWhereInput[]
    OR?: UsuarioExecucaoWhereInput[]
    NOT?: UsuarioExecucaoWhereInput | UsuarioExecucaoWhereInput[]
    id?: IntFilter<"UsuarioExecucao"> | number
    nome?: StringFilter<"UsuarioExecucao"> | string
    cpf?: StringFilter<"UsuarioExecucao"> | string
    endereco?: StringFilter<"UsuarioExecucao"> | string
    creaCau?: StringFilter<"UsuarioExecucao"> | string
    telefone?: StringNullableFilter<"UsuarioExecucao"> | string | null
    email?: StringFilter<"UsuarioExecucao"> | string
    dataNascimento?: DateTimeNullableFilter<"UsuarioExecucao"> | Date | string | null
    senhaHash?: StringFilter<"UsuarioExecucao"> | string
    role?: EnumRoleFilter<"UsuarioExecucao"> | $Enums.Role
    empresaId?: IntFilter<"UsuarioExecucao"> | number
    empresa?: XOR<UsuarioGerenciamentoRelationFilter, UsuarioGerenciamentoWhereInput>
    obrasResponsavel?: ObraListRelationFilter
  }

  export type UsuarioExecucaoOrderByWithRelationInput = {
    id?: SortOrder
    nome?: SortOrder
    cpf?: SortOrder
    endereco?: SortOrder
    creaCau?: SortOrder
    telefone?: SortOrderInput | SortOrder
    email?: SortOrder
    dataNascimento?: SortOrderInput | SortOrder
    senhaHash?: SortOrder
    role?: SortOrder
    empresaId?: SortOrder
    empresa?: UsuarioGerenciamentoOrderByWithRelationInput
    obrasResponsavel?: ObraOrderByRelationAggregateInput
  }

  export type UsuarioExecucaoWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    cpf?: string
    creaCau?: string
    email?: string
    AND?: UsuarioExecucaoWhereInput | UsuarioExecucaoWhereInput[]
    OR?: UsuarioExecucaoWhereInput[]
    NOT?: UsuarioExecucaoWhereInput | UsuarioExecucaoWhereInput[]
    nome?: StringFilter<"UsuarioExecucao"> | string
    endereco?: StringFilter<"UsuarioExecucao"> | string
    telefone?: StringNullableFilter<"UsuarioExecucao"> | string | null
    dataNascimento?: DateTimeNullableFilter<"UsuarioExecucao"> | Date | string | null
    senhaHash?: StringFilter<"UsuarioExecucao"> | string
    role?: EnumRoleFilter<"UsuarioExecucao"> | $Enums.Role
    empresaId?: IntFilter<"UsuarioExecucao"> | number
    empresa?: XOR<UsuarioGerenciamentoRelationFilter, UsuarioGerenciamentoWhereInput>
    obrasResponsavel?: ObraListRelationFilter
  }, "id" | "cpf" | "creaCau" | "email">

  export type UsuarioExecucaoOrderByWithAggregationInput = {
    id?: SortOrder
    nome?: SortOrder
    cpf?: SortOrder
    endereco?: SortOrder
    creaCau?: SortOrder
    telefone?: SortOrderInput | SortOrder
    email?: SortOrder
    dataNascimento?: SortOrderInput | SortOrder
    senhaHash?: SortOrder
    role?: SortOrder
    empresaId?: SortOrder
    _count?: UsuarioExecucaoCountOrderByAggregateInput
    _avg?: UsuarioExecucaoAvgOrderByAggregateInput
    _max?: UsuarioExecucaoMaxOrderByAggregateInput
    _min?: UsuarioExecucaoMinOrderByAggregateInput
    _sum?: UsuarioExecucaoSumOrderByAggregateInput
  }

  export type UsuarioExecucaoScalarWhereWithAggregatesInput = {
    AND?: UsuarioExecucaoScalarWhereWithAggregatesInput | UsuarioExecucaoScalarWhereWithAggregatesInput[]
    OR?: UsuarioExecucaoScalarWhereWithAggregatesInput[]
    NOT?: UsuarioExecucaoScalarWhereWithAggregatesInput | UsuarioExecucaoScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"UsuarioExecucao"> | number
    nome?: StringWithAggregatesFilter<"UsuarioExecucao"> | string
    cpf?: StringWithAggregatesFilter<"UsuarioExecucao"> | string
    endereco?: StringWithAggregatesFilter<"UsuarioExecucao"> | string
    creaCau?: StringWithAggregatesFilter<"UsuarioExecucao"> | string
    telefone?: StringNullableWithAggregatesFilter<"UsuarioExecucao"> | string | null
    email?: StringWithAggregatesFilter<"UsuarioExecucao"> | string
    dataNascimento?: DateTimeNullableWithAggregatesFilter<"UsuarioExecucao"> | Date | string | null
    senhaHash?: StringWithAggregatesFilter<"UsuarioExecucao"> | string
    role?: EnumRoleWithAggregatesFilter<"UsuarioExecucao"> | $Enums.Role
    empresaId?: IntWithAggregatesFilter<"UsuarioExecucao"> | number
  }

  export type ObraWhereInput = {
    AND?: ObraWhereInput | ObraWhereInput[]
    OR?: ObraWhereInput[]
    NOT?: ObraWhereInput | ObraWhereInput[]
    id?: IntFilter<"Obra"> | number
    tipoObra?: EnumTipoObraFilter<"Obra"> | $Enums.TipoObra
    endereco?: StringFilter<"Obra"> | string
    creaCauResponsavel?: StringFilter<"Obra"> | string
    cno?: StringFilter<"Obra"> | string
    gerenteId?: IntFilter<"Obra"> | number
    responsavelId?: IntFilter<"Obra"> | number
    createdAt?: DateTimeFilter<"Obra"> | Date | string
    updatedAt?: DateTimeFilter<"Obra"> | Date | string
    gerente?: XOR<UsuarioGerenciamentoRelationFilter, UsuarioGerenciamentoWhereInput>
    responsavel?: XOR<UsuarioExecucaoRelationFilter, UsuarioExecucaoWhereInput>
    etapas?: EtapaObraListRelationFilter
    materiaisPedidos?: MaterialObraListRelationFilter
    lembretes?: LembreteMaterialListRelationFilter
  }

  export type ObraOrderByWithRelationInput = {
    id?: SortOrder
    tipoObra?: SortOrder
    endereco?: SortOrder
    creaCauResponsavel?: SortOrder
    cno?: SortOrder
    gerenteId?: SortOrder
    responsavelId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    gerente?: UsuarioGerenciamentoOrderByWithRelationInput
    responsavel?: UsuarioExecucaoOrderByWithRelationInput
    etapas?: EtapaObraOrderByRelationAggregateInput
    materiaisPedidos?: MaterialObraOrderByRelationAggregateInput
    lembretes?: LembreteMaterialOrderByRelationAggregateInput
  }

  export type ObraWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    cno?: string
    AND?: ObraWhereInput | ObraWhereInput[]
    OR?: ObraWhereInput[]
    NOT?: ObraWhereInput | ObraWhereInput[]
    tipoObra?: EnumTipoObraFilter<"Obra"> | $Enums.TipoObra
    endereco?: StringFilter<"Obra"> | string
    creaCauResponsavel?: StringFilter<"Obra"> | string
    gerenteId?: IntFilter<"Obra"> | number
    responsavelId?: IntFilter<"Obra"> | number
    createdAt?: DateTimeFilter<"Obra"> | Date | string
    updatedAt?: DateTimeFilter<"Obra"> | Date | string
    gerente?: XOR<UsuarioGerenciamentoRelationFilter, UsuarioGerenciamentoWhereInput>
    responsavel?: XOR<UsuarioExecucaoRelationFilter, UsuarioExecucaoWhereInput>
    etapas?: EtapaObraListRelationFilter
    materiaisPedidos?: MaterialObraListRelationFilter
    lembretes?: LembreteMaterialListRelationFilter
  }, "id" | "cno">

  export type ObraOrderByWithAggregationInput = {
    id?: SortOrder
    tipoObra?: SortOrder
    endereco?: SortOrder
    creaCauResponsavel?: SortOrder
    cno?: SortOrder
    gerenteId?: SortOrder
    responsavelId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ObraCountOrderByAggregateInput
    _avg?: ObraAvgOrderByAggregateInput
    _max?: ObraMaxOrderByAggregateInput
    _min?: ObraMinOrderByAggregateInput
    _sum?: ObraSumOrderByAggregateInput
  }

  export type ObraScalarWhereWithAggregatesInput = {
    AND?: ObraScalarWhereWithAggregatesInput | ObraScalarWhereWithAggregatesInput[]
    OR?: ObraScalarWhereWithAggregatesInput[]
    NOT?: ObraScalarWhereWithAggregatesInput | ObraScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Obra"> | number
    tipoObra?: EnumTipoObraWithAggregatesFilter<"Obra"> | $Enums.TipoObra
    endereco?: StringWithAggregatesFilter<"Obra"> | string
    creaCauResponsavel?: StringWithAggregatesFilter<"Obra"> | string
    cno?: StringWithAggregatesFilter<"Obra"> | string
    gerenteId?: IntWithAggregatesFilter<"Obra"> | number
    responsavelId?: IntWithAggregatesFilter<"Obra"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Obra"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Obra"> | Date | string
  }

  export type JustificativaAtrasoWhereInput = {
    AND?: JustificativaAtrasoWhereInput | JustificativaAtrasoWhereInput[]
    OR?: JustificativaAtrasoWhereInput[]
    NOT?: JustificativaAtrasoWhereInput | JustificativaAtrasoWhereInput[]
    id?: IntFilter<"JustificativaAtraso"> | number
    tipo?: EnumTipoJustificativaFilter<"JustificativaAtraso"> | $Enums.TipoJustificativa
    descricao?: StringNullableFilter<"JustificativaAtraso"> | string | null
    createdAt?: DateTimeFilter<"JustificativaAtraso"> | Date | string
    etapas?: EtapaObraListRelationFilter
  }

  export type JustificativaAtrasoOrderByWithRelationInput = {
    id?: SortOrder
    tipo?: SortOrder
    descricao?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    etapas?: EtapaObraOrderByRelationAggregateInput
  }

  export type JustificativaAtrasoWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: JustificativaAtrasoWhereInput | JustificativaAtrasoWhereInput[]
    OR?: JustificativaAtrasoWhereInput[]
    NOT?: JustificativaAtrasoWhereInput | JustificativaAtrasoWhereInput[]
    tipo?: EnumTipoJustificativaFilter<"JustificativaAtraso"> | $Enums.TipoJustificativa
    descricao?: StringNullableFilter<"JustificativaAtraso"> | string | null
    createdAt?: DateTimeFilter<"JustificativaAtraso"> | Date | string
    etapas?: EtapaObraListRelationFilter
  }, "id">

  export type JustificativaAtrasoOrderByWithAggregationInput = {
    id?: SortOrder
    tipo?: SortOrder
    descricao?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: JustificativaAtrasoCountOrderByAggregateInput
    _avg?: JustificativaAtrasoAvgOrderByAggregateInput
    _max?: JustificativaAtrasoMaxOrderByAggregateInput
    _min?: JustificativaAtrasoMinOrderByAggregateInput
    _sum?: JustificativaAtrasoSumOrderByAggregateInput
  }

  export type JustificativaAtrasoScalarWhereWithAggregatesInput = {
    AND?: JustificativaAtrasoScalarWhereWithAggregatesInput | JustificativaAtrasoScalarWhereWithAggregatesInput[]
    OR?: JustificativaAtrasoScalarWhereWithAggregatesInput[]
    NOT?: JustificativaAtrasoScalarWhereWithAggregatesInput | JustificativaAtrasoScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"JustificativaAtraso"> | number
    tipo?: EnumTipoJustificativaWithAggregatesFilter<"JustificativaAtraso"> | $Enums.TipoJustificativa
    descricao?: StringNullableWithAggregatesFilter<"JustificativaAtraso"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"JustificativaAtraso"> | Date | string
  }

  export type EtapaObraWhereInput = {
    AND?: EtapaObraWhereInput | EtapaObraWhereInput[]
    OR?: EtapaObraWhereInput[]
    NOT?: EtapaObraWhereInput | EtapaObraWhereInput[]
    id?: IntFilter<"EtapaObra"> | number
    obraId?: IntFilter<"EtapaObra"> | number
    tipo?: EnumEtapaTipoFilter<"EtapaObra"> | $Enums.EtapaTipo
    subEtapa?: EnumSubEtapaTipoNullableFilter<"EtapaObra"> | $Enums.SubEtapaTipo | null
    status?: EnumStatusEtapaFilter<"EtapaObra"> | $Enums.StatusEtapa
    dataPrevistaInicio?: DateTimeNullableFilter<"EtapaObra"> | Date | string | null
    dataPrevistaFim?: DateTimeNullableFilter<"EtapaObra"> | Date | string | null
    dataRealInicio?: DateTimeNullableFilter<"EtapaObra"> | Date | string | null
    dataRealFim?: DateTimeNullableFilter<"EtapaObra"> | Date | string | null
    justificativaId?: IntNullableFilter<"EtapaObra"> | number | null
    createdAt?: DateTimeFilter<"EtapaObra"> | Date | string
    updatedAt?: DateTimeFilter<"EtapaObra"> | Date | string
    obra?: XOR<ObraRelationFilter, ObraWhereInput>
    justificativa?: XOR<JustificativaAtrasoNullableRelationFilter, JustificativaAtrasoWhereInput> | null
  }

  export type EtapaObraOrderByWithRelationInput = {
    id?: SortOrder
    obraId?: SortOrder
    tipo?: SortOrder
    subEtapa?: SortOrderInput | SortOrder
    status?: SortOrder
    dataPrevistaInicio?: SortOrderInput | SortOrder
    dataPrevistaFim?: SortOrderInput | SortOrder
    dataRealInicio?: SortOrderInput | SortOrder
    dataRealFim?: SortOrderInput | SortOrder
    justificativaId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    obra?: ObraOrderByWithRelationInput
    justificativa?: JustificativaAtrasoOrderByWithRelationInput
  }

  export type EtapaObraWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: EtapaObraWhereInput | EtapaObraWhereInput[]
    OR?: EtapaObraWhereInput[]
    NOT?: EtapaObraWhereInput | EtapaObraWhereInput[]
    obraId?: IntFilter<"EtapaObra"> | number
    tipo?: EnumEtapaTipoFilter<"EtapaObra"> | $Enums.EtapaTipo
    subEtapa?: EnumSubEtapaTipoNullableFilter<"EtapaObra"> | $Enums.SubEtapaTipo | null
    status?: EnumStatusEtapaFilter<"EtapaObra"> | $Enums.StatusEtapa
    dataPrevistaInicio?: DateTimeNullableFilter<"EtapaObra"> | Date | string | null
    dataPrevistaFim?: DateTimeNullableFilter<"EtapaObra"> | Date | string | null
    dataRealInicio?: DateTimeNullableFilter<"EtapaObra"> | Date | string | null
    dataRealFim?: DateTimeNullableFilter<"EtapaObra"> | Date | string | null
    justificativaId?: IntNullableFilter<"EtapaObra"> | number | null
    createdAt?: DateTimeFilter<"EtapaObra"> | Date | string
    updatedAt?: DateTimeFilter<"EtapaObra"> | Date | string
    obra?: XOR<ObraRelationFilter, ObraWhereInput>
    justificativa?: XOR<JustificativaAtrasoNullableRelationFilter, JustificativaAtrasoWhereInput> | null
  }, "id">

  export type EtapaObraOrderByWithAggregationInput = {
    id?: SortOrder
    obraId?: SortOrder
    tipo?: SortOrder
    subEtapa?: SortOrderInput | SortOrder
    status?: SortOrder
    dataPrevistaInicio?: SortOrderInput | SortOrder
    dataPrevistaFim?: SortOrderInput | SortOrder
    dataRealInicio?: SortOrderInput | SortOrder
    dataRealFim?: SortOrderInput | SortOrder
    justificativaId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: EtapaObraCountOrderByAggregateInput
    _avg?: EtapaObraAvgOrderByAggregateInput
    _max?: EtapaObraMaxOrderByAggregateInput
    _min?: EtapaObraMinOrderByAggregateInput
    _sum?: EtapaObraSumOrderByAggregateInput
  }

  export type EtapaObraScalarWhereWithAggregatesInput = {
    AND?: EtapaObraScalarWhereWithAggregatesInput | EtapaObraScalarWhereWithAggregatesInput[]
    OR?: EtapaObraScalarWhereWithAggregatesInput[]
    NOT?: EtapaObraScalarWhereWithAggregatesInput | EtapaObraScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"EtapaObra"> | number
    obraId?: IntWithAggregatesFilter<"EtapaObra"> | number
    tipo?: EnumEtapaTipoWithAggregatesFilter<"EtapaObra"> | $Enums.EtapaTipo
    subEtapa?: EnumSubEtapaTipoNullableWithAggregatesFilter<"EtapaObra"> | $Enums.SubEtapaTipo | null
    status?: EnumStatusEtapaWithAggregatesFilter<"EtapaObra"> | $Enums.StatusEtapa
    dataPrevistaInicio?: DateTimeNullableWithAggregatesFilter<"EtapaObra"> | Date | string | null
    dataPrevistaFim?: DateTimeNullableWithAggregatesFilter<"EtapaObra"> | Date | string | null
    dataRealInicio?: DateTimeNullableWithAggregatesFilter<"EtapaObra"> | Date | string | null
    dataRealFim?: DateTimeNullableWithAggregatesFilter<"EtapaObra"> | Date | string | null
    justificativaId?: IntNullableWithAggregatesFilter<"EtapaObra"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"EtapaObra"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"EtapaObra"> | Date | string
  }

  export type MaterialWhereInput = {
    AND?: MaterialWhereInput | MaterialWhereInput[]
    OR?: MaterialWhereInput[]
    NOT?: MaterialWhereInput | MaterialWhereInput[]
    id?: IntFilter<"Material"> | number
    nome?: StringFilter<"Material"> | string
    etapaDefault?: EnumEtapaTipoNullableFilter<"Material"> | $Enums.EtapaTipo | null
    unidade?: StringFilter<"Material"> | string
    itens?: MaterialObraListRelationFilter
    lembretes?: LembreteMaterialListRelationFilter
  }

  export type MaterialOrderByWithRelationInput = {
    id?: SortOrder
    nome?: SortOrder
    etapaDefault?: SortOrderInput | SortOrder
    unidade?: SortOrder
    itens?: MaterialObraOrderByRelationAggregateInput
    lembretes?: LembreteMaterialOrderByRelationAggregateInput
  }

  export type MaterialWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: MaterialWhereInput | MaterialWhereInput[]
    OR?: MaterialWhereInput[]
    NOT?: MaterialWhereInput | MaterialWhereInput[]
    nome?: StringFilter<"Material"> | string
    etapaDefault?: EnumEtapaTipoNullableFilter<"Material"> | $Enums.EtapaTipo | null
    unidade?: StringFilter<"Material"> | string
    itens?: MaterialObraListRelationFilter
    lembretes?: LembreteMaterialListRelationFilter
  }, "id">

  export type MaterialOrderByWithAggregationInput = {
    id?: SortOrder
    nome?: SortOrder
    etapaDefault?: SortOrderInput | SortOrder
    unidade?: SortOrder
    _count?: MaterialCountOrderByAggregateInput
    _avg?: MaterialAvgOrderByAggregateInput
    _max?: MaterialMaxOrderByAggregateInput
    _min?: MaterialMinOrderByAggregateInput
    _sum?: MaterialSumOrderByAggregateInput
  }

  export type MaterialScalarWhereWithAggregatesInput = {
    AND?: MaterialScalarWhereWithAggregatesInput | MaterialScalarWhereWithAggregatesInput[]
    OR?: MaterialScalarWhereWithAggregatesInput[]
    NOT?: MaterialScalarWhereWithAggregatesInput | MaterialScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Material"> | number
    nome?: StringWithAggregatesFilter<"Material"> | string
    etapaDefault?: EnumEtapaTipoNullableWithAggregatesFilter<"Material"> | $Enums.EtapaTipo | null
    unidade?: StringWithAggregatesFilter<"Material"> | string
  }

  export type MaterialObraWhereInput = {
    AND?: MaterialObraWhereInput | MaterialObraWhereInput[]
    OR?: MaterialObraWhereInput[]
    NOT?: MaterialObraWhereInput | MaterialObraWhereInput[]
    id?: IntFilter<"MaterialObra"> | number
    obraId?: IntFilter<"MaterialObra"> | number
    materialId?: IntFilter<"MaterialObra"> | number
    etapa?: EnumEtapaTipoFilter<"MaterialObra"> | $Enums.EtapaTipo
    quantidade?: FloatFilter<"MaterialObra"> | number
    statusPedido?: EnumStatusPedidoFilter<"MaterialObra"> | $Enums.StatusPedido
    dataPedido?: DateTimeNullableFilter<"MaterialObra"> | Date | string | null
    dataEntrega?: DateTimeNullableFilter<"MaterialObra"> | Date | string | null
    obra?: XOR<ObraRelationFilter, ObraWhereInput>
    material?: XOR<MaterialRelationFilter, MaterialWhereInput>
  }

  export type MaterialObraOrderByWithRelationInput = {
    id?: SortOrder
    obraId?: SortOrder
    materialId?: SortOrder
    etapa?: SortOrder
    quantidade?: SortOrder
    statusPedido?: SortOrder
    dataPedido?: SortOrderInput | SortOrder
    dataEntrega?: SortOrderInput | SortOrder
    obra?: ObraOrderByWithRelationInput
    material?: MaterialOrderByWithRelationInput
  }

  export type MaterialObraWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: MaterialObraWhereInput | MaterialObraWhereInput[]
    OR?: MaterialObraWhereInput[]
    NOT?: MaterialObraWhereInput | MaterialObraWhereInput[]
    obraId?: IntFilter<"MaterialObra"> | number
    materialId?: IntFilter<"MaterialObra"> | number
    etapa?: EnumEtapaTipoFilter<"MaterialObra"> | $Enums.EtapaTipo
    quantidade?: FloatFilter<"MaterialObra"> | number
    statusPedido?: EnumStatusPedidoFilter<"MaterialObra"> | $Enums.StatusPedido
    dataPedido?: DateTimeNullableFilter<"MaterialObra"> | Date | string | null
    dataEntrega?: DateTimeNullableFilter<"MaterialObra"> | Date | string | null
    obra?: XOR<ObraRelationFilter, ObraWhereInput>
    material?: XOR<MaterialRelationFilter, MaterialWhereInput>
  }, "id">

  export type MaterialObraOrderByWithAggregationInput = {
    id?: SortOrder
    obraId?: SortOrder
    materialId?: SortOrder
    etapa?: SortOrder
    quantidade?: SortOrder
    statusPedido?: SortOrder
    dataPedido?: SortOrderInput | SortOrder
    dataEntrega?: SortOrderInput | SortOrder
    _count?: MaterialObraCountOrderByAggregateInput
    _avg?: MaterialObraAvgOrderByAggregateInput
    _max?: MaterialObraMaxOrderByAggregateInput
    _min?: MaterialObraMinOrderByAggregateInput
    _sum?: MaterialObraSumOrderByAggregateInput
  }

  export type MaterialObraScalarWhereWithAggregatesInput = {
    AND?: MaterialObraScalarWhereWithAggregatesInput | MaterialObraScalarWhereWithAggregatesInput[]
    OR?: MaterialObraScalarWhereWithAggregatesInput[]
    NOT?: MaterialObraScalarWhereWithAggregatesInput | MaterialObraScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"MaterialObra"> | number
    obraId?: IntWithAggregatesFilter<"MaterialObra"> | number
    materialId?: IntWithAggregatesFilter<"MaterialObra"> | number
    etapa?: EnumEtapaTipoWithAggregatesFilter<"MaterialObra"> | $Enums.EtapaTipo
    quantidade?: FloatWithAggregatesFilter<"MaterialObra"> | number
    statusPedido?: EnumStatusPedidoWithAggregatesFilter<"MaterialObra"> | $Enums.StatusPedido
    dataPedido?: DateTimeNullableWithAggregatesFilter<"MaterialObra"> | Date | string | null
    dataEntrega?: DateTimeNullableWithAggregatesFilter<"MaterialObra"> | Date | string | null
  }

  export type LembreteMaterialWhereInput = {
    AND?: LembreteMaterialWhereInput | LembreteMaterialWhereInput[]
    OR?: LembreteMaterialWhereInput[]
    NOT?: LembreteMaterialWhereInput | LembreteMaterialWhereInput[]
    id?: IntFilter<"LembreteMaterial"> | number
    obraId?: IntFilter<"LembreteMaterial"> | number
    materialId?: IntFilter<"LembreteMaterial"> | number
    etapa?: EnumEtapaTipoFilter<"LembreteMaterial"> | $Enums.EtapaTipo
    dataLembrete?: DateTimeFilter<"LembreteMaterial"> | Date | string
    enviado?: BoolFilter<"LembreteMaterial"> | boolean
    createdAt?: DateTimeFilter<"LembreteMaterial"> | Date | string
    obra?: XOR<ObraRelationFilter, ObraWhereInput>
    material?: XOR<MaterialRelationFilter, MaterialWhereInput>
  }

  export type LembreteMaterialOrderByWithRelationInput = {
    id?: SortOrder
    obraId?: SortOrder
    materialId?: SortOrder
    etapa?: SortOrder
    dataLembrete?: SortOrder
    enviado?: SortOrder
    createdAt?: SortOrder
    obra?: ObraOrderByWithRelationInput
    material?: MaterialOrderByWithRelationInput
  }

  export type LembreteMaterialWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: LembreteMaterialWhereInput | LembreteMaterialWhereInput[]
    OR?: LembreteMaterialWhereInput[]
    NOT?: LembreteMaterialWhereInput | LembreteMaterialWhereInput[]
    obraId?: IntFilter<"LembreteMaterial"> | number
    materialId?: IntFilter<"LembreteMaterial"> | number
    etapa?: EnumEtapaTipoFilter<"LembreteMaterial"> | $Enums.EtapaTipo
    dataLembrete?: DateTimeFilter<"LembreteMaterial"> | Date | string
    enviado?: BoolFilter<"LembreteMaterial"> | boolean
    createdAt?: DateTimeFilter<"LembreteMaterial"> | Date | string
    obra?: XOR<ObraRelationFilter, ObraWhereInput>
    material?: XOR<MaterialRelationFilter, MaterialWhereInput>
  }, "id">

  export type LembreteMaterialOrderByWithAggregationInput = {
    id?: SortOrder
    obraId?: SortOrder
    materialId?: SortOrder
    etapa?: SortOrder
    dataLembrete?: SortOrder
    enviado?: SortOrder
    createdAt?: SortOrder
    _count?: LembreteMaterialCountOrderByAggregateInput
    _avg?: LembreteMaterialAvgOrderByAggregateInput
    _max?: LembreteMaterialMaxOrderByAggregateInput
    _min?: LembreteMaterialMinOrderByAggregateInput
    _sum?: LembreteMaterialSumOrderByAggregateInput
  }

  export type LembreteMaterialScalarWhereWithAggregatesInput = {
    AND?: LembreteMaterialScalarWhereWithAggregatesInput | LembreteMaterialScalarWhereWithAggregatesInput[]
    OR?: LembreteMaterialScalarWhereWithAggregatesInput[]
    NOT?: LembreteMaterialScalarWhereWithAggregatesInput | LembreteMaterialScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"LembreteMaterial"> | number
    obraId?: IntWithAggregatesFilter<"LembreteMaterial"> | number
    materialId?: IntWithAggregatesFilter<"LembreteMaterial"> | number
    etapa?: EnumEtapaTipoWithAggregatesFilter<"LembreteMaterial"> | $Enums.EtapaTipo
    dataLembrete?: DateTimeWithAggregatesFilter<"LembreteMaterial"> | Date | string
    enviado?: BoolWithAggregatesFilter<"LembreteMaterial"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"LembreteMaterial"> | Date | string
  }

  export type UsuarioGerenciamentoCreateInput = {
    razaoSocial: string
    inscricaoEstadual?: string | null
    cnpj: string
    dataFundacao?: Date | string | null
    telefone?: string | null
    email: string
    endereco: string
    senhaHash: string
    role?: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    obras?: ObraCreateNestedManyWithoutGerenteInput
    usuariosExecucao?: UsuarioExecucaoCreateNestedManyWithoutEmpresaInput
  }

  export type UsuarioGerenciamentoUncheckedCreateInput = {
    id?: number
    razaoSocial: string
    inscricaoEstadual?: string | null
    cnpj: string
    dataFundacao?: Date | string | null
    telefone?: string | null
    email: string
    endereco: string
    senhaHash: string
    role?: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    obras?: ObraUncheckedCreateNestedManyWithoutGerenteInput
    usuariosExecucao?: UsuarioExecucaoUncheckedCreateNestedManyWithoutEmpresaInput
  }

  export type UsuarioGerenciamentoUpdateInput = {
    razaoSocial?: StringFieldUpdateOperationsInput | string
    inscricaoEstadual?: NullableStringFieldUpdateOperationsInput | string | null
    cnpj?: StringFieldUpdateOperationsInput | string
    dataFundacao?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    telefone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    endereco?: StringFieldUpdateOperationsInput | string
    senhaHash?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    obras?: ObraUpdateManyWithoutGerenteNestedInput
    usuariosExecucao?: UsuarioExecucaoUpdateManyWithoutEmpresaNestedInput
  }

  export type UsuarioGerenciamentoUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    razaoSocial?: StringFieldUpdateOperationsInput | string
    inscricaoEstadual?: NullableStringFieldUpdateOperationsInput | string | null
    cnpj?: StringFieldUpdateOperationsInput | string
    dataFundacao?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    telefone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    endereco?: StringFieldUpdateOperationsInput | string
    senhaHash?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    obras?: ObraUncheckedUpdateManyWithoutGerenteNestedInput
    usuariosExecucao?: UsuarioExecucaoUncheckedUpdateManyWithoutEmpresaNestedInput
  }

  export type UsuarioGerenciamentoCreateManyInput = {
    id?: number
    razaoSocial: string
    inscricaoEstadual?: string | null
    cnpj: string
    dataFundacao?: Date | string | null
    telefone?: string | null
    email: string
    endereco: string
    senhaHash: string
    role?: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UsuarioGerenciamentoUpdateManyMutationInput = {
    razaoSocial?: StringFieldUpdateOperationsInput | string
    inscricaoEstadual?: NullableStringFieldUpdateOperationsInput | string | null
    cnpj?: StringFieldUpdateOperationsInput | string
    dataFundacao?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    telefone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    endereco?: StringFieldUpdateOperationsInput | string
    senhaHash?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UsuarioGerenciamentoUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    razaoSocial?: StringFieldUpdateOperationsInput | string
    inscricaoEstadual?: NullableStringFieldUpdateOperationsInput | string | null
    cnpj?: StringFieldUpdateOperationsInput | string
    dataFundacao?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    telefone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    endereco?: StringFieldUpdateOperationsInput | string
    senhaHash?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UsuarioExecucaoCreateInput = {
    nome: string
    cpf: string
    endereco: string
    creaCau: string
    telefone?: string | null
    email: string
    dataNascimento?: Date | string | null
    senhaHash: string
    role?: $Enums.Role
    empresa: UsuarioGerenciamentoCreateNestedOneWithoutUsuariosExecucaoInput
    obrasResponsavel?: ObraCreateNestedManyWithoutResponsavelInput
  }

  export type UsuarioExecucaoUncheckedCreateInput = {
    id?: number
    nome: string
    cpf: string
    endereco: string
    creaCau: string
    telefone?: string | null
    email: string
    dataNascimento?: Date | string | null
    senhaHash: string
    role?: $Enums.Role
    empresaId: number
    obrasResponsavel?: ObraUncheckedCreateNestedManyWithoutResponsavelInput
  }

  export type UsuarioExecucaoUpdateInput = {
    nome?: StringFieldUpdateOperationsInput | string
    cpf?: StringFieldUpdateOperationsInput | string
    endereco?: StringFieldUpdateOperationsInput | string
    creaCau?: StringFieldUpdateOperationsInput | string
    telefone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    dataNascimento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    senhaHash?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    empresa?: UsuarioGerenciamentoUpdateOneRequiredWithoutUsuariosExecucaoNestedInput
    obrasResponsavel?: ObraUpdateManyWithoutResponsavelNestedInput
  }

  export type UsuarioExecucaoUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    cpf?: StringFieldUpdateOperationsInput | string
    endereco?: StringFieldUpdateOperationsInput | string
    creaCau?: StringFieldUpdateOperationsInput | string
    telefone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    dataNascimento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    senhaHash?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    empresaId?: IntFieldUpdateOperationsInput | number
    obrasResponsavel?: ObraUncheckedUpdateManyWithoutResponsavelNestedInput
  }

  export type UsuarioExecucaoCreateManyInput = {
    id?: number
    nome: string
    cpf: string
    endereco: string
    creaCau: string
    telefone?: string | null
    email: string
    dataNascimento?: Date | string | null
    senhaHash: string
    role?: $Enums.Role
    empresaId: number
  }

  export type UsuarioExecucaoUpdateManyMutationInput = {
    nome?: StringFieldUpdateOperationsInput | string
    cpf?: StringFieldUpdateOperationsInput | string
    endereco?: StringFieldUpdateOperationsInput | string
    creaCau?: StringFieldUpdateOperationsInput | string
    telefone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    dataNascimento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    senhaHash?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
  }

  export type UsuarioExecucaoUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    cpf?: StringFieldUpdateOperationsInput | string
    endereco?: StringFieldUpdateOperationsInput | string
    creaCau?: StringFieldUpdateOperationsInput | string
    telefone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    dataNascimento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    senhaHash?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    empresaId?: IntFieldUpdateOperationsInput | number
  }

  export type ObraCreateInput = {
    tipoObra: $Enums.TipoObra
    endereco: string
    creaCauResponsavel: string
    cno: string
    createdAt?: Date | string
    updatedAt?: Date | string
    gerente: UsuarioGerenciamentoCreateNestedOneWithoutObrasInput
    responsavel: UsuarioExecucaoCreateNestedOneWithoutObrasResponsavelInput
    etapas?: EtapaObraCreateNestedManyWithoutObraInput
    materiaisPedidos?: MaterialObraCreateNestedManyWithoutObraInput
    lembretes?: LembreteMaterialCreateNestedManyWithoutObraInput
  }

  export type ObraUncheckedCreateInput = {
    id?: number
    tipoObra: $Enums.TipoObra
    endereco: string
    creaCauResponsavel: string
    cno: string
    gerenteId: number
    responsavelId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    etapas?: EtapaObraUncheckedCreateNestedManyWithoutObraInput
    materiaisPedidos?: MaterialObraUncheckedCreateNestedManyWithoutObraInput
    lembretes?: LembreteMaterialUncheckedCreateNestedManyWithoutObraInput
  }

  export type ObraUpdateInput = {
    tipoObra?: EnumTipoObraFieldUpdateOperationsInput | $Enums.TipoObra
    endereco?: StringFieldUpdateOperationsInput | string
    creaCauResponsavel?: StringFieldUpdateOperationsInput | string
    cno?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    gerente?: UsuarioGerenciamentoUpdateOneRequiredWithoutObrasNestedInput
    responsavel?: UsuarioExecucaoUpdateOneRequiredWithoutObrasResponsavelNestedInput
    etapas?: EtapaObraUpdateManyWithoutObraNestedInput
    materiaisPedidos?: MaterialObraUpdateManyWithoutObraNestedInput
    lembretes?: LembreteMaterialUpdateManyWithoutObraNestedInput
  }

  export type ObraUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    tipoObra?: EnumTipoObraFieldUpdateOperationsInput | $Enums.TipoObra
    endereco?: StringFieldUpdateOperationsInput | string
    creaCauResponsavel?: StringFieldUpdateOperationsInput | string
    cno?: StringFieldUpdateOperationsInput | string
    gerenteId?: IntFieldUpdateOperationsInput | number
    responsavelId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    etapas?: EtapaObraUncheckedUpdateManyWithoutObraNestedInput
    materiaisPedidos?: MaterialObraUncheckedUpdateManyWithoutObraNestedInput
    lembretes?: LembreteMaterialUncheckedUpdateManyWithoutObraNestedInput
  }

  export type ObraCreateManyInput = {
    id?: number
    tipoObra: $Enums.TipoObra
    endereco: string
    creaCauResponsavel: string
    cno: string
    gerenteId: number
    responsavelId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ObraUpdateManyMutationInput = {
    tipoObra?: EnumTipoObraFieldUpdateOperationsInput | $Enums.TipoObra
    endereco?: StringFieldUpdateOperationsInput | string
    creaCauResponsavel?: StringFieldUpdateOperationsInput | string
    cno?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ObraUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    tipoObra?: EnumTipoObraFieldUpdateOperationsInput | $Enums.TipoObra
    endereco?: StringFieldUpdateOperationsInput | string
    creaCauResponsavel?: StringFieldUpdateOperationsInput | string
    cno?: StringFieldUpdateOperationsInput | string
    gerenteId?: IntFieldUpdateOperationsInput | number
    responsavelId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JustificativaAtrasoCreateInput = {
    tipo: $Enums.TipoJustificativa
    descricao?: string | null
    createdAt?: Date | string
    etapas?: EtapaObraCreateNestedManyWithoutJustificativaInput
  }

  export type JustificativaAtrasoUncheckedCreateInput = {
    id?: number
    tipo: $Enums.TipoJustificativa
    descricao?: string | null
    createdAt?: Date | string
    etapas?: EtapaObraUncheckedCreateNestedManyWithoutJustificativaInput
  }

  export type JustificativaAtrasoUpdateInput = {
    tipo?: EnumTipoJustificativaFieldUpdateOperationsInput | $Enums.TipoJustificativa
    descricao?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    etapas?: EtapaObraUpdateManyWithoutJustificativaNestedInput
  }

  export type JustificativaAtrasoUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    tipo?: EnumTipoJustificativaFieldUpdateOperationsInput | $Enums.TipoJustificativa
    descricao?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    etapas?: EtapaObraUncheckedUpdateManyWithoutJustificativaNestedInput
  }

  export type JustificativaAtrasoCreateManyInput = {
    id?: number
    tipo: $Enums.TipoJustificativa
    descricao?: string | null
    createdAt?: Date | string
  }

  export type JustificativaAtrasoUpdateManyMutationInput = {
    tipo?: EnumTipoJustificativaFieldUpdateOperationsInput | $Enums.TipoJustificativa
    descricao?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JustificativaAtrasoUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    tipo?: EnumTipoJustificativaFieldUpdateOperationsInput | $Enums.TipoJustificativa
    descricao?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EtapaObraCreateInput = {
    tipo: $Enums.EtapaTipo
    subEtapa?: $Enums.SubEtapaTipo | null
    status?: $Enums.StatusEtapa
    dataPrevistaInicio?: Date | string | null
    dataPrevistaFim?: Date | string | null
    dataRealInicio?: Date | string | null
    dataRealFim?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    obra: ObraCreateNestedOneWithoutEtapasInput
    justificativa?: JustificativaAtrasoCreateNestedOneWithoutEtapasInput
  }

  export type EtapaObraUncheckedCreateInput = {
    id?: number
    obraId: number
    tipo: $Enums.EtapaTipo
    subEtapa?: $Enums.SubEtapaTipo | null
    status?: $Enums.StatusEtapa
    dataPrevistaInicio?: Date | string | null
    dataPrevistaFim?: Date | string | null
    dataRealInicio?: Date | string | null
    dataRealFim?: Date | string | null
    justificativaId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EtapaObraUpdateInput = {
    tipo?: EnumEtapaTipoFieldUpdateOperationsInput | $Enums.EtapaTipo
    subEtapa?: NullableEnumSubEtapaTipoFieldUpdateOperationsInput | $Enums.SubEtapaTipo | null
    status?: EnumStatusEtapaFieldUpdateOperationsInput | $Enums.StatusEtapa
    dataPrevistaInicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dataPrevistaFim?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dataRealInicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dataRealFim?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    obra?: ObraUpdateOneRequiredWithoutEtapasNestedInput
    justificativa?: JustificativaAtrasoUpdateOneWithoutEtapasNestedInput
  }

  export type EtapaObraUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    obraId?: IntFieldUpdateOperationsInput | number
    tipo?: EnumEtapaTipoFieldUpdateOperationsInput | $Enums.EtapaTipo
    subEtapa?: NullableEnumSubEtapaTipoFieldUpdateOperationsInput | $Enums.SubEtapaTipo | null
    status?: EnumStatusEtapaFieldUpdateOperationsInput | $Enums.StatusEtapa
    dataPrevistaInicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dataPrevistaFim?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dataRealInicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dataRealFim?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    justificativaId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EtapaObraCreateManyInput = {
    id?: number
    obraId: number
    tipo: $Enums.EtapaTipo
    subEtapa?: $Enums.SubEtapaTipo | null
    status?: $Enums.StatusEtapa
    dataPrevistaInicio?: Date | string | null
    dataPrevistaFim?: Date | string | null
    dataRealInicio?: Date | string | null
    dataRealFim?: Date | string | null
    justificativaId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EtapaObraUpdateManyMutationInput = {
    tipo?: EnumEtapaTipoFieldUpdateOperationsInput | $Enums.EtapaTipo
    subEtapa?: NullableEnumSubEtapaTipoFieldUpdateOperationsInput | $Enums.SubEtapaTipo | null
    status?: EnumStatusEtapaFieldUpdateOperationsInput | $Enums.StatusEtapa
    dataPrevistaInicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dataPrevistaFim?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dataRealInicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dataRealFim?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EtapaObraUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    obraId?: IntFieldUpdateOperationsInput | number
    tipo?: EnumEtapaTipoFieldUpdateOperationsInput | $Enums.EtapaTipo
    subEtapa?: NullableEnumSubEtapaTipoFieldUpdateOperationsInput | $Enums.SubEtapaTipo | null
    status?: EnumStatusEtapaFieldUpdateOperationsInput | $Enums.StatusEtapa
    dataPrevistaInicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dataPrevistaFim?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dataRealInicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dataRealFim?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    justificativaId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MaterialCreateInput = {
    nome: string
    etapaDefault?: $Enums.EtapaTipo | null
    unidade: string
    itens?: MaterialObraCreateNestedManyWithoutMaterialInput
    lembretes?: LembreteMaterialCreateNestedManyWithoutMaterialInput
  }

  export type MaterialUncheckedCreateInput = {
    id?: number
    nome: string
    etapaDefault?: $Enums.EtapaTipo | null
    unidade: string
    itens?: MaterialObraUncheckedCreateNestedManyWithoutMaterialInput
    lembretes?: LembreteMaterialUncheckedCreateNestedManyWithoutMaterialInput
  }

  export type MaterialUpdateInput = {
    nome?: StringFieldUpdateOperationsInput | string
    etapaDefault?: NullableEnumEtapaTipoFieldUpdateOperationsInput | $Enums.EtapaTipo | null
    unidade?: StringFieldUpdateOperationsInput | string
    itens?: MaterialObraUpdateManyWithoutMaterialNestedInput
    lembretes?: LembreteMaterialUpdateManyWithoutMaterialNestedInput
  }

  export type MaterialUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    etapaDefault?: NullableEnumEtapaTipoFieldUpdateOperationsInput | $Enums.EtapaTipo | null
    unidade?: StringFieldUpdateOperationsInput | string
    itens?: MaterialObraUncheckedUpdateManyWithoutMaterialNestedInput
    lembretes?: LembreteMaterialUncheckedUpdateManyWithoutMaterialNestedInput
  }

  export type MaterialCreateManyInput = {
    id?: number
    nome: string
    etapaDefault?: $Enums.EtapaTipo | null
    unidade: string
  }

  export type MaterialUpdateManyMutationInput = {
    nome?: StringFieldUpdateOperationsInput | string
    etapaDefault?: NullableEnumEtapaTipoFieldUpdateOperationsInput | $Enums.EtapaTipo | null
    unidade?: StringFieldUpdateOperationsInput | string
  }

  export type MaterialUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    etapaDefault?: NullableEnumEtapaTipoFieldUpdateOperationsInput | $Enums.EtapaTipo | null
    unidade?: StringFieldUpdateOperationsInput | string
  }

  export type MaterialObraCreateInput = {
    etapa: $Enums.EtapaTipo
    quantidade: number
    statusPedido?: $Enums.StatusPedido
    dataPedido?: Date | string | null
    dataEntrega?: Date | string | null
    obra: ObraCreateNestedOneWithoutMateriaisPedidosInput
    material: MaterialCreateNestedOneWithoutItensInput
  }

  export type MaterialObraUncheckedCreateInput = {
    id?: number
    obraId: number
    materialId: number
    etapa: $Enums.EtapaTipo
    quantidade: number
    statusPedido?: $Enums.StatusPedido
    dataPedido?: Date | string | null
    dataEntrega?: Date | string | null
  }

  export type MaterialObraUpdateInput = {
    etapa?: EnumEtapaTipoFieldUpdateOperationsInput | $Enums.EtapaTipo
    quantidade?: FloatFieldUpdateOperationsInput | number
    statusPedido?: EnumStatusPedidoFieldUpdateOperationsInput | $Enums.StatusPedido
    dataPedido?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dataEntrega?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    obra?: ObraUpdateOneRequiredWithoutMateriaisPedidosNestedInput
    material?: MaterialUpdateOneRequiredWithoutItensNestedInput
  }

  export type MaterialObraUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    obraId?: IntFieldUpdateOperationsInput | number
    materialId?: IntFieldUpdateOperationsInput | number
    etapa?: EnumEtapaTipoFieldUpdateOperationsInput | $Enums.EtapaTipo
    quantidade?: FloatFieldUpdateOperationsInput | number
    statusPedido?: EnumStatusPedidoFieldUpdateOperationsInput | $Enums.StatusPedido
    dataPedido?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dataEntrega?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MaterialObraCreateManyInput = {
    id?: number
    obraId: number
    materialId: number
    etapa: $Enums.EtapaTipo
    quantidade: number
    statusPedido?: $Enums.StatusPedido
    dataPedido?: Date | string | null
    dataEntrega?: Date | string | null
  }

  export type MaterialObraUpdateManyMutationInput = {
    etapa?: EnumEtapaTipoFieldUpdateOperationsInput | $Enums.EtapaTipo
    quantidade?: FloatFieldUpdateOperationsInput | number
    statusPedido?: EnumStatusPedidoFieldUpdateOperationsInput | $Enums.StatusPedido
    dataPedido?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dataEntrega?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MaterialObraUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    obraId?: IntFieldUpdateOperationsInput | number
    materialId?: IntFieldUpdateOperationsInput | number
    etapa?: EnumEtapaTipoFieldUpdateOperationsInput | $Enums.EtapaTipo
    quantidade?: FloatFieldUpdateOperationsInput | number
    statusPedido?: EnumStatusPedidoFieldUpdateOperationsInput | $Enums.StatusPedido
    dataPedido?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dataEntrega?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type LembreteMaterialCreateInput = {
    etapa: $Enums.EtapaTipo
    dataLembrete: Date | string
    enviado?: boolean
    createdAt?: Date | string
    obra: ObraCreateNestedOneWithoutLembretesInput
    material: MaterialCreateNestedOneWithoutLembretesInput
  }

  export type LembreteMaterialUncheckedCreateInput = {
    id?: number
    obraId: number
    materialId: number
    etapa: $Enums.EtapaTipo
    dataLembrete: Date | string
    enviado?: boolean
    createdAt?: Date | string
  }

  export type LembreteMaterialUpdateInput = {
    etapa?: EnumEtapaTipoFieldUpdateOperationsInput | $Enums.EtapaTipo
    dataLembrete?: DateTimeFieldUpdateOperationsInput | Date | string
    enviado?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    obra?: ObraUpdateOneRequiredWithoutLembretesNestedInput
    material?: MaterialUpdateOneRequiredWithoutLembretesNestedInput
  }

  export type LembreteMaterialUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    obraId?: IntFieldUpdateOperationsInput | number
    materialId?: IntFieldUpdateOperationsInput | number
    etapa?: EnumEtapaTipoFieldUpdateOperationsInput | $Enums.EtapaTipo
    dataLembrete?: DateTimeFieldUpdateOperationsInput | Date | string
    enviado?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LembreteMaterialCreateManyInput = {
    id?: number
    obraId: number
    materialId: number
    etapa: $Enums.EtapaTipo
    dataLembrete: Date | string
    enviado?: boolean
    createdAt?: Date | string
  }

  export type LembreteMaterialUpdateManyMutationInput = {
    etapa?: EnumEtapaTipoFieldUpdateOperationsInput | $Enums.EtapaTipo
    dataLembrete?: DateTimeFieldUpdateOperationsInput | Date | string
    enviado?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LembreteMaterialUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    obraId?: IntFieldUpdateOperationsInput | number
    materialId?: IntFieldUpdateOperationsInput | number
    etapa?: EnumEtapaTipoFieldUpdateOperationsInput | $Enums.EtapaTipo
    dataLembrete?: DateTimeFieldUpdateOperationsInput | Date | string
    enviado?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type EnumRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleFilter<$PrismaModel> | $Enums.Role
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type ObraListRelationFilter = {
    every?: ObraWhereInput
    some?: ObraWhereInput
    none?: ObraWhereInput
  }

  export type UsuarioExecucaoListRelationFilter = {
    every?: UsuarioExecucaoWhereInput
    some?: UsuarioExecucaoWhereInput
    none?: UsuarioExecucaoWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type ObraOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UsuarioExecucaoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UsuarioGerenciamentoCountOrderByAggregateInput = {
    id?: SortOrder
    razaoSocial?: SortOrder
    inscricaoEstadual?: SortOrder
    cnpj?: SortOrder
    dataFundacao?: SortOrder
    telefone?: SortOrder
    email?: SortOrder
    endereco?: SortOrder
    senhaHash?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UsuarioGerenciamentoAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type UsuarioGerenciamentoMaxOrderByAggregateInput = {
    id?: SortOrder
    razaoSocial?: SortOrder
    inscricaoEstadual?: SortOrder
    cnpj?: SortOrder
    dataFundacao?: SortOrder
    telefone?: SortOrder
    email?: SortOrder
    endereco?: SortOrder
    senhaHash?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UsuarioGerenciamentoMinOrderByAggregateInput = {
    id?: SortOrder
    razaoSocial?: SortOrder
    inscricaoEstadual?: SortOrder
    cnpj?: SortOrder
    dataFundacao?: SortOrder
    telefone?: SortOrder
    email?: SortOrder
    endereco?: SortOrder
    senhaHash?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UsuarioGerenciamentoSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type EnumRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleWithAggregatesFilter<$PrismaModel> | $Enums.Role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleFilter<$PrismaModel>
    _max?: NestedEnumRoleFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type UsuarioGerenciamentoRelationFilter = {
    is?: UsuarioGerenciamentoWhereInput
    isNot?: UsuarioGerenciamentoWhereInput
  }

  export type UsuarioExecucaoCountOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    cpf?: SortOrder
    endereco?: SortOrder
    creaCau?: SortOrder
    telefone?: SortOrder
    email?: SortOrder
    dataNascimento?: SortOrder
    senhaHash?: SortOrder
    role?: SortOrder
    empresaId?: SortOrder
  }

  export type UsuarioExecucaoAvgOrderByAggregateInput = {
    id?: SortOrder
    empresaId?: SortOrder
  }

  export type UsuarioExecucaoMaxOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    cpf?: SortOrder
    endereco?: SortOrder
    creaCau?: SortOrder
    telefone?: SortOrder
    email?: SortOrder
    dataNascimento?: SortOrder
    senhaHash?: SortOrder
    role?: SortOrder
    empresaId?: SortOrder
  }

  export type UsuarioExecucaoMinOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    cpf?: SortOrder
    endereco?: SortOrder
    creaCau?: SortOrder
    telefone?: SortOrder
    email?: SortOrder
    dataNascimento?: SortOrder
    senhaHash?: SortOrder
    role?: SortOrder
    empresaId?: SortOrder
  }

  export type UsuarioExecucaoSumOrderByAggregateInput = {
    id?: SortOrder
    empresaId?: SortOrder
  }

  export type EnumTipoObraFilter<$PrismaModel = never> = {
    equals?: $Enums.TipoObra | EnumTipoObraFieldRefInput<$PrismaModel>
    in?: $Enums.TipoObra[] | ListEnumTipoObraFieldRefInput<$PrismaModel>
    notIn?: $Enums.TipoObra[] | ListEnumTipoObraFieldRefInput<$PrismaModel>
    not?: NestedEnumTipoObraFilter<$PrismaModel> | $Enums.TipoObra
  }

  export type UsuarioExecucaoRelationFilter = {
    is?: UsuarioExecucaoWhereInput
    isNot?: UsuarioExecucaoWhereInput
  }

  export type EtapaObraListRelationFilter = {
    every?: EtapaObraWhereInput
    some?: EtapaObraWhereInput
    none?: EtapaObraWhereInput
  }

  export type MaterialObraListRelationFilter = {
    every?: MaterialObraWhereInput
    some?: MaterialObraWhereInput
    none?: MaterialObraWhereInput
  }

  export type LembreteMaterialListRelationFilter = {
    every?: LembreteMaterialWhereInput
    some?: LembreteMaterialWhereInput
    none?: LembreteMaterialWhereInput
  }

  export type EtapaObraOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MaterialObraOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LembreteMaterialOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ObraCountOrderByAggregateInput = {
    id?: SortOrder
    tipoObra?: SortOrder
    endereco?: SortOrder
    creaCauResponsavel?: SortOrder
    cno?: SortOrder
    gerenteId?: SortOrder
    responsavelId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ObraAvgOrderByAggregateInput = {
    id?: SortOrder
    gerenteId?: SortOrder
    responsavelId?: SortOrder
  }

  export type ObraMaxOrderByAggregateInput = {
    id?: SortOrder
    tipoObra?: SortOrder
    endereco?: SortOrder
    creaCauResponsavel?: SortOrder
    cno?: SortOrder
    gerenteId?: SortOrder
    responsavelId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ObraMinOrderByAggregateInput = {
    id?: SortOrder
    tipoObra?: SortOrder
    endereco?: SortOrder
    creaCauResponsavel?: SortOrder
    cno?: SortOrder
    gerenteId?: SortOrder
    responsavelId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ObraSumOrderByAggregateInput = {
    id?: SortOrder
    gerenteId?: SortOrder
    responsavelId?: SortOrder
  }

  export type EnumTipoObraWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TipoObra | EnumTipoObraFieldRefInput<$PrismaModel>
    in?: $Enums.TipoObra[] | ListEnumTipoObraFieldRefInput<$PrismaModel>
    notIn?: $Enums.TipoObra[] | ListEnumTipoObraFieldRefInput<$PrismaModel>
    not?: NestedEnumTipoObraWithAggregatesFilter<$PrismaModel> | $Enums.TipoObra
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTipoObraFilter<$PrismaModel>
    _max?: NestedEnumTipoObraFilter<$PrismaModel>
  }

  export type EnumTipoJustificativaFilter<$PrismaModel = never> = {
    equals?: $Enums.TipoJustificativa | EnumTipoJustificativaFieldRefInput<$PrismaModel>
    in?: $Enums.TipoJustificativa[] | ListEnumTipoJustificativaFieldRefInput<$PrismaModel>
    notIn?: $Enums.TipoJustificativa[] | ListEnumTipoJustificativaFieldRefInput<$PrismaModel>
    not?: NestedEnumTipoJustificativaFilter<$PrismaModel> | $Enums.TipoJustificativa
  }

  export type JustificativaAtrasoCountOrderByAggregateInput = {
    id?: SortOrder
    tipo?: SortOrder
    descricao?: SortOrder
    createdAt?: SortOrder
  }

  export type JustificativaAtrasoAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type JustificativaAtrasoMaxOrderByAggregateInput = {
    id?: SortOrder
    tipo?: SortOrder
    descricao?: SortOrder
    createdAt?: SortOrder
  }

  export type JustificativaAtrasoMinOrderByAggregateInput = {
    id?: SortOrder
    tipo?: SortOrder
    descricao?: SortOrder
    createdAt?: SortOrder
  }

  export type JustificativaAtrasoSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EnumTipoJustificativaWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TipoJustificativa | EnumTipoJustificativaFieldRefInput<$PrismaModel>
    in?: $Enums.TipoJustificativa[] | ListEnumTipoJustificativaFieldRefInput<$PrismaModel>
    notIn?: $Enums.TipoJustificativa[] | ListEnumTipoJustificativaFieldRefInput<$PrismaModel>
    not?: NestedEnumTipoJustificativaWithAggregatesFilter<$PrismaModel> | $Enums.TipoJustificativa
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTipoJustificativaFilter<$PrismaModel>
    _max?: NestedEnumTipoJustificativaFilter<$PrismaModel>
  }

  export type EnumEtapaTipoFilter<$PrismaModel = never> = {
    equals?: $Enums.EtapaTipo | EnumEtapaTipoFieldRefInput<$PrismaModel>
    in?: $Enums.EtapaTipo[] | ListEnumEtapaTipoFieldRefInput<$PrismaModel>
    notIn?: $Enums.EtapaTipo[] | ListEnumEtapaTipoFieldRefInput<$PrismaModel>
    not?: NestedEnumEtapaTipoFilter<$PrismaModel> | $Enums.EtapaTipo
  }

  export type EnumSubEtapaTipoNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.SubEtapaTipo | EnumSubEtapaTipoFieldRefInput<$PrismaModel> | null
    in?: $Enums.SubEtapaTipo[] | ListEnumSubEtapaTipoFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.SubEtapaTipo[] | ListEnumSubEtapaTipoFieldRefInput<$PrismaModel> | null
    not?: NestedEnumSubEtapaTipoNullableFilter<$PrismaModel> | $Enums.SubEtapaTipo | null
  }

  export type EnumStatusEtapaFilter<$PrismaModel = never> = {
    equals?: $Enums.StatusEtapa | EnumStatusEtapaFieldRefInput<$PrismaModel>
    in?: $Enums.StatusEtapa[] | ListEnumStatusEtapaFieldRefInput<$PrismaModel>
    notIn?: $Enums.StatusEtapa[] | ListEnumStatusEtapaFieldRefInput<$PrismaModel>
    not?: NestedEnumStatusEtapaFilter<$PrismaModel> | $Enums.StatusEtapa
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type ObraRelationFilter = {
    is?: ObraWhereInput
    isNot?: ObraWhereInput
  }

  export type JustificativaAtrasoNullableRelationFilter = {
    is?: JustificativaAtrasoWhereInput | null
    isNot?: JustificativaAtrasoWhereInput | null
  }

  export type EtapaObraCountOrderByAggregateInput = {
    id?: SortOrder
    obraId?: SortOrder
    tipo?: SortOrder
    subEtapa?: SortOrder
    status?: SortOrder
    dataPrevistaInicio?: SortOrder
    dataPrevistaFim?: SortOrder
    dataRealInicio?: SortOrder
    dataRealFim?: SortOrder
    justificativaId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EtapaObraAvgOrderByAggregateInput = {
    id?: SortOrder
    obraId?: SortOrder
    justificativaId?: SortOrder
  }

  export type EtapaObraMaxOrderByAggregateInput = {
    id?: SortOrder
    obraId?: SortOrder
    tipo?: SortOrder
    subEtapa?: SortOrder
    status?: SortOrder
    dataPrevistaInicio?: SortOrder
    dataPrevistaFim?: SortOrder
    dataRealInicio?: SortOrder
    dataRealFim?: SortOrder
    justificativaId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EtapaObraMinOrderByAggregateInput = {
    id?: SortOrder
    obraId?: SortOrder
    tipo?: SortOrder
    subEtapa?: SortOrder
    status?: SortOrder
    dataPrevistaInicio?: SortOrder
    dataPrevistaFim?: SortOrder
    dataRealInicio?: SortOrder
    dataRealFim?: SortOrder
    justificativaId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EtapaObraSumOrderByAggregateInput = {
    id?: SortOrder
    obraId?: SortOrder
    justificativaId?: SortOrder
  }

  export type EnumEtapaTipoWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EtapaTipo | EnumEtapaTipoFieldRefInput<$PrismaModel>
    in?: $Enums.EtapaTipo[] | ListEnumEtapaTipoFieldRefInput<$PrismaModel>
    notIn?: $Enums.EtapaTipo[] | ListEnumEtapaTipoFieldRefInput<$PrismaModel>
    not?: NestedEnumEtapaTipoWithAggregatesFilter<$PrismaModel> | $Enums.EtapaTipo
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEtapaTipoFilter<$PrismaModel>
    _max?: NestedEnumEtapaTipoFilter<$PrismaModel>
  }

  export type EnumSubEtapaTipoNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SubEtapaTipo | EnumSubEtapaTipoFieldRefInput<$PrismaModel> | null
    in?: $Enums.SubEtapaTipo[] | ListEnumSubEtapaTipoFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.SubEtapaTipo[] | ListEnumSubEtapaTipoFieldRefInput<$PrismaModel> | null
    not?: NestedEnumSubEtapaTipoNullableWithAggregatesFilter<$PrismaModel> | $Enums.SubEtapaTipo | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumSubEtapaTipoNullableFilter<$PrismaModel>
    _max?: NestedEnumSubEtapaTipoNullableFilter<$PrismaModel>
  }

  export type EnumStatusEtapaWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.StatusEtapa | EnumStatusEtapaFieldRefInput<$PrismaModel>
    in?: $Enums.StatusEtapa[] | ListEnumStatusEtapaFieldRefInput<$PrismaModel>
    notIn?: $Enums.StatusEtapa[] | ListEnumStatusEtapaFieldRefInput<$PrismaModel>
    not?: NestedEnumStatusEtapaWithAggregatesFilter<$PrismaModel> | $Enums.StatusEtapa
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStatusEtapaFilter<$PrismaModel>
    _max?: NestedEnumStatusEtapaFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type EnumEtapaTipoNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.EtapaTipo | EnumEtapaTipoFieldRefInput<$PrismaModel> | null
    in?: $Enums.EtapaTipo[] | ListEnumEtapaTipoFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.EtapaTipo[] | ListEnumEtapaTipoFieldRefInput<$PrismaModel> | null
    not?: NestedEnumEtapaTipoNullableFilter<$PrismaModel> | $Enums.EtapaTipo | null
  }

  export type MaterialCountOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    etapaDefault?: SortOrder
    unidade?: SortOrder
  }

  export type MaterialAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type MaterialMaxOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    etapaDefault?: SortOrder
    unidade?: SortOrder
  }

  export type MaterialMinOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    etapaDefault?: SortOrder
    unidade?: SortOrder
  }

  export type MaterialSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EnumEtapaTipoNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EtapaTipo | EnumEtapaTipoFieldRefInput<$PrismaModel> | null
    in?: $Enums.EtapaTipo[] | ListEnumEtapaTipoFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.EtapaTipo[] | ListEnumEtapaTipoFieldRefInput<$PrismaModel> | null
    not?: NestedEnumEtapaTipoNullableWithAggregatesFilter<$PrismaModel> | $Enums.EtapaTipo | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumEtapaTipoNullableFilter<$PrismaModel>
    _max?: NestedEnumEtapaTipoNullableFilter<$PrismaModel>
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type EnumStatusPedidoFilter<$PrismaModel = never> = {
    equals?: $Enums.StatusPedido | EnumStatusPedidoFieldRefInput<$PrismaModel>
    in?: $Enums.StatusPedido[] | ListEnumStatusPedidoFieldRefInput<$PrismaModel>
    notIn?: $Enums.StatusPedido[] | ListEnumStatusPedidoFieldRefInput<$PrismaModel>
    not?: NestedEnumStatusPedidoFilter<$PrismaModel> | $Enums.StatusPedido
  }

  export type MaterialRelationFilter = {
    is?: MaterialWhereInput
    isNot?: MaterialWhereInput
  }

  export type MaterialObraCountOrderByAggregateInput = {
    id?: SortOrder
    obraId?: SortOrder
    materialId?: SortOrder
    etapa?: SortOrder
    quantidade?: SortOrder
    statusPedido?: SortOrder
    dataPedido?: SortOrder
    dataEntrega?: SortOrder
  }

  export type MaterialObraAvgOrderByAggregateInput = {
    id?: SortOrder
    obraId?: SortOrder
    materialId?: SortOrder
    quantidade?: SortOrder
  }

  export type MaterialObraMaxOrderByAggregateInput = {
    id?: SortOrder
    obraId?: SortOrder
    materialId?: SortOrder
    etapa?: SortOrder
    quantidade?: SortOrder
    statusPedido?: SortOrder
    dataPedido?: SortOrder
    dataEntrega?: SortOrder
  }

  export type MaterialObraMinOrderByAggregateInput = {
    id?: SortOrder
    obraId?: SortOrder
    materialId?: SortOrder
    etapa?: SortOrder
    quantidade?: SortOrder
    statusPedido?: SortOrder
    dataPedido?: SortOrder
    dataEntrega?: SortOrder
  }

  export type MaterialObraSumOrderByAggregateInput = {
    id?: SortOrder
    obraId?: SortOrder
    materialId?: SortOrder
    quantidade?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type EnumStatusPedidoWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.StatusPedido | EnumStatusPedidoFieldRefInput<$PrismaModel>
    in?: $Enums.StatusPedido[] | ListEnumStatusPedidoFieldRefInput<$PrismaModel>
    notIn?: $Enums.StatusPedido[] | ListEnumStatusPedidoFieldRefInput<$PrismaModel>
    not?: NestedEnumStatusPedidoWithAggregatesFilter<$PrismaModel> | $Enums.StatusPedido
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStatusPedidoFilter<$PrismaModel>
    _max?: NestedEnumStatusPedidoFilter<$PrismaModel>
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type LembreteMaterialCountOrderByAggregateInput = {
    id?: SortOrder
    obraId?: SortOrder
    materialId?: SortOrder
    etapa?: SortOrder
    dataLembrete?: SortOrder
    enviado?: SortOrder
    createdAt?: SortOrder
  }

  export type LembreteMaterialAvgOrderByAggregateInput = {
    id?: SortOrder
    obraId?: SortOrder
    materialId?: SortOrder
  }

  export type LembreteMaterialMaxOrderByAggregateInput = {
    id?: SortOrder
    obraId?: SortOrder
    materialId?: SortOrder
    etapa?: SortOrder
    dataLembrete?: SortOrder
    enviado?: SortOrder
    createdAt?: SortOrder
  }

  export type LembreteMaterialMinOrderByAggregateInput = {
    id?: SortOrder
    obraId?: SortOrder
    materialId?: SortOrder
    etapa?: SortOrder
    dataLembrete?: SortOrder
    enviado?: SortOrder
    createdAt?: SortOrder
  }

  export type LembreteMaterialSumOrderByAggregateInput = {
    id?: SortOrder
    obraId?: SortOrder
    materialId?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type ObraCreateNestedManyWithoutGerenteInput = {
    create?: XOR<ObraCreateWithoutGerenteInput, ObraUncheckedCreateWithoutGerenteInput> | ObraCreateWithoutGerenteInput[] | ObraUncheckedCreateWithoutGerenteInput[]
    connectOrCreate?: ObraCreateOrConnectWithoutGerenteInput | ObraCreateOrConnectWithoutGerenteInput[]
    createMany?: ObraCreateManyGerenteInputEnvelope
    connect?: ObraWhereUniqueInput | ObraWhereUniqueInput[]
  }

  export type UsuarioExecucaoCreateNestedManyWithoutEmpresaInput = {
    create?: XOR<UsuarioExecucaoCreateWithoutEmpresaInput, UsuarioExecucaoUncheckedCreateWithoutEmpresaInput> | UsuarioExecucaoCreateWithoutEmpresaInput[] | UsuarioExecucaoUncheckedCreateWithoutEmpresaInput[]
    connectOrCreate?: UsuarioExecucaoCreateOrConnectWithoutEmpresaInput | UsuarioExecucaoCreateOrConnectWithoutEmpresaInput[]
    createMany?: UsuarioExecucaoCreateManyEmpresaInputEnvelope
    connect?: UsuarioExecucaoWhereUniqueInput | UsuarioExecucaoWhereUniqueInput[]
  }

  export type ObraUncheckedCreateNestedManyWithoutGerenteInput = {
    create?: XOR<ObraCreateWithoutGerenteInput, ObraUncheckedCreateWithoutGerenteInput> | ObraCreateWithoutGerenteInput[] | ObraUncheckedCreateWithoutGerenteInput[]
    connectOrCreate?: ObraCreateOrConnectWithoutGerenteInput | ObraCreateOrConnectWithoutGerenteInput[]
    createMany?: ObraCreateManyGerenteInputEnvelope
    connect?: ObraWhereUniqueInput | ObraWhereUniqueInput[]
  }

  export type UsuarioExecucaoUncheckedCreateNestedManyWithoutEmpresaInput = {
    create?: XOR<UsuarioExecucaoCreateWithoutEmpresaInput, UsuarioExecucaoUncheckedCreateWithoutEmpresaInput> | UsuarioExecucaoCreateWithoutEmpresaInput[] | UsuarioExecucaoUncheckedCreateWithoutEmpresaInput[]
    connectOrCreate?: UsuarioExecucaoCreateOrConnectWithoutEmpresaInput | UsuarioExecucaoCreateOrConnectWithoutEmpresaInput[]
    createMany?: UsuarioExecucaoCreateManyEmpresaInputEnvelope
    connect?: UsuarioExecucaoWhereUniqueInput | UsuarioExecucaoWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type EnumRoleFieldUpdateOperationsInput = {
    set?: $Enums.Role
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type ObraUpdateManyWithoutGerenteNestedInput = {
    create?: XOR<ObraCreateWithoutGerenteInput, ObraUncheckedCreateWithoutGerenteInput> | ObraCreateWithoutGerenteInput[] | ObraUncheckedCreateWithoutGerenteInput[]
    connectOrCreate?: ObraCreateOrConnectWithoutGerenteInput | ObraCreateOrConnectWithoutGerenteInput[]
    upsert?: ObraUpsertWithWhereUniqueWithoutGerenteInput | ObraUpsertWithWhereUniqueWithoutGerenteInput[]
    createMany?: ObraCreateManyGerenteInputEnvelope
    set?: ObraWhereUniqueInput | ObraWhereUniqueInput[]
    disconnect?: ObraWhereUniqueInput | ObraWhereUniqueInput[]
    delete?: ObraWhereUniqueInput | ObraWhereUniqueInput[]
    connect?: ObraWhereUniqueInput | ObraWhereUniqueInput[]
    update?: ObraUpdateWithWhereUniqueWithoutGerenteInput | ObraUpdateWithWhereUniqueWithoutGerenteInput[]
    updateMany?: ObraUpdateManyWithWhereWithoutGerenteInput | ObraUpdateManyWithWhereWithoutGerenteInput[]
    deleteMany?: ObraScalarWhereInput | ObraScalarWhereInput[]
  }

  export type UsuarioExecucaoUpdateManyWithoutEmpresaNestedInput = {
    create?: XOR<UsuarioExecucaoCreateWithoutEmpresaInput, UsuarioExecucaoUncheckedCreateWithoutEmpresaInput> | UsuarioExecucaoCreateWithoutEmpresaInput[] | UsuarioExecucaoUncheckedCreateWithoutEmpresaInput[]
    connectOrCreate?: UsuarioExecucaoCreateOrConnectWithoutEmpresaInput | UsuarioExecucaoCreateOrConnectWithoutEmpresaInput[]
    upsert?: UsuarioExecucaoUpsertWithWhereUniqueWithoutEmpresaInput | UsuarioExecucaoUpsertWithWhereUniqueWithoutEmpresaInput[]
    createMany?: UsuarioExecucaoCreateManyEmpresaInputEnvelope
    set?: UsuarioExecucaoWhereUniqueInput | UsuarioExecucaoWhereUniqueInput[]
    disconnect?: UsuarioExecucaoWhereUniqueInput | UsuarioExecucaoWhereUniqueInput[]
    delete?: UsuarioExecucaoWhereUniqueInput | UsuarioExecucaoWhereUniqueInput[]
    connect?: UsuarioExecucaoWhereUniqueInput | UsuarioExecucaoWhereUniqueInput[]
    update?: UsuarioExecucaoUpdateWithWhereUniqueWithoutEmpresaInput | UsuarioExecucaoUpdateWithWhereUniqueWithoutEmpresaInput[]
    updateMany?: UsuarioExecucaoUpdateManyWithWhereWithoutEmpresaInput | UsuarioExecucaoUpdateManyWithWhereWithoutEmpresaInput[]
    deleteMany?: UsuarioExecucaoScalarWhereInput | UsuarioExecucaoScalarWhereInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type ObraUncheckedUpdateManyWithoutGerenteNestedInput = {
    create?: XOR<ObraCreateWithoutGerenteInput, ObraUncheckedCreateWithoutGerenteInput> | ObraCreateWithoutGerenteInput[] | ObraUncheckedCreateWithoutGerenteInput[]
    connectOrCreate?: ObraCreateOrConnectWithoutGerenteInput | ObraCreateOrConnectWithoutGerenteInput[]
    upsert?: ObraUpsertWithWhereUniqueWithoutGerenteInput | ObraUpsertWithWhereUniqueWithoutGerenteInput[]
    createMany?: ObraCreateManyGerenteInputEnvelope
    set?: ObraWhereUniqueInput | ObraWhereUniqueInput[]
    disconnect?: ObraWhereUniqueInput | ObraWhereUniqueInput[]
    delete?: ObraWhereUniqueInput | ObraWhereUniqueInput[]
    connect?: ObraWhereUniqueInput | ObraWhereUniqueInput[]
    update?: ObraUpdateWithWhereUniqueWithoutGerenteInput | ObraUpdateWithWhereUniqueWithoutGerenteInput[]
    updateMany?: ObraUpdateManyWithWhereWithoutGerenteInput | ObraUpdateManyWithWhereWithoutGerenteInput[]
    deleteMany?: ObraScalarWhereInput | ObraScalarWhereInput[]
  }

  export type UsuarioExecucaoUncheckedUpdateManyWithoutEmpresaNestedInput = {
    create?: XOR<UsuarioExecucaoCreateWithoutEmpresaInput, UsuarioExecucaoUncheckedCreateWithoutEmpresaInput> | UsuarioExecucaoCreateWithoutEmpresaInput[] | UsuarioExecucaoUncheckedCreateWithoutEmpresaInput[]
    connectOrCreate?: UsuarioExecucaoCreateOrConnectWithoutEmpresaInput | UsuarioExecucaoCreateOrConnectWithoutEmpresaInput[]
    upsert?: UsuarioExecucaoUpsertWithWhereUniqueWithoutEmpresaInput | UsuarioExecucaoUpsertWithWhereUniqueWithoutEmpresaInput[]
    createMany?: UsuarioExecucaoCreateManyEmpresaInputEnvelope
    set?: UsuarioExecucaoWhereUniqueInput | UsuarioExecucaoWhereUniqueInput[]
    disconnect?: UsuarioExecucaoWhereUniqueInput | UsuarioExecucaoWhereUniqueInput[]
    delete?: UsuarioExecucaoWhereUniqueInput | UsuarioExecucaoWhereUniqueInput[]
    connect?: UsuarioExecucaoWhereUniqueInput | UsuarioExecucaoWhereUniqueInput[]
    update?: UsuarioExecucaoUpdateWithWhereUniqueWithoutEmpresaInput | UsuarioExecucaoUpdateWithWhereUniqueWithoutEmpresaInput[]
    updateMany?: UsuarioExecucaoUpdateManyWithWhereWithoutEmpresaInput | UsuarioExecucaoUpdateManyWithWhereWithoutEmpresaInput[]
    deleteMany?: UsuarioExecucaoScalarWhereInput | UsuarioExecucaoScalarWhereInput[]
  }

  export type UsuarioGerenciamentoCreateNestedOneWithoutUsuariosExecucaoInput = {
    create?: XOR<UsuarioGerenciamentoCreateWithoutUsuariosExecucaoInput, UsuarioGerenciamentoUncheckedCreateWithoutUsuariosExecucaoInput>
    connectOrCreate?: UsuarioGerenciamentoCreateOrConnectWithoutUsuariosExecucaoInput
    connect?: UsuarioGerenciamentoWhereUniqueInput
  }

  export type ObraCreateNestedManyWithoutResponsavelInput = {
    create?: XOR<ObraCreateWithoutResponsavelInput, ObraUncheckedCreateWithoutResponsavelInput> | ObraCreateWithoutResponsavelInput[] | ObraUncheckedCreateWithoutResponsavelInput[]
    connectOrCreate?: ObraCreateOrConnectWithoutResponsavelInput | ObraCreateOrConnectWithoutResponsavelInput[]
    createMany?: ObraCreateManyResponsavelInputEnvelope
    connect?: ObraWhereUniqueInput | ObraWhereUniqueInput[]
  }

  export type ObraUncheckedCreateNestedManyWithoutResponsavelInput = {
    create?: XOR<ObraCreateWithoutResponsavelInput, ObraUncheckedCreateWithoutResponsavelInput> | ObraCreateWithoutResponsavelInput[] | ObraUncheckedCreateWithoutResponsavelInput[]
    connectOrCreate?: ObraCreateOrConnectWithoutResponsavelInput | ObraCreateOrConnectWithoutResponsavelInput[]
    createMany?: ObraCreateManyResponsavelInputEnvelope
    connect?: ObraWhereUniqueInput | ObraWhereUniqueInput[]
  }

  export type UsuarioGerenciamentoUpdateOneRequiredWithoutUsuariosExecucaoNestedInput = {
    create?: XOR<UsuarioGerenciamentoCreateWithoutUsuariosExecucaoInput, UsuarioGerenciamentoUncheckedCreateWithoutUsuariosExecucaoInput>
    connectOrCreate?: UsuarioGerenciamentoCreateOrConnectWithoutUsuariosExecucaoInput
    upsert?: UsuarioGerenciamentoUpsertWithoutUsuariosExecucaoInput
    connect?: UsuarioGerenciamentoWhereUniqueInput
    update?: XOR<XOR<UsuarioGerenciamentoUpdateToOneWithWhereWithoutUsuariosExecucaoInput, UsuarioGerenciamentoUpdateWithoutUsuariosExecucaoInput>, UsuarioGerenciamentoUncheckedUpdateWithoutUsuariosExecucaoInput>
  }

  export type ObraUpdateManyWithoutResponsavelNestedInput = {
    create?: XOR<ObraCreateWithoutResponsavelInput, ObraUncheckedCreateWithoutResponsavelInput> | ObraCreateWithoutResponsavelInput[] | ObraUncheckedCreateWithoutResponsavelInput[]
    connectOrCreate?: ObraCreateOrConnectWithoutResponsavelInput | ObraCreateOrConnectWithoutResponsavelInput[]
    upsert?: ObraUpsertWithWhereUniqueWithoutResponsavelInput | ObraUpsertWithWhereUniqueWithoutResponsavelInput[]
    createMany?: ObraCreateManyResponsavelInputEnvelope
    set?: ObraWhereUniqueInput | ObraWhereUniqueInput[]
    disconnect?: ObraWhereUniqueInput | ObraWhereUniqueInput[]
    delete?: ObraWhereUniqueInput | ObraWhereUniqueInput[]
    connect?: ObraWhereUniqueInput | ObraWhereUniqueInput[]
    update?: ObraUpdateWithWhereUniqueWithoutResponsavelInput | ObraUpdateWithWhereUniqueWithoutResponsavelInput[]
    updateMany?: ObraUpdateManyWithWhereWithoutResponsavelInput | ObraUpdateManyWithWhereWithoutResponsavelInput[]
    deleteMany?: ObraScalarWhereInput | ObraScalarWhereInput[]
  }

  export type ObraUncheckedUpdateManyWithoutResponsavelNestedInput = {
    create?: XOR<ObraCreateWithoutResponsavelInput, ObraUncheckedCreateWithoutResponsavelInput> | ObraCreateWithoutResponsavelInput[] | ObraUncheckedCreateWithoutResponsavelInput[]
    connectOrCreate?: ObraCreateOrConnectWithoutResponsavelInput | ObraCreateOrConnectWithoutResponsavelInput[]
    upsert?: ObraUpsertWithWhereUniqueWithoutResponsavelInput | ObraUpsertWithWhereUniqueWithoutResponsavelInput[]
    createMany?: ObraCreateManyResponsavelInputEnvelope
    set?: ObraWhereUniqueInput | ObraWhereUniqueInput[]
    disconnect?: ObraWhereUniqueInput | ObraWhereUniqueInput[]
    delete?: ObraWhereUniqueInput | ObraWhereUniqueInput[]
    connect?: ObraWhereUniqueInput | ObraWhereUniqueInput[]
    update?: ObraUpdateWithWhereUniqueWithoutResponsavelInput | ObraUpdateWithWhereUniqueWithoutResponsavelInput[]
    updateMany?: ObraUpdateManyWithWhereWithoutResponsavelInput | ObraUpdateManyWithWhereWithoutResponsavelInput[]
    deleteMany?: ObraScalarWhereInput | ObraScalarWhereInput[]
  }

  export type UsuarioGerenciamentoCreateNestedOneWithoutObrasInput = {
    create?: XOR<UsuarioGerenciamentoCreateWithoutObrasInput, UsuarioGerenciamentoUncheckedCreateWithoutObrasInput>
    connectOrCreate?: UsuarioGerenciamentoCreateOrConnectWithoutObrasInput
    connect?: UsuarioGerenciamentoWhereUniqueInput
  }

  export type UsuarioExecucaoCreateNestedOneWithoutObrasResponsavelInput = {
    create?: XOR<UsuarioExecucaoCreateWithoutObrasResponsavelInput, UsuarioExecucaoUncheckedCreateWithoutObrasResponsavelInput>
    connectOrCreate?: UsuarioExecucaoCreateOrConnectWithoutObrasResponsavelInput
    connect?: UsuarioExecucaoWhereUniqueInput
  }

  export type EtapaObraCreateNestedManyWithoutObraInput = {
    create?: XOR<EtapaObraCreateWithoutObraInput, EtapaObraUncheckedCreateWithoutObraInput> | EtapaObraCreateWithoutObraInput[] | EtapaObraUncheckedCreateWithoutObraInput[]
    connectOrCreate?: EtapaObraCreateOrConnectWithoutObraInput | EtapaObraCreateOrConnectWithoutObraInput[]
    createMany?: EtapaObraCreateManyObraInputEnvelope
    connect?: EtapaObraWhereUniqueInput | EtapaObraWhereUniqueInput[]
  }

  export type MaterialObraCreateNestedManyWithoutObraInput = {
    create?: XOR<MaterialObraCreateWithoutObraInput, MaterialObraUncheckedCreateWithoutObraInput> | MaterialObraCreateWithoutObraInput[] | MaterialObraUncheckedCreateWithoutObraInput[]
    connectOrCreate?: MaterialObraCreateOrConnectWithoutObraInput | MaterialObraCreateOrConnectWithoutObraInput[]
    createMany?: MaterialObraCreateManyObraInputEnvelope
    connect?: MaterialObraWhereUniqueInput | MaterialObraWhereUniqueInput[]
  }

  export type LembreteMaterialCreateNestedManyWithoutObraInput = {
    create?: XOR<LembreteMaterialCreateWithoutObraInput, LembreteMaterialUncheckedCreateWithoutObraInput> | LembreteMaterialCreateWithoutObraInput[] | LembreteMaterialUncheckedCreateWithoutObraInput[]
    connectOrCreate?: LembreteMaterialCreateOrConnectWithoutObraInput | LembreteMaterialCreateOrConnectWithoutObraInput[]
    createMany?: LembreteMaterialCreateManyObraInputEnvelope
    connect?: LembreteMaterialWhereUniqueInput | LembreteMaterialWhereUniqueInput[]
  }

  export type EtapaObraUncheckedCreateNestedManyWithoutObraInput = {
    create?: XOR<EtapaObraCreateWithoutObraInput, EtapaObraUncheckedCreateWithoutObraInput> | EtapaObraCreateWithoutObraInput[] | EtapaObraUncheckedCreateWithoutObraInput[]
    connectOrCreate?: EtapaObraCreateOrConnectWithoutObraInput | EtapaObraCreateOrConnectWithoutObraInput[]
    createMany?: EtapaObraCreateManyObraInputEnvelope
    connect?: EtapaObraWhereUniqueInput | EtapaObraWhereUniqueInput[]
  }

  export type MaterialObraUncheckedCreateNestedManyWithoutObraInput = {
    create?: XOR<MaterialObraCreateWithoutObraInput, MaterialObraUncheckedCreateWithoutObraInput> | MaterialObraCreateWithoutObraInput[] | MaterialObraUncheckedCreateWithoutObraInput[]
    connectOrCreate?: MaterialObraCreateOrConnectWithoutObraInput | MaterialObraCreateOrConnectWithoutObraInput[]
    createMany?: MaterialObraCreateManyObraInputEnvelope
    connect?: MaterialObraWhereUniqueInput | MaterialObraWhereUniqueInput[]
  }

  export type LembreteMaterialUncheckedCreateNestedManyWithoutObraInput = {
    create?: XOR<LembreteMaterialCreateWithoutObraInput, LembreteMaterialUncheckedCreateWithoutObraInput> | LembreteMaterialCreateWithoutObraInput[] | LembreteMaterialUncheckedCreateWithoutObraInput[]
    connectOrCreate?: LembreteMaterialCreateOrConnectWithoutObraInput | LembreteMaterialCreateOrConnectWithoutObraInput[]
    createMany?: LembreteMaterialCreateManyObraInputEnvelope
    connect?: LembreteMaterialWhereUniqueInput | LembreteMaterialWhereUniqueInput[]
  }

  export type EnumTipoObraFieldUpdateOperationsInput = {
    set?: $Enums.TipoObra
  }

  export type UsuarioGerenciamentoUpdateOneRequiredWithoutObrasNestedInput = {
    create?: XOR<UsuarioGerenciamentoCreateWithoutObrasInput, UsuarioGerenciamentoUncheckedCreateWithoutObrasInput>
    connectOrCreate?: UsuarioGerenciamentoCreateOrConnectWithoutObrasInput
    upsert?: UsuarioGerenciamentoUpsertWithoutObrasInput
    connect?: UsuarioGerenciamentoWhereUniqueInput
    update?: XOR<XOR<UsuarioGerenciamentoUpdateToOneWithWhereWithoutObrasInput, UsuarioGerenciamentoUpdateWithoutObrasInput>, UsuarioGerenciamentoUncheckedUpdateWithoutObrasInput>
  }

  export type UsuarioExecucaoUpdateOneRequiredWithoutObrasResponsavelNestedInput = {
    create?: XOR<UsuarioExecucaoCreateWithoutObrasResponsavelInput, UsuarioExecucaoUncheckedCreateWithoutObrasResponsavelInput>
    connectOrCreate?: UsuarioExecucaoCreateOrConnectWithoutObrasResponsavelInput
    upsert?: UsuarioExecucaoUpsertWithoutObrasResponsavelInput
    connect?: UsuarioExecucaoWhereUniqueInput
    update?: XOR<XOR<UsuarioExecucaoUpdateToOneWithWhereWithoutObrasResponsavelInput, UsuarioExecucaoUpdateWithoutObrasResponsavelInput>, UsuarioExecucaoUncheckedUpdateWithoutObrasResponsavelInput>
  }

  export type EtapaObraUpdateManyWithoutObraNestedInput = {
    create?: XOR<EtapaObraCreateWithoutObraInput, EtapaObraUncheckedCreateWithoutObraInput> | EtapaObraCreateWithoutObraInput[] | EtapaObraUncheckedCreateWithoutObraInput[]
    connectOrCreate?: EtapaObraCreateOrConnectWithoutObraInput | EtapaObraCreateOrConnectWithoutObraInput[]
    upsert?: EtapaObraUpsertWithWhereUniqueWithoutObraInput | EtapaObraUpsertWithWhereUniqueWithoutObraInput[]
    createMany?: EtapaObraCreateManyObraInputEnvelope
    set?: EtapaObraWhereUniqueInput | EtapaObraWhereUniqueInput[]
    disconnect?: EtapaObraWhereUniqueInput | EtapaObraWhereUniqueInput[]
    delete?: EtapaObraWhereUniqueInput | EtapaObraWhereUniqueInput[]
    connect?: EtapaObraWhereUniqueInput | EtapaObraWhereUniqueInput[]
    update?: EtapaObraUpdateWithWhereUniqueWithoutObraInput | EtapaObraUpdateWithWhereUniqueWithoutObraInput[]
    updateMany?: EtapaObraUpdateManyWithWhereWithoutObraInput | EtapaObraUpdateManyWithWhereWithoutObraInput[]
    deleteMany?: EtapaObraScalarWhereInput | EtapaObraScalarWhereInput[]
  }

  export type MaterialObraUpdateManyWithoutObraNestedInput = {
    create?: XOR<MaterialObraCreateWithoutObraInput, MaterialObraUncheckedCreateWithoutObraInput> | MaterialObraCreateWithoutObraInput[] | MaterialObraUncheckedCreateWithoutObraInput[]
    connectOrCreate?: MaterialObraCreateOrConnectWithoutObraInput | MaterialObraCreateOrConnectWithoutObraInput[]
    upsert?: MaterialObraUpsertWithWhereUniqueWithoutObraInput | MaterialObraUpsertWithWhereUniqueWithoutObraInput[]
    createMany?: MaterialObraCreateManyObraInputEnvelope
    set?: MaterialObraWhereUniqueInput | MaterialObraWhereUniqueInput[]
    disconnect?: MaterialObraWhereUniqueInput | MaterialObraWhereUniqueInput[]
    delete?: MaterialObraWhereUniqueInput | MaterialObraWhereUniqueInput[]
    connect?: MaterialObraWhereUniqueInput | MaterialObraWhereUniqueInput[]
    update?: MaterialObraUpdateWithWhereUniqueWithoutObraInput | MaterialObraUpdateWithWhereUniqueWithoutObraInput[]
    updateMany?: MaterialObraUpdateManyWithWhereWithoutObraInput | MaterialObraUpdateManyWithWhereWithoutObraInput[]
    deleteMany?: MaterialObraScalarWhereInput | MaterialObraScalarWhereInput[]
  }

  export type LembreteMaterialUpdateManyWithoutObraNestedInput = {
    create?: XOR<LembreteMaterialCreateWithoutObraInput, LembreteMaterialUncheckedCreateWithoutObraInput> | LembreteMaterialCreateWithoutObraInput[] | LembreteMaterialUncheckedCreateWithoutObraInput[]
    connectOrCreate?: LembreteMaterialCreateOrConnectWithoutObraInput | LembreteMaterialCreateOrConnectWithoutObraInput[]
    upsert?: LembreteMaterialUpsertWithWhereUniqueWithoutObraInput | LembreteMaterialUpsertWithWhereUniqueWithoutObraInput[]
    createMany?: LembreteMaterialCreateManyObraInputEnvelope
    set?: LembreteMaterialWhereUniqueInput | LembreteMaterialWhereUniqueInput[]
    disconnect?: LembreteMaterialWhereUniqueInput | LembreteMaterialWhereUniqueInput[]
    delete?: LembreteMaterialWhereUniqueInput | LembreteMaterialWhereUniqueInput[]
    connect?: LembreteMaterialWhereUniqueInput | LembreteMaterialWhereUniqueInput[]
    update?: LembreteMaterialUpdateWithWhereUniqueWithoutObraInput | LembreteMaterialUpdateWithWhereUniqueWithoutObraInput[]
    updateMany?: LembreteMaterialUpdateManyWithWhereWithoutObraInput | LembreteMaterialUpdateManyWithWhereWithoutObraInput[]
    deleteMany?: LembreteMaterialScalarWhereInput | LembreteMaterialScalarWhereInput[]
  }

  export type EtapaObraUncheckedUpdateManyWithoutObraNestedInput = {
    create?: XOR<EtapaObraCreateWithoutObraInput, EtapaObraUncheckedCreateWithoutObraInput> | EtapaObraCreateWithoutObraInput[] | EtapaObraUncheckedCreateWithoutObraInput[]
    connectOrCreate?: EtapaObraCreateOrConnectWithoutObraInput | EtapaObraCreateOrConnectWithoutObraInput[]
    upsert?: EtapaObraUpsertWithWhereUniqueWithoutObraInput | EtapaObraUpsertWithWhereUniqueWithoutObraInput[]
    createMany?: EtapaObraCreateManyObraInputEnvelope
    set?: EtapaObraWhereUniqueInput | EtapaObraWhereUniqueInput[]
    disconnect?: EtapaObraWhereUniqueInput | EtapaObraWhereUniqueInput[]
    delete?: EtapaObraWhereUniqueInput | EtapaObraWhereUniqueInput[]
    connect?: EtapaObraWhereUniqueInput | EtapaObraWhereUniqueInput[]
    update?: EtapaObraUpdateWithWhereUniqueWithoutObraInput | EtapaObraUpdateWithWhereUniqueWithoutObraInput[]
    updateMany?: EtapaObraUpdateManyWithWhereWithoutObraInput | EtapaObraUpdateManyWithWhereWithoutObraInput[]
    deleteMany?: EtapaObraScalarWhereInput | EtapaObraScalarWhereInput[]
  }

  export type MaterialObraUncheckedUpdateManyWithoutObraNestedInput = {
    create?: XOR<MaterialObraCreateWithoutObraInput, MaterialObraUncheckedCreateWithoutObraInput> | MaterialObraCreateWithoutObraInput[] | MaterialObraUncheckedCreateWithoutObraInput[]
    connectOrCreate?: MaterialObraCreateOrConnectWithoutObraInput | MaterialObraCreateOrConnectWithoutObraInput[]
    upsert?: MaterialObraUpsertWithWhereUniqueWithoutObraInput | MaterialObraUpsertWithWhereUniqueWithoutObraInput[]
    createMany?: MaterialObraCreateManyObraInputEnvelope
    set?: MaterialObraWhereUniqueInput | MaterialObraWhereUniqueInput[]
    disconnect?: MaterialObraWhereUniqueInput | MaterialObraWhereUniqueInput[]
    delete?: MaterialObraWhereUniqueInput | MaterialObraWhereUniqueInput[]
    connect?: MaterialObraWhereUniqueInput | MaterialObraWhereUniqueInput[]
    update?: MaterialObraUpdateWithWhereUniqueWithoutObraInput | MaterialObraUpdateWithWhereUniqueWithoutObraInput[]
    updateMany?: MaterialObraUpdateManyWithWhereWithoutObraInput | MaterialObraUpdateManyWithWhereWithoutObraInput[]
    deleteMany?: MaterialObraScalarWhereInput | MaterialObraScalarWhereInput[]
  }

  export type LembreteMaterialUncheckedUpdateManyWithoutObraNestedInput = {
    create?: XOR<LembreteMaterialCreateWithoutObraInput, LembreteMaterialUncheckedCreateWithoutObraInput> | LembreteMaterialCreateWithoutObraInput[] | LembreteMaterialUncheckedCreateWithoutObraInput[]
    connectOrCreate?: LembreteMaterialCreateOrConnectWithoutObraInput | LembreteMaterialCreateOrConnectWithoutObraInput[]
    upsert?: LembreteMaterialUpsertWithWhereUniqueWithoutObraInput | LembreteMaterialUpsertWithWhereUniqueWithoutObraInput[]
    createMany?: LembreteMaterialCreateManyObraInputEnvelope
    set?: LembreteMaterialWhereUniqueInput | LembreteMaterialWhereUniqueInput[]
    disconnect?: LembreteMaterialWhereUniqueInput | LembreteMaterialWhereUniqueInput[]
    delete?: LembreteMaterialWhereUniqueInput | LembreteMaterialWhereUniqueInput[]
    connect?: LembreteMaterialWhereUniqueInput | LembreteMaterialWhereUniqueInput[]
    update?: LembreteMaterialUpdateWithWhereUniqueWithoutObraInput | LembreteMaterialUpdateWithWhereUniqueWithoutObraInput[]
    updateMany?: LembreteMaterialUpdateManyWithWhereWithoutObraInput | LembreteMaterialUpdateManyWithWhereWithoutObraInput[]
    deleteMany?: LembreteMaterialScalarWhereInput | LembreteMaterialScalarWhereInput[]
  }

  export type EtapaObraCreateNestedManyWithoutJustificativaInput = {
    create?: XOR<EtapaObraCreateWithoutJustificativaInput, EtapaObraUncheckedCreateWithoutJustificativaInput> | EtapaObraCreateWithoutJustificativaInput[] | EtapaObraUncheckedCreateWithoutJustificativaInput[]
    connectOrCreate?: EtapaObraCreateOrConnectWithoutJustificativaInput | EtapaObraCreateOrConnectWithoutJustificativaInput[]
    createMany?: EtapaObraCreateManyJustificativaInputEnvelope
    connect?: EtapaObraWhereUniqueInput | EtapaObraWhereUniqueInput[]
  }

  export type EtapaObraUncheckedCreateNestedManyWithoutJustificativaInput = {
    create?: XOR<EtapaObraCreateWithoutJustificativaInput, EtapaObraUncheckedCreateWithoutJustificativaInput> | EtapaObraCreateWithoutJustificativaInput[] | EtapaObraUncheckedCreateWithoutJustificativaInput[]
    connectOrCreate?: EtapaObraCreateOrConnectWithoutJustificativaInput | EtapaObraCreateOrConnectWithoutJustificativaInput[]
    createMany?: EtapaObraCreateManyJustificativaInputEnvelope
    connect?: EtapaObraWhereUniqueInput | EtapaObraWhereUniqueInput[]
  }

  export type EnumTipoJustificativaFieldUpdateOperationsInput = {
    set?: $Enums.TipoJustificativa
  }

  export type EtapaObraUpdateManyWithoutJustificativaNestedInput = {
    create?: XOR<EtapaObraCreateWithoutJustificativaInput, EtapaObraUncheckedCreateWithoutJustificativaInput> | EtapaObraCreateWithoutJustificativaInput[] | EtapaObraUncheckedCreateWithoutJustificativaInput[]
    connectOrCreate?: EtapaObraCreateOrConnectWithoutJustificativaInput | EtapaObraCreateOrConnectWithoutJustificativaInput[]
    upsert?: EtapaObraUpsertWithWhereUniqueWithoutJustificativaInput | EtapaObraUpsertWithWhereUniqueWithoutJustificativaInput[]
    createMany?: EtapaObraCreateManyJustificativaInputEnvelope
    set?: EtapaObraWhereUniqueInput | EtapaObraWhereUniqueInput[]
    disconnect?: EtapaObraWhereUniqueInput | EtapaObraWhereUniqueInput[]
    delete?: EtapaObraWhereUniqueInput | EtapaObraWhereUniqueInput[]
    connect?: EtapaObraWhereUniqueInput | EtapaObraWhereUniqueInput[]
    update?: EtapaObraUpdateWithWhereUniqueWithoutJustificativaInput | EtapaObraUpdateWithWhereUniqueWithoutJustificativaInput[]
    updateMany?: EtapaObraUpdateManyWithWhereWithoutJustificativaInput | EtapaObraUpdateManyWithWhereWithoutJustificativaInput[]
    deleteMany?: EtapaObraScalarWhereInput | EtapaObraScalarWhereInput[]
  }

  export type EtapaObraUncheckedUpdateManyWithoutJustificativaNestedInput = {
    create?: XOR<EtapaObraCreateWithoutJustificativaInput, EtapaObraUncheckedCreateWithoutJustificativaInput> | EtapaObraCreateWithoutJustificativaInput[] | EtapaObraUncheckedCreateWithoutJustificativaInput[]
    connectOrCreate?: EtapaObraCreateOrConnectWithoutJustificativaInput | EtapaObraCreateOrConnectWithoutJustificativaInput[]
    upsert?: EtapaObraUpsertWithWhereUniqueWithoutJustificativaInput | EtapaObraUpsertWithWhereUniqueWithoutJustificativaInput[]
    createMany?: EtapaObraCreateManyJustificativaInputEnvelope
    set?: EtapaObraWhereUniqueInput | EtapaObraWhereUniqueInput[]
    disconnect?: EtapaObraWhereUniqueInput | EtapaObraWhereUniqueInput[]
    delete?: EtapaObraWhereUniqueInput | EtapaObraWhereUniqueInput[]
    connect?: EtapaObraWhereUniqueInput | EtapaObraWhereUniqueInput[]
    update?: EtapaObraUpdateWithWhereUniqueWithoutJustificativaInput | EtapaObraUpdateWithWhereUniqueWithoutJustificativaInput[]
    updateMany?: EtapaObraUpdateManyWithWhereWithoutJustificativaInput | EtapaObraUpdateManyWithWhereWithoutJustificativaInput[]
    deleteMany?: EtapaObraScalarWhereInput | EtapaObraScalarWhereInput[]
  }

  export type ObraCreateNestedOneWithoutEtapasInput = {
    create?: XOR<ObraCreateWithoutEtapasInput, ObraUncheckedCreateWithoutEtapasInput>
    connectOrCreate?: ObraCreateOrConnectWithoutEtapasInput
    connect?: ObraWhereUniqueInput
  }

  export type JustificativaAtrasoCreateNestedOneWithoutEtapasInput = {
    create?: XOR<JustificativaAtrasoCreateWithoutEtapasInput, JustificativaAtrasoUncheckedCreateWithoutEtapasInput>
    connectOrCreate?: JustificativaAtrasoCreateOrConnectWithoutEtapasInput
    connect?: JustificativaAtrasoWhereUniqueInput
  }

  export type EnumEtapaTipoFieldUpdateOperationsInput = {
    set?: $Enums.EtapaTipo
  }

  export type NullableEnumSubEtapaTipoFieldUpdateOperationsInput = {
    set?: $Enums.SubEtapaTipo | null
  }

  export type EnumStatusEtapaFieldUpdateOperationsInput = {
    set?: $Enums.StatusEtapa
  }

  export type ObraUpdateOneRequiredWithoutEtapasNestedInput = {
    create?: XOR<ObraCreateWithoutEtapasInput, ObraUncheckedCreateWithoutEtapasInput>
    connectOrCreate?: ObraCreateOrConnectWithoutEtapasInput
    upsert?: ObraUpsertWithoutEtapasInput
    connect?: ObraWhereUniqueInput
    update?: XOR<XOR<ObraUpdateToOneWithWhereWithoutEtapasInput, ObraUpdateWithoutEtapasInput>, ObraUncheckedUpdateWithoutEtapasInput>
  }

  export type JustificativaAtrasoUpdateOneWithoutEtapasNestedInput = {
    create?: XOR<JustificativaAtrasoCreateWithoutEtapasInput, JustificativaAtrasoUncheckedCreateWithoutEtapasInput>
    connectOrCreate?: JustificativaAtrasoCreateOrConnectWithoutEtapasInput
    upsert?: JustificativaAtrasoUpsertWithoutEtapasInput
    disconnect?: JustificativaAtrasoWhereInput | boolean
    delete?: JustificativaAtrasoWhereInput | boolean
    connect?: JustificativaAtrasoWhereUniqueInput
    update?: XOR<XOR<JustificativaAtrasoUpdateToOneWithWhereWithoutEtapasInput, JustificativaAtrasoUpdateWithoutEtapasInput>, JustificativaAtrasoUncheckedUpdateWithoutEtapasInput>
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type MaterialObraCreateNestedManyWithoutMaterialInput = {
    create?: XOR<MaterialObraCreateWithoutMaterialInput, MaterialObraUncheckedCreateWithoutMaterialInput> | MaterialObraCreateWithoutMaterialInput[] | MaterialObraUncheckedCreateWithoutMaterialInput[]
    connectOrCreate?: MaterialObraCreateOrConnectWithoutMaterialInput | MaterialObraCreateOrConnectWithoutMaterialInput[]
    createMany?: MaterialObraCreateManyMaterialInputEnvelope
    connect?: MaterialObraWhereUniqueInput | MaterialObraWhereUniqueInput[]
  }

  export type LembreteMaterialCreateNestedManyWithoutMaterialInput = {
    create?: XOR<LembreteMaterialCreateWithoutMaterialInput, LembreteMaterialUncheckedCreateWithoutMaterialInput> | LembreteMaterialCreateWithoutMaterialInput[] | LembreteMaterialUncheckedCreateWithoutMaterialInput[]
    connectOrCreate?: LembreteMaterialCreateOrConnectWithoutMaterialInput | LembreteMaterialCreateOrConnectWithoutMaterialInput[]
    createMany?: LembreteMaterialCreateManyMaterialInputEnvelope
    connect?: LembreteMaterialWhereUniqueInput | LembreteMaterialWhereUniqueInput[]
  }

  export type MaterialObraUncheckedCreateNestedManyWithoutMaterialInput = {
    create?: XOR<MaterialObraCreateWithoutMaterialInput, MaterialObraUncheckedCreateWithoutMaterialInput> | MaterialObraCreateWithoutMaterialInput[] | MaterialObraUncheckedCreateWithoutMaterialInput[]
    connectOrCreate?: MaterialObraCreateOrConnectWithoutMaterialInput | MaterialObraCreateOrConnectWithoutMaterialInput[]
    createMany?: MaterialObraCreateManyMaterialInputEnvelope
    connect?: MaterialObraWhereUniqueInput | MaterialObraWhereUniqueInput[]
  }

  export type LembreteMaterialUncheckedCreateNestedManyWithoutMaterialInput = {
    create?: XOR<LembreteMaterialCreateWithoutMaterialInput, LembreteMaterialUncheckedCreateWithoutMaterialInput> | LembreteMaterialCreateWithoutMaterialInput[] | LembreteMaterialUncheckedCreateWithoutMaterialInput[]
    connectOrCreate?: LembreteMaterialCreateOrConnectWithoutMaterialInput | LembreteMaterialCreateOrConnectWithoutMaterialInput[]
    createMany?: LembreteMaterialCreateManyMaterialInputEnvelope
    connect?: LembreteMaterialWhereUniqueInput | LembreteMaterialWhereUniqueInput[]
  }

  export type NullableEnumEtapaTipoFieldUpdateOperationsInput = {
    set?: $Enums.EtapaTipo | null
  }

  export type MaterialObraUpdateManyWithoutMaterialNestedInput = {
    create?: XOR<MaterialObraCreateWithoutMaterialInput, MaterialObraUncheckedCreateWithoutMaterialInput> | MaterialObraCreateWithoutMaterialInput[] | MaterialObraUncheckedCreateWithoutMaterialInput[]
    connectOrCreate?: MaterialObraCreateOrConnectWithoutMaterialInput | MaterialObraCreateOrConnectWithoutMaterialInput[]
    upsert?: MaterialObraUpsertWithWhereUniqueWithoutMaterialInput | MaterialObraUpsertWithWhereUniqueWithoutMaterialInput[]
    createMany?: MaterialObraCreateManyMaterialInputEnvelope
    set?: MaterialObraWhereUniqueInput | MaterialObraWhereUniqueInput[]
    disconnect?: MaterialObraWhereUniqueInput | MaterialObraWhereUniqueInput[]
    delete?: MaterialObraWhereUniqueInput | MaterialObraWhereUniqueInput[]
    connect?: MaterialObraWhereUniqueInput | MaterialObraWhereUniqueInput[]
    update?: MaterialObraUpdateWithWhereUniqueWithoutMaterialInput | MaterialObraUpdateWithWhereUniqueWithoutMaterialInput[]
    updateMany?: MaterialObraUpdateManyWithWhereWithoutMaterialInput | MaterialObraUpdateManyWithWhereWithoutMaterialInput[]
    deleteMany?: MaterialObraScalarWhereInput | MaterialObraScalarWhereInput[]
  }

  export type LembreteMaterialUpdateManyWithoutMaterialNestedInput = {
    create?: XOR<LembreteMaterialCreateWithoutMaterialInput, LembreteMaterialUncheckedCreateWithoutMaterialInput> | LembreteMaterialCreateWithoutMaterialInput[] | LembreteMaterialUncheckedCreateWithoutMaterialInput[]
    connectOrCreate?: LembreteMaterialCreateOrConnectWithoutMaterialInput | LembreteMaterialCreateOrConnectWithoutMaterialInput[]
    upsert?: LembreteMaterialUpsertWithWhereUniqueWithoutMaterialInput | LembreteMaterialUpsertWithWhereUniqueWithoutMaterialInput[]
    createMany?: LembreteMaterialCreateManyMaterialInputEnvelope
    set?: LembreteMaterialWhereUniqueInput | LembreteMaterialWhereUniqueInput[]
    disconnect?: LembreteMaterialWhereUniqueInput | LembreteMaterialWhereUniqueInput[]
    delete?: LembreteMaterialWhereUniqueInput | LembreteMaterialWhereUniqueInput[]
    connect?: LembreteMaterialWhereUniqueInput | LembreteMaterialWhereUniqueInput[]
    update?: LembreteMaterialUpdateWithWhereUniqueWithoutMaterialInput | LembreteMaterialUpdateWithWhereUniqueWithoutMaterialInput[]
    updateMany?: LembreteMaterialUpdateManyWithWhereWithoutMaterialInput | LembreteMaterialUpdateManyWithWhereWithoutMaterialInput[]
    deleteMany?: LembreteMaterialScalarWhereInput | LembreteMaterialScalarWhereInput[]
  }

  export type MaterialObraUncheckedUpdateManyWithoutMaterialNestedInput = {
    create?: XOR<MaterialObraCreateWithoutMaterialInput, MaterialObraUncheckedCreateWithoutMaterialInput> | MaterialObraCreateWithoutMaterialInput[] | MaterialObraUncheckedCreateWithoutMaterialInput[]
    connectOrCreate?: MaterialObraCreateOrConnectWithoutMaterialInput | MaterialObraCreateOrConnectWithoutMaterialInput[]
    upsert?: MaterialObraUpsertWithWhereUniqueWithoutMaterialInput | MaterialObraUpsertWithWhereUniqueWithoutMaterialInput[]
    createMany?: MaterialObraCreateManyMaterialInputEnvelope
    set?: MaterialObraWhereUniqueInput | MaterialObraWhereUniqueInput[]
    disconnect?: MaterialObraWhereUniqueInput | MaterialObraWhereUniqueInput[]
    delete?: MaterialObraWhereUniqueInput | MaterialObraWhereUniqueInput[]
    connect?: MaterialObraWhereUniqueInput | MaterialObraWhereUniqueInput[]
    update?: MaterialObraUpdateWithWhereUniqueWithoutMaterialInput | MaterialObraUpdateWithWhereUniqueWithoutMaterialInput[]
    updateMany?: MaterialObraUpdateManyWithWhereWithoutMaterialInput | MaterialObraUpdateManyWithWhereWithoutMaterialInput[]
    deleteMany?: MaterialObraScalarWhereInput | MaterialObraScalarWhereInput[]
  }

  export type LembreteMaterialUncheckedUpdateManyWithoutMaterialNestedInput = {
    create?: XOR<LembreteMaterialCreateWithoutMaterialInput, LembreteMaterialUncheckedCreateWithoutMaterialInput> | LembreteMaterialCreateWithoutMaterialInput[] | LembreteMaterialUncheckedCreateWithoutMaterialInput[]
    connectOrCreate?: LembreteMaterialCreateOrConnectWithoutMaterialInput | LembreteMaterialCreateOrConnectWithoutMaterialInput[]
    upsert?: LembreteMaterialUpsertWithWhereUniqueWithoutMaterialInput | LembreteMaterialUpsertWithWhereUniqueWithoutMaterialInput[]
    createMany?: LembreteMaterialCreateManyMaterialInputEnvelope
    set?: LembreteMaterialWhereUniqueInput | LembreteMaterialWhereUniqueInput[]
    disconnect?: LembreteMaterialWhereUniqueInput | LembreteMaterialWhereUniqueInput[]
    delete?: LembreteMaterialWhereUniqueInput | LembreteMaterialWhereUniqueInput[]
    connect?: LembreteMaterialWhereUniqueInput | LembreteMaterialWhereUniqueInput[]
    update?: LembreteMaterialUpdateWithWhereUniqueWithoutMaterialInput | LembreteMaterialUpdateWithWhereUniqueWithoutMaterialInput[]
    updateMany?: LembreteMaterialUpdateManyWithWhereWithoutMaterialInput | LembreteMaterialUpdateManyWithWhereWithoutMaterialInput[]
    deleteMany?: LembreteMaterialScalarWhereInput | LembreteMaterialScalarWhereInput[]
  }

  export type ObraCreateNestedOneWithoutMateriaisPedidosInput = {
    create?: XOR<ObraCreateWithoutMateriaisPedidosInput, ObraUncheckedCreateWithoutMateriaisPedidosInput>
    connectOrCreate?: ObraCreateOrConnectWithoutMateriaisPedidosInput
    connect?: ObraWhereUniqueInput
  }

  export type MaterialCreateNestedOneWithoutItensInput = {
    create?: XOR<MaterialCreateWithoutItensInput, MaterialUncheckedCreateWithoutItensInput>
    connectOrCreate?: MaterialCreateOrConnectWithoutItensInput
    connect?: MaterialWhereUniqueInput
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type EnumStatusPedidoFieldUpdateOperationsInput = {
    set?: $Enums.StatusPedido
  }

  export type ObraUpdateOneRequiredWithoutMateriaisPedidosNestedInput = {
    create?: XOR<ObraCreateWithoutMateriaisPedidosInput, ObraUncheckedCreateWithoutMateriaisPedidosInput>
    connectOrCreate?: ObraCreateOrConnectWithoutMateriaisPedidosInput
    upsert?: ObraUpsertWithoutMateriaisPedidosInput
    connect?: ObraWhereUniqueInput
    update?: XOR<XOR<ObraUpdateToOneWithWhereWithoutMateriaisPedidosInput, ObraUpdateWithoutMateriaisPedidosInput>, ObraUncheckedUpdateWithoutMateriaisPedidosInput>
  }

  export type MaterialUpdateOneRequiredWithoutItensNestedInput = {
    create?: XOR<MaterialCreateWithoutItensInput, MaterialUncheckedCreateWithoutItensInput>
    connectOrCreate?: MaterialCreateOrConnectWithoutItensInput
    upsert?: MaterialUpsertWithoutItensInput
    connect?: MaterialWhereUniqueInput
    update?: XOR<XOR<MaterialUpdateToOneWithWhereWithoutItensInput, MaterialUpdateWithoutItensInput>, MaterialUncheckedUpdateWithoutItensInput>
  }

  export type ObraCreateNestedOneWithoutLembretesInput = {
    create?: XOR<ObraCreateWithoutLembretesInput, ObraUncheckedCreateWithoutLembretesInput>
    connectOrCreate?: ObraCreateOrConnectWithoutLembretesInput
    connect?: ObraWhereUniqueInput
  }

  export type MaterialCreateNestedOneWithoutLembretesInput = {
    create?: XOR<MaterialCreateWithoutLembretesInput, MaterialUncheckedCreateWithoutLembretesInput>
    connectOrCreate?: MaterialCreateOrConnectWithoutLembretesInput
    connect?: MaterialWhereUniqueInput
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type ObraUpdateOneRequiredWithoutLembretesNestedInput = {
    create?: XOR<ObraCreateWithoutLembretesInput, ObraUncheckedCreateWithoutLembretesInput>
    connectOrCreate?: ObraCreateOrConnectWithoutLembretesInput
    upsert?: ObraUpsertWithoutLembretesInput
    connect?: ObraWhereUniqueInput
    update?: XOR<XOR<ObraUpdateToOneWithWhereWithoutLembretesInput, ObraUpdateWithoutLembretesInput>, ObraUncheckedUpdateWithoutLembretesInput>
  }

  export type MaterialUpdateOneRequiredWithoutLembretesNestedInput = {
    create?: XOR<MaterialCreateWithoutLembretesInput, MaterialUncheckedCreateWithoutLembretesInput>
    connectOrCreate?: MaterialCreateOrConnectWithoutLembretesInput
    upsert?: MaterialUpsertWithoutLembretesInput
    connect?: MaterialWhereUniqueInput
    update?: XOR<XOR<MaterialUpdateToOneWithWhereWithoutLembretesInput, MaterialUpdateWithoutLembretesInput>, MaterialUncheckedUpdateWithoutLembretesInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedEnumRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleFilter<$PrismaModel> | $Enums.Role
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedEnumRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleWithAggregatesFilter<$PrismaModel> | $Enums.Role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleFilter<$PrismaModel>
    _max?: NestedEnumRoleFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedEnumTipoObraFilter<$PrismaModel = never> = {
    equals?: $Enums.TipoObra | EnumTipoObraFieldRefInput<$PrismaModel>
    in?: $Enums.TipoObra[] | ListEnumTipoObraFieldRefInput<$PrismaModel>
    notIn?: $Enums.TipoObra[] | ListEnumTipoObraFieldRefInput<$PrismaModel>
    not?: NestedEnumTipoObraFilter<$PrismaModel> | $Enums.TipoObra
  }

  export type NestedEnumTipoObraWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TipoObra | EnumTipoObraFieldRefInput<$PrismaModel>
    in?: $Enums.TipoObra[] | ListEnumTipoObraFieldRefInput<$PrismaModel>
    notIn?: $Enums.TipoObra[] | ListEnumTipoObraFieldRefInput<$PrismaModel>
    not?: NestedEnumTipoObraWithAggregatesFilter<$PrismaModel> | $Enums.TipoObra
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTipoObraFilter<$PrismaModel>
    _max?: NestedEnumTipoObraFilter<$PrismaModel>
  }

  export type NestedEnumTipoJustificativaFilter<$PrismaModel = never> = {
    equals?: $Enums.TipoJustificativa | EnumTipoJustificativaFieldRefInput<$PrismaModel>
    in?: $Enums.TipoJustificativa[] | ListEnumTipoJustificativaFieldRefInput<$PrismaModel>
    notIn?: $Enums.TipoJustificativa[] | ListEnumTipoJustificativaFieldRefInput<$PrismaModel>
    not?: NestedEnumTipoJustificativaFilter<$PrismaModel> | $Enums.TipoJustificativa
  }

  export type NestedEnumTipoJustificativaWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TipoJustificativa | EnumTipoJustificativaFieldRefInput<$PrismaModel>
    in?: $Enums.TipoJustificativa[] | ListEnumTipoJustificativaFieldRefInput<$PrismaModel>
    notIn?: $Enums.TipoJustificativa[] | ListEnumTipoJustificativaFieldRefInput<$PrismaModel>
    not?: NestedEnumTipoJustificativaWithAggregatesFilter<$PrismaModel> | $Enums.TipoJustificativa
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTipoJustificativaFilter<$PrismaModel>
    _max?: NestedEnumTipoJustificativaFilter<$PrismaModel>
  }

  export type NestedEnumEtapaTipoFilter<$PrismaModel = never> = {
    equals?: $Enums.EtapaTipo | EnumEtapaTipoFieldRefInput<$PrismaModel>
    in?: $Enums.EtapaTipo[] | ListEnumEtapaTipoFieldRefInput<$PrismaModel>
    notIn?: $Enums.EtapaTipo[] | ListEnumEtapaTipoFieldRefInput<$PrismaModel>
    not?: NestedEnumEtapaTipoFilter<$PrismaModel> | $Enums.EtapaTipo
  }

  export type NestedEnumSubEtapaTipoNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.SubEtapaTipo | EnumSubEtapaTipoFieldRefInput<$PrismaModel> | null
    in?: $Enums.SubEtapaTipo[] | ListEnumSubEtapaTipoFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.SubEtapaTipo[] | ListEnumSubEtapaTipoFieldRefInput<$PrismaModel> | null
    not?: NestedEnumSubEtapaTipoNullableFilter<$PrismaModel> | $Enums.SubEtapaTipo | null
  }

  export type NestedEnumStatusEtapaFilter<$PrismaModel = never> = {
    equals?: $Enums.StatusEtapa | EnumStatusEtapaFieldRefInput<$PrismaModel>
    in?: $Enums.StatusEtapa[] | ListEnumStatusEtapaFieldRefInput<$PrismaModel>
    notIn?: $Enums.StatusEtapa[] | ListEnumStatusEtapaFieldRefInput<$PrismaModel>
    not?: NestedEnumStatusEtapaFilter<$PrismaModel> | $Enums.StatusEtapa
  }

  export type NestedEnumEtapaTipoWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EtapaTipo | EnumEtapaTipoFieldRefInput<$PrismaModel>
    in?: $Enums.EtapaTipo[] | ListEnumEtapaTipoFieldRefInput<$PrismaModel>
    notIn?: $Enums.EtapaTipo[] | ListEnumEtapaTipoFieldRefInput<$PrismaModel>
    not?: NestedEnumEtapaTipoWithAggregatesFilter<$PrismaModel> | $Enums.EtapaTipo
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEtapaTipoFilter<$PrismaModel>
    _max?: NestedEnumEtapaTipoFilter<$PrismaModel>
  }

  export type NestedEnumSubEtapaTipoNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SubEtapaTipo | EnumSubEtapaTipoFieldRefInput<$PrismaModel> | null
    in?: $Enums.SubEtapaTipo[] | ListEnumSubEtapaTipoFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.SubEtapaTipo[] | ListEnumSubEtapaTipoFieldRefInput<$PrismaModel> | null
    not?: NestedEnumSubEtapaTipoNullableWithAggregatesFilter<$PrismaModel> | $Enums.SubEtapaTipo | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumSubEtapaTipoNullableFilter<$PrismaModel>
    _max?: NestedEnumSubEtapaTipoNullableFilter<$PrismaModel>
  }

  export type NestedEnumStatusEtapaWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.StatusEtapa | EnumStatusEtapaFieldRefInput<$PrismaModel>
    in?: $Enums.StatusEtapa[] | ListEnumStatusEtapaFieldRefInput<$PrismaModel>
    notIn?: $Enums.StatusEtapa[] | ListEnumStatusEtapaFieldRefInput<$PrismaModel>
    not?: NestedEnumStatusEtapaWithAggregatesFilter<$PrismaModel> | $Enums.StatusEtapa
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStatusEtapaFilter<$PrismaModel>
    _max?: NestedEnumStatusEtapaFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumEtapaTipoNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.EtapaTipo | EnumEtapaTipoFieldRefInput<$PrismaModel> | null
    in?: $Enums.EtapaTipo[] | ListEnumEtapaTipoFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.EtapaTipo[] | ListEnumEtapaTipoFieldRefInput<$PrismaModel> | null
    not?: NestedEnumEtapaTipoNullableFilter<$PrismaModel> | $Enums.EtapaTipo | null
  }

  export type NestedEnumEtapaTipoNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EtapaTipo | EnumEtapaTipoFieldRefInput<$PrismaModel> | null
    in?: $Enums.EtapaTipo[] | ListEnumEtapaTipoFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.EtapaTipo[] | ListEnumEtapaTipoFieldRefInput<$PrismaModel> | null
    not?: NestedEnumEtapaTipoNullableWithAggregatesFilter<$PrismaModel> | $Enums.EtapaTipo | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumEtapaTipoNullableFilter<$PrismaModel>
    _max?: NestedEnumEtapaTipoNullableFilter<$PrismaModel>
  }

  export type NestedEnumStatusPedidoFilter<$PrismaModel = never> = {
    equals?: $Enums.StatusPedido | EnumStatusPedidoFieldRefInput<$PrismaModel>
    in?: $Enums.StatusPedido[] | ListEnumStatusPedidoFieldRefInput<$PrismaModel>
    notIn?: $Enums.StatusPedido[] | ListEnumStatusPedidoFieldRefInput<$PrismaModel>
    not?: NestedEnumStatusPedidoFilter<$PrismaModel> | $Enums.StatusPedido
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedEnumStatusPedidoWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.StatusPedido | EnumStatusPedidoFieldRefInput<$PrismaModel>
    in?: $Enums.StatusPedido[] | ListEnumStatusPedidoFieldRefInput<$PrismaModel>
    notIn?: $Enums.StatusPedido[] | ListEnumStatusPedidoFieldRefInput<$PrismaModel>
    not?: NestedEnumStatusPedidoWithAggregatesFilter<$PrismaModel> | $Enums.StatusPedido
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStatusPedidoFilter<$PrismaModel>
    _max?: NestedEnumStatusPedidoFilter<$PrismaModel>
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type ObraCreateWithoutGerenteInput = {
    tipoObra: $Enums.TipoObra
    endereco: string
    creaCauResponsavel: string
    cno: string
    createdAt?: Date | string
    updatedAt?: Date | string
    responsavel: UsuarioExecucaoCreateNestedOneWithoutObrasResponsavelInput
    etapas?: EtapaObraCreateNestedManyWithoutObraInput
    materiaisPedidos?: MaterialObraCreateNestedManyWithoutObraInput
    lembretes?: LembreteMaterialCreateNestedManyWithoutObraInput
  }

  export type ObraUncheckedCreateWithoutGerenteInput = {
    id?: number
    tipoObra: $Enums.TipoObra
    endereco: string
    creaCauResponsavel: string
    cno: string
    responsavelId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    etapas?: EtapaObraUncheckedCreateNestedManyWithoutObraInput
    materiaisPedidos?: MaterialObraUncheckedCreateNestedManyWithoutObraInput
    lembretes?: LembreteMaterialUncheckedCreateNestedManyWithoutObraInput
  }

  export type ObraCreateOrConnectWithoutGerenteInput = {
    where: ObraWhereUniqueInput
    create: XOR<ObraCreateWithoutGerenteInput, ObraUncheckedCreateWithoutGerenteInput>
  }

  export type ObraCreateManyGerenteInputEnvelope = {
    data: ObraCreateManyGerenteInput | ObraCreateManyGerenteInput[]
    skipDuplicates?: boolean
  }

  export type UsuarioExecucaoCreateWithoutEmpresaInput = {
    nome: string
    cpf: string
    endereco: string
    creaCau: string
    telefone?: string | null
    email: string
    dataNascimento?: Date | string | null
    senhaHash: string
    role?: $Enums.Role
    obrasResponsavel?: ObraCreateNestedManyWithoutResponsavelInput
  }

  export type UsuarioExecucaoUncheckedCreateWithoutEmpresaInput = {
    id?: number
    nome: string
    cpf: string
    endereco: string
    creaCau: string
    telefone?: string | null
    email: string
    dataNascimento?: Date | string | null
    senhaHash: string
    role?: $Enums.Role
    obrasResponsavel?: ObraUncheckedCreateNestedManyWithoutResponsavelInput
  }

  export type UsuarioExecucaoCreateOrConnectWithoutEmpresaInput = {
    where: UsuarioExecucaoWhereUniqueInput
    create: XOR<UsuarioExecucaoCreateWithoutEmpresaInput, UsuarioExecucaoUncheckedCreateWithoutEmpresaInput>
  }

  export type UsuarioExecucaoCreateManyEmpresaInputEnvelope = {
    data: UsuarioExecucaoCreateManyEmpresaInput | UsuarioExecucaoCreateManyEmpresaInput[]
    skipDuplicates?: boolean
  }

  export type ObraUpsertWithWhereUniqueWithoutGerenteInput = {
    where: ObraWhereUniqueInput
    update: XOR<ObraUpdateWithoutGerenteInput, ObraUncheckedUpdateWithoutGerenteInput>
    create: XOR<ObraCreateWithoutGerenteInput, ObraUncheckedCreateWithoutGerenteInput>
  }

  export type ObraUpdateWithWhereUniqueWithoutGerenteInput = {
    where: ObraWhereUniqueInput
    data: XOR<ObraUpdateWithoutGerenteInput, ObraUncheckedUpdateWithoutGerenteInput>
  }

  export type ObraUpdateManyWithWhereWithoutGerenteInput = {
    where: ObraScalarWhereInput
    data: XOR<ObraUpdateManyMutationInput, ObraUncheckedUpdateManyWithoutGerenteInput>
  }

  export type ObraScalarWhereInput = {
    AND?: ObraScalarWhereInput | ObraScalarWhereInput[]
    OR?: ObraScalarWhereInput[]
    NOT?: ObraScalarWhereInput | ObraScalarWhereInput[]
    id?: IntFilter<"Obra"> | number
    tipoObra?: EnumTipoObraFilter<"Obra"> | $Enums.TipoObra
    endereco?: StringFilter<"Obra"> | string
    creaCauResponsavel?: StringFilter<"Obra"> | string
    cno?: StringFilter<"Obra"> | string
    gerenteId?: IntFilter<"Obra"> | number
    responsavelId?: IntFilter<"Obra"> | number
    createdAt?: DateTimeFilter<"Obra"> | Date | string
    updatedAt?: DateTimeFilter<"Obra"> | Date | string
  }

  export type UsuarioExecucaoUpsertWithWhereUniqueWithoutEmpresaInput = {
    where: UsuarioExecucaoWhereUniqueInput
    update: XOR<UsuarioExecucaoUpdateWithoutEmpresaInput, UsuarioExecucaoUncheckedUpdateWithoutEmpresaInput>
    create: XOR<UsuarioExecucaoCreateWithoutEmpresaInput, UsuarioExecucaoUncheckedCreateWithoutEmpresaInput>
  }

  export type UsuarioExecucaoUpdateWithWhereUniqueWithoutEmpresaInput = {
    where: UsuarioExecucaoWhereUniqueInput
    data: XOR<UsuarioExecucaoUpdateWithoutEmpresaInput, UsuarioExecucaoUncheckedUpdateWithoutEmpresaInput>
  }

  export type UsuarioExecucaoUpdateManyWithWhereWithoutEmpresaInput = {
    where: UsuarioExecucaoScalarWhereInput
    data: XOR<UsuarioExecucaoUpdateManyMutationInput, UsuarioExecucaoUncheckedUpdateManyWithoutEmpresaInput>
  }

  export type UsuarioExecucaoScalarWhereInput = {
    AND?: UsuarioExecucaoScalarWhereInput | UsuarioExecucaoScalarWhereInput[]
    OR?: UsuarioExecucaoScalarWhereInput[]
    NOT?: UsuarioExecucaoScalarWhereInput | UsuarioExecucaoScalarWhereInput[]
    id?: IntFilter<"UsuarioExecucao"> | number
    nome?: StringFilter<"UsuarioExecucao"> | string
    cpf?: StringFilter<"UsuarioExecucao"> | string
    endereco?: StringFilter<"UsuarioExecucao"> | string
    creaCau?: StringFilter<"UsuarioExecucao"> | string
    telefone?: StringNullableFilter<"UsuarioExecucao"> | string | null
    email?: StringFilter<"UsuarioExecucao"> | string
    dataNascimento?: DateTimeNullableFilter<"UsuarioExecucao"> | Date | string | null
    senhaHash?: StringFilter<"UsuarioExecucao"> | string
    role?: EnumRoleFilter<"UsuarioExecucao"> | $Enums.Role
    empresaId?: IntFilter<"UsuarioExecucao"> | number
  }

  export type UsuarioGerenciamentoCreateWithoutUsuariosExecucaoInput = {
    razaoSocial: string
    inscricaoEstadual?: string | null
    cnpj: string
    dataFundacao?: Date | string | null
    telefone?: string | null
    email: string
    endereco: string
    senhaHash: string
    role?: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    obras?: ObraCreateNestedManyWithoutGerenteInput
  }

  export type UsuarioGerenciamentoUncheckedCreateWithoutUsuariosExecucaoInput = {
    id?: number
    razaoSocial: string
    inscricaoEstadual?: string | null
    cnpj: string
    dataFundacao?: Date | string | null
    telefone?: string | null
    email: string
    endereco: string
    senhaHash: string
    role?: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    obras?: ObraUncheckedCreateNestedManyWithoutGerenteInput
  }

  export type UsuarioGerenciamentoCreateOrConnectWithoutUsuariosExecucaoInput = {
    where: UsuarioGerenciamentoWhereUniqueInput
    create: XOR<UsuarioGerenciamentoCreateWithoutUsuariosExecucaoInput, UsuarioGerenciamentoUncheckedCreateWithoutUsuariosExecucaoInput>
  }

  export type ObraCreateWithoutResponsavelInput = {
    tipoObra: $Enums.TipoObra
    endereco: string
    creaCauResponsavel: string
    cno: string
    createdAt?: Date | string
    updatedAt?: Date | string
    gerente: UsuarioGerenciamentoCreateNestedOneWithoutObrasInput
    etapas?: EtapaObraCreateNestedManyWithoutObraInput
    materiaisPedidos?: MaterialObraCreateNestedManyWithoutObraInput
    lembretes?: LembreteMaterialCreateNestedManyWithoutObraInput
  }

  export type ObraUncheckedCreateWithoutResponsavelInput = {
    id?: number
    tipoObra: $Enums.TipoObra
    endereco: string
    creaCauResponsavel: string
    cno: string
    gerenteId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    etapas?: EtapaObraUncheckedCreateNestedManyWithoutObraInput
    materiaisPedidos?: MaterialObraUncheckedCreateNestedManyWithoutObraInput
    lembretes?: LembreteMaterialUncheckedCreateNestedManyWithoutObraInput
  }

  export type ObraCreateOrConnectWithoutResponsavelInput = {
    where: ObraWhereUniqueInput
    create: XOR<ObraCreateWithoutResponsavelInput, ObraUncheckedCreateWithoutResponsavelInput>
  }

  export type ObraCreateManyResponsavelInputEnvelope = {
    data: ObraCreateManyResponsavelInput | ObraCreateManyResponsavelInput[]
    skipDuplicates?: boolean
  }

  export type UsuarioGerenciamentoUpsertWithoutUsuariosExecucaoInput = {
    update: XOR<UsuarioGerenciamentoUpdateWithoutUsuariosExecucaoInput, UsuarioGerenciamentoUncheckedUpdateWithoutUsuariosExecucaoInput>
    create: XOR<UsuarioGerenciamentoCreateWithoutUsuariosExecucaoInput, UsuarioGerenciamentoUncheckedCreateWithoutUsuariosExecucaoInput>
    where?: UsuarioGerenciamentoWhereInput
  }

  export type UsuarioGerenciamentoUpdateToOneWithWhereWithoutUsuariosExecucaoInput = {
    where?: UsuarioGerenciamentoWhereInput
    data: XOR<UsuarioGerenciamentoUpdateWithoutUsuariosExecucaoInput, UsuarioGerenciamentoUncheckedUpdateWithoutUsuariosExecucaoInput>
  }

  export type UsuarioGerenciamentoUpdateWithoutUsuariosExecucaoInput = {
    razaoSocial?: StringFieldUpdateOperationsInput | string
    inscricaoEstadual?: NullableStringFieldUpdateOperationsInput | string | null
    cnpj?: StringFieldUpdateOperationsInput | string
    dataFundacao?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    telefone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    endereco?: StringFieldUpdateOperationsInput | string
    senhaHash?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    obras?: ObraUpdateManyWithoutGerenteNestedInput
  }

  export type UsuarioGerenciamentoUncheckedUpdateWithoutUsuariosExecucaoInput = {
    id?: IntFieldUpdateOperationsInput | number
    razaoSocial?: StringFieldUpdateOperationsInput | string
    inscricaoEstadual?: NullableStringFieldUpdateOperationsInput | string | null
    cnpj?: StringFieldUpdateOperationsInput | string
    dataFundacao?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    telefone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    endereco?: StringFieldUpdateOperationsInput | string
    senhaHash?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    obras?: ObraUncheckedUpdateManyWithoutGerenteNestedInput
  }

  export type ObraUpsertWithWhereUniqueWithoutResponsavelInput = {
    where: ObraWhereUniqueInput
    update: XOR<ObraUpdateWithoutResponsavelInput, ObraUncheckedUpdateWithoutResponsavelInput>
    create: XOR<ObraCreateWithoutResponsavelInput, ObraUncheckedCreateWithoutResponsavelInput>
  }

  export type ObraUpdateWithWhereUniqueWithoutResponsavelInput = {
    where: ObraWhereUniqueInput
    data: XOR<ObraUpdateWithoutResponsavelInput, ObraUncheckedUpdateWithoutResponsavelInput>
  }

  export type ObraUpdateManyWithWhereWithoutResponsavelInput = {
    where: ObraScalarWhereInput
    data: XOR<ObraUpdateManyMutationInput, ObraUncheckedUpdateManyWithoutResponsavelInput>
  }

  export type UsuarioGerenciamentoCreateWithoutObrasInput = {
    razaoSocial: string
    inscricaoEstadual?: string | null
    cnpj: string
    dataFundacao?: Date | string | null
    telefone?: string | null
    email: string
    endereco: string
    senhaHash: string
    role?: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    usuariosExecucao?: UsuarioExecucaoCreateNestedManyWithoutEmpresaInput
  }

  export type UsuarioGerenciamentoUncheckedCreateWithoutObrasInput = {
    id?: number
    razaoSocial: string
    inscricaoEstadual?: string | null
    cnpj: string
    dataFundacao?: Date | string | null
    telefone?: string | null
    email: string
    endereco: string
    senhaHash: string
    role?: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    usuariosExecucao?: UsuarioExecucaoUncheckedCreateNestedManyWithoutEmpresaInput
  }

  export type UsuarioGerenciamentoCreateOrConnectWithoutObrasInput = {
    where: UsuarioGerenciamentoWhereUniqueInput
    create: XOR<UsuarioGerenciamentoCreateWithoutObrasInput, UsuarioGerenciamentoUncheckedCreateWithoutObrasInput>
  }

  export type UsuarioExecucaoCreateWithoutObrasResponsavelInput = {
    nome: string
    cpf: string
    endereco: string
    creaCau: string
    telefone?: string | null
    email: string
    dataNascimento?: Date | string | null
    senhaHash: string
    role?: $Enums.Role
    empresa: UsuarioGerenciamentoCreateNestedOneWithoutUsuariosExecucaoInput
  }

  export type UsuarioExecucaoUncheckedCreateWithoutObrasResponsavelInput = {
    id?: number
    nome: string
    cpf: string
    endereco: string
    creaCau: string
    telefone?: string | null
    email: string
    dataNascimento?: Date | string | null
    senhaHash: string
    role?: $Enums.Role
    empresaId: number
  }

  export type UsuarioExecucaoCreateOrConnectWithoutObrasResponsavelInput = {
    where: UsuarioExecucaoWhereUniqueInput
    create: XOR<UsuarioExecucaoCreateWithoutObrasResponsavelInput, UsuarioExecucaoUncheckedCreateWithoutObrasResponsavelInput>
  }

  export type EtapaObraCreateWithoutObraInput = {
    tipo: $Enums.EtapaTipo
    subEtapa?: $Enums.SubEtapaTipo | null
    status?: $Enums.StatusEtapa
    dataPrevistaInicio?: Date | string | null
    dataPrevistaFim?: Date | string | null
    dataRealInicio?: Date | string | null
    dataRealFim?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    justificativa?: JustificativaAtrasoCreateNestedOneWithoutEtapasInput
  }

  export type EtapaObraUncheckedCreateWithoutObraInput = {
    id?: number
    tipo: $Enums.EtapaTipo
    subEtapa?: $Enums.SubEtapaTipo | null
    status?: $Enums.StatusEtapa
    dataPrevistaInicio?: Date | string | null
    dataPrevistaFim?: Date | string | null
    dataRealInicio?: Date | string | null
    dataRealFim?: Date | string | null
    justificativaId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EtapaObraCreateOrConnectWithoutObraInput = {
    where: EtapaObraWhereUniqueInput
    create: XOR<EtapaObraCreateWithoutObraInput, EtapaObraUncheckedCreateWithoutObraInput>
  }

  export type EtapaObraCreateManyObraInputEnvelope = {
    data: EtapaObraCreateManyObraInput | EtapaObraCreateManyObraInput[]
    skipDuplicates?: boolean
  }

  export type MaterialObraCreateWithoutObraInput = {
    etapa: $Enums.EtapaTipo
    quantidade: number
    statusPedido?: $Enums.StatusPedido
    dataPedido?: Date | string | null
    dataEntrega?: Date | string | null
    material: MaterialCreateNestedOneWithoutItensInput
  }

  export type MaterialObraUncheckedCreateWithoutObraInput = {
    id?: number
    materialId: number
    etapa: $Enums.EtapaTipo
    quantidade: number
    statusPedido?: $Enums.StatusPedido
    dataPedido?: Date | string | null
    dataEntrega?: Date | string | null
  }

  export type MaterialObraCreateOrConnectWithoutObraInput = {
    where: MaterialObraWhereUniqueInput
    create: XOR<MaterialObraCreateWithoutObraInput, MaterialObraUncheckedCreateWithoutObraInput>
  }

  export type MaterialObraCreateManyObraInputEnvelope = {
    data: MaterialObraCreateManyObraInput | MaterialObraCreateManyObraInput[]
    skipDuplicates?: boolean
  }

  export type LembreteMaterialCreateWithoutObraInput = {
    etapa: $Enums.EtapaTipo
    dataLembrete: Date | string
    enviado?: boolean
    createdAt?: Date | string
    material: MaterialCreateNestedOneWithoutLembretesInput
  }

  export type LembreteMaterialUncheckedCreateWithoutObraInput = {
    id?: number
    materialId: number
    etapa: $Enums.EtapaTipo
    dataLembrete: Date | string
    enviado?: boolean
    createdAt?: Date | string
  }

  export type LembreteMaterialCreateOrConnectWithoutObraInput = {
    where: LembreteMaterialWhereUniqueInput
    create: XOR<LembreteMaterialCreateWithoutObraInput, LembreteMaterialUncheckedCreateWithoutObraInput>
  }

  export type LembreteMaterialCreateManyObraInputEnvelope = {
    data: LembreteMaterialCreateManyObraInput | LembreteMaterialCreateManyObraInput[]
    skipDuplicates?: boolean
  }

  export type UsuarioGerenciamentoUpsertWithoutObrasInput = {
    update: XOR<UsuarioGerenciamentoUpdateWithoutObrasInput, UsuarioGerenciamentoUncheckedUpdateWithoutObrasInput>
    create: XOR<UsuarioGerenciamentoCreateWithoutObrasInput, UsuarioGerenciamentoUncheckedCreateWithoutObrasInput>
    where?: UsuarioGerenciamentoWhereInput
  }

  export type UsuarioGerenciamentoUpdateToOneWithWhereWithoutObrasInput = {
    where?: UsuarioGerenciamentoWhereInput
    data: XOR<UsuarioGerenciamentoUpdateWithoutObrasInput, UsuarioGerenciamentoUncheckedUpdateWithoutObrasInput>
  }

  export type UsuarioGerenciamentoUpdateWithoutObrasInput = {
    razaoSocial?: StringFieldUpdateOperationsInput | string
    inscricaoEstadual?: NullableStringFieldUpdateOperationsInput | string | null
    cnpj?: StringFieldUpdateOperationsInput | string
    dataFundacao?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    telefone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    endereco?: StringFieldUpdateOperationsInput | string
    senhaHash?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usuariosExecucao?: UsuarioExecucaoUpdateManyWithoutEmpresaNestedInput
  }

  export type UsuarioGerenciamentoUncheckedUpdateWithoutObrasInput = {
    id?: IntFieldUpdateOperationsInput | number
    razaoSocial?: StringFieldUpdateOperationsInput | string
    inscricaoEstadual?: NullableStringFieldUpdateOperationsInput | string | null
    cnpj?: StringFieldUpdateOperationsInput | string
    dataFundacao?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    telefone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    endereco?: StringFieldUpdateOperationsInput | string
    senhaHash?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usuariosExecucao?: UsuarioExecucaoUncheckedUpdateManyWithoutEmpresaNestedInput
  }

  export type UsuarioExecucaoUpsertWithoutObrasResponsavelInput = {
    update: XOR<UsuarioExecucaoUpdateWithoutObrasResponsavelInput, UsuarioExecucaoUncheckedUpdateWithoutObrasResponsavelInput>
    create: XOR<UsuarioExecucaoCreateWithoutObrasResponsavelInput, UsuarioExecucaoUncheckedCreateWithoutObrasResponsavelInput>
    where?: UsuarioExecucaoWhereInput
  }

  export type UsuarioExecucaoUpdateToOneWithWhereWithoutObrasResponsavelInput = {
    where?: UsuarioExecucaoWhereInput
    data: XOR<UsuarioExecucaoUpdateWithoutObrasResponsavelInput, UsuarioExecucaoUncheckedUpdateWithoutObrasResponsavelInput>
  }

  export type UsuarioExecucaoUpdateWithoutObrasResponsavelInput = {
    nome?: StringFieldUpdateOperationsInput | string
    cpf?: StringFieldUpdateOperationsInput | string
    endereco?: StringFieldUpdateOperationsInput | string
    creaCau?: StringFieldUpdateOperationsInput | string
    telefone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    dataNascimento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    senhaHash?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    empresa?: UsuarioGerenciamentoUpdateOneRequiredWithoutUsuariosExecucaoNestedInput
  }

  export type UsuarioExecucaoUncheckedUpdateWithoutObrasResponsavelInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    cpf?: StringFieldUpdateOperationsInput | string
    endereco?: StringFieldUpdateOperationsInput | string
    creaCau?: StringFieldUpdateOperationsInput | string
    telefone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    dataNascimento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    senhaHash?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    empresaId?: IntFieldUpdateOperationsInput | number
  }

  export type EtapaObraUpsertWithWhereUniqueWithoutObraInput = {
    where: EtapaObraWhereUniqueInput
    update: XOR<EtapaObraUpdateWithoutObraInput, EtapaObraUncheckedUpdateWithoutObraInput>
    create: XOR<EtapaObraCreateWithoutObraInput, EtapaObraUncheckedCreateWithoutObraInput>
  }

  export type EtapaObraUpdateWithWhereUniqueWithoutObraInput = {
    where: EtapaObraWhereUniqueInput
    data: XOR<EtapaObraUpdateWithoutObraInput, EtapaObraUncheckedUpdateWithoutObraInput>
  }

  export type EtapaObraUpdateManyWithWhereWithoutObraInput = {
    where: EtapaObraScalarWhereInput
    data: XOR<EtapaObraUpdateManyMutationInput, EtapaObraUncheckedUpdateManyWithoutObraInput>
  }

  export type EtapaObraScalarWhereInput = {
    AND?: EtapaObraScalarWhereInput | EtapaObraScalarWhereInput[]
    OR?: EtapaObraScalarWhereInput[]
    NOT?: EtapaObraScalarWhereInput | EtapaObraScalarWhereInput[]
    id?: IntFilter<"EtapaObra"> | number
    obraId?: IntFilter<"EtapaObra"> | number
    tipo?: EnumEtapaTipoFilter<"EtapaObra"> | $Enums.EtapaTipo
    subEtapa?: EnumSubEtapaTipoNullableFilter<"EtapaObra"> | $Enums.SubEtapaTipo | null
    status?: EnumStatusEtapaFilter<"EtapaObra"> | $Enums.StatusEtapa
    dataPrevistaInicio?: DateTimeNullableFilter<"EtapaObra"> | Date | string | null
    dataPrevistaFim?: DateTimeNullableFilter<"EtapaObra"> | Date | string | null
    dataRealInicio?: DateTimeNullableFilter<"EtapaObra"> | Date | string | null
    dataRealFim?: DateTimeNullableFilter<"EtapaObra"> | Date | string | null
    justificativaId?: IntNullableFilter<"EtapaObra"> | number | null
    createdAt?: DateTimeFilter<"EtapaObra"> | Date | string
    updatedAt?: DateTimeFilter<"EtapaObra"> | Date | string
  }

  export type MaterialObraUpsertWithWhereUniqueWithoutObraInput = {
    where: MaterialObraWhereUniqueInput
    update: XOR<MaterialObraUpdateWithoutObraInput, MaterialObraUncheckedUpdateWithoutObraInput>
    create: XOR<MaterialObraCreateWithoutObraInput, MaterialObraUncheckedCreateWithoutObraInput>
  }

  export type MaterialObraUpdateWithWhereUniqueWithoutObraInput = {
    where: MaterialObraWhereUniqueInput
    data: XOR<MaterialObraUpdateWithoutObraInput, MaterialObraUncheckedUpdateWithoutObraInput>
  }

  export type MaterialObraUpdateManyWithWhereWithoutObraInput = {
    where: MaterialObraScalarWhereInput
    data: XOR<MaterialObraUpdateManyMutationInput, MaterialObraUncheckedUpdateManyWithoutObraInput>
  }

  export type MaterialObraScalarWhereInput = {
    AND?: MaterialObraScalarWhereInput | MaterialObraScalarWhereInput[]
    OR?: MaterialObraScalarWhereInput[]
    NOT?: MaterialObraScalarWhereInput | MaterialObraScalarWhereInput[]
    id?: IntFilter<"MaterialObra"> | number
    obraId?: IntFilter<"MaterialObra"> | number
    materialId?: IntFilter<"MaterialObra"> | number
    etapa?: EnumEtapaTipoFilter<"MaterialObra"> | $Enums.EtapaTipo
    quantidade?: FloatFilter<"MaterialObra"> | number
    statusPedido?: EnumStatusPedidoFilter<"MaterialObra"> | $Enums.StatusPedido
    dataPedido?: DateTimeNullableFilter<"MaterialObra"> | Date | string | null
    dataEntrega?: DateTimeNullableFilter<"MaterialObra"> | Date | string | null
  }

  export type LembreteMaterialUpsertWithWhereUniqueWithoutObraInput = {
    where: LembreteMaterialWhereUniqueInput
    update: XOR<LembreteMaterialUpdateWithoutObraInput, LembreteMaterialUncheckedUpdateWithoutObraInput>
    create: XOR<LembreteMaterialCreateWithoutObraInput, LembreteMaterialUncheckedCreateWithoutObraInput>
  }

  export type LembreteMaterialUpdateWithWhereUniqueWithoutObraInput = {
    where: LembreteMaterialWhereUniqueInput
    data: XOR<LembreteMaterialUpdateWithoutObraInput, LembreteMaterialUncheckedUpdateWithoutObraInput>
  }

  export type LembreteMaterialUpdateManyWithWhereWithoutObraInput = {
    where: LembreteMaterialScalarWhereInput
    data: XOR<LembreteMaterialUpdateManyMutationInput, LembreteMaterialUncheckedUpdateManyWithoutObraInput>
  }

  export type LembreteMaterialScalarWhereInput = {
    AND?: LembreteMaterialScalarWhereInput | LembreteMaterialScalarWhereInput[]
    OR?: LembreteMaterialScalarWhereInput[]
    NOT?: LembreteMaterialScalarWhereInput | LembreteMaterialScalarWhereInput[]
    id?: IntFilter<"LembreteMaterial"> | number
    obraId?: IntFilter<"LembreteMaterial"> | number
    materialId?: IntFilter<"LembreteMaterial"> | number
    etapa?: EnumEtapaTipoFilter<"LembreteMaterial"> | $Enums.EtapaTipo
    dataLembrete?: DateTimeFilter<"LembreteMaterial"> | Date | string
    enviado?: BoolFilter<"LembreteMaterial"> | boolean
    createdAt?: DateTimeFilter<"LembreteMaterial"> | Date | string
  }

  export type EtapaObraCreateWithoutJustificativaInput = {
    tipo: $Enums.EtapaTipo
    subEtapa?: $Enums.SubEtapaTipo | null
    status?: $Enums.StatusEtapa
    dataPrevistaInicio?: Date | string | null
    dataPrevistaFim?: Date | string | null
    dataRealInicio?: Date | string | null
    dataRealFim?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    obra: ObraCreateNestedOneWithoutEtapasInput
  }

  export type EtapaObraUncheckedCreateWithoutJustificativaInput = {
    id?: number
    obraId: number
    tipo: $Enums.EtapaTipo
    subEtapa?: $Enums.SubEtapaTipo | null
    status?: $Enums.StatusEtapa
    dataPrevistaInicio?: Date | string | null
    dataPrevistaFim?: Date | string | null
    dataRealInicio?: Date | string | null
    dataRealFim?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EtapaObraCreateOrConnectWithoutJustificativaInput = {
    where: EtapaObraWhereUniqueInput
    create: XOR<EtapaObraCreateWithoutJustificativaInput, EtapaObraUncheckedCreateWithoutJustificativaInput>
  }

  export type EtapaObraCreateManyJustificativaInputEnvelope = {
    data: EtapaObraCreateManyJustificativaInput | EtapaObraCreateManyJustificativaInput[]
    skipDuplicates?: boolean
  }

  export type EtapaObraUpsertWithWhereUniqueWithoutJustificativaInput = {
    where: EtapaObraWhereUniqueInput
    update: XOR<EtapaObraUpdateWithoutJustificativaInput, EtapaObraUncheckedUpdateWithoutJustificativaInput>
    create: XOR<EtapaObraCreateWithoutJustificativaInput, EtapaObraUncheckedCreateWithoutJustificativaInput>
  }

  export type EtapaObraUpdateWithWhereUniqueWithoutJustificativaInput = {
    where: EtapaObraWhereUniqueInput
    data: XOR<EtapaObraUpdateWithoutJustificativaInput, EtapaObraUncheckedUpdateWithoutJustificativaInput>
  }

  export type EtapaObraUpdateManyWithWhereWithoutJustificativaInput = {
    where: EtapaObraScalarWhereInput
    data: XOR<EtapaObraUpdateManyMutationInput, EtapaObraUncheckedUpdateManyWithoutJustificativaInput>
  }

  export type ObraCreateWithoutEtapasInput = {
    tipoObra: $Enums.TipoObra
    endereco: string
    creaCauResponsavel: string
    cno: string
    createdAt?: Date | string
    updatedAt?: Date | string
    gerente: UsuarioGerenciamentoCreateNestedOneWithoutObrasInput
    responsavel: UsuarioExecucaoCreateNestedOneWithoutObrasResponsavelInput
    materiaisPedidos?: MaterialObraCreateNestedManyWithoutObraInput
    lembretes?: LembreteMaterialCreateNestedManyWithoutObraInput
  }

  export type ObraUncheckedCreateWithoutEtapasInput = {
    id?: number
    tipoObra: $Enums.TipoObra
    endereco: string
    creaCauResponsavel: string
    cno: string
    gerenteId: number
    responsavelId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    materiaisPedidos?: MaterialObraUncheckedCreateNestedManyWithoutObraInput
    lembretes?: LembreteMaterialUncheckedCreateNestedManyWithoutObraInput
  }

  export type ObraCreateOrConnectWithoutEtapasInput = {
    where: ObraWhereUniqueInput
    create: XOR<ObraCreateWithoutEtapasInput, ObraUncheckedCreateWithoutEtapasInput>
  }

  export type JustificativaAtrasoCreateWithoutEtapasInput = {
    tipo: $Enums.TipoJustificativa
    descricao?: string | null
    createdAt?: Date | string
  }

  export type JustificativaAtrasoUncheckedCreateWithoutEtapasInput = {
    id?: number
    tipo: $Enums.TipoJustificativa
    descricao?: string | null
    createdAt?: Date | string
  }

  export type JustificativaAtrasoCreateOrConnectWithoutEtapasInput = {
    where: JustificativaAtrasoWhereUniqueInput
    create: XOR<JustificativaAtrasoCreateWithoutEtapasInput, JustificativaAtrasoUncheckedCreateWithoutEtapasInput>
  }

  export type ObraUpsertWithoutEtapasInput = {
    update: XOR<ObraUpdateWithoutEtapasInput, ObraUncheckedUpdateWithoutEtapasInput>
    create: XOR<ObraCreateWithoutEtapasInput, ObraUncheckedCreateWithoutEtapasInput>
    where?: ObraWhereInput
  }

  export type ObraUpdateToOneWithWhereWithoutEtapasInput = {
    where?: ObraWhereInput
    data: XOR<ObraUpdateWithoutEtapasInput, ObraUncheckedUpdateWithoutEtapasInput>
  }

  export type ObraUpdateWithoutEtapasInput = {
    tipoObra?: EnumTipoObraFieldUpdateOperationsInput | $Enums.TipoObra
    endereco?: StringFieldUpdateOperationsInput | string
    creaCauResponsavel?: StringFieldUpdateOperationsInput | string
    cno?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    gerente?: UsuarioGerenciamentoUpdateOneRequiredWithoutObrasNestedInput
    responsavel?: UsuarioExecucaoUpdateOneRequiredWithoutObrasResponsavelNestedInput
    materiaisPedidos?: MaterialObraUpdateManyWithoutObraNestedInput
    lembretes?: LembreteMaterialUpdateManyWithoutObraNestedInput
  }

  export type ObraUncheckedUpdateWithoutEtapasInput = {
    id?: IntFieldUpdateOperationsInput | number
    tipoObra?: EnumTipoObraFieldUpdateOperationsInput | $Enums.TipoObra
    endereco?: StringFieldUpdateOperationsInput | string
    creaCauResponsavel?: StringFieldUpdateOperationsInput | string
    cno?: StringFieldUpdateOperationsInput | string
    gerenteId?: IntFieldUpdateOperationsInput | number
    responsavelId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    materiaisPedidos?: MaterialObraUncheckedUpdateManyWithoutObraNestedInput
    lembretes?: LembreteMaterialUncheckedUpdateManyWithoutObraNestedInput
  }

  export type JustificativaAtrasoUpsertWithoutEtapasInput = {
    update: XOR<JustificativaAtrasoUpdateWithoutEtapasInput, JustificativaAtrasoUncheckedUpdateWithoutEtapasInput>
    create: XOR<JustificativaAtrasoCreateWithoutEtapasInput, JustificativaAtrasoUncheckedCreateWithoutEtapasInput>
    where?: JustificativaAtrasoWhereInput
  }

  export type JustificativaAtrasoUpdateToOneWithWhereWithoutEtapasInput = {
    where?: JustificativaAtrasoWhereInput
    data: XOR<JustificativaAtrasoUpdateWithoutEtapasInput, JustificativaAtrasoUncheckedUpdateWithoutEtapasInput>
  }

  export type JustificativaAtrasoUpdateWithoutEtapasInput = {
    tipo?: EnumTipoJustificativaFieldUpdateOperationsInput | $Enums.TipoJustificativa
    descricao?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JustificativaAtrasoUncheckedUpdateWithoutEtapasInput = {
    id?: IntFieldUpdateOperationsInput | number
    tipo?: EnumTipoJustificativaFieldUpdateOperationsInput | $Enums.TipoJustificativa
    descricao?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MaterialObraCreateWithoutMaterialInput = {
    etapa: $Enums.EtapaTipo
    quantidade: number
    statusPedido?: $Enums.StatusPedido
    dataPedido?: Date | string | null
    dataEntrega?: Date | string | null
    obra: ObraCreateNestedOneWithoutMateriaisPedidosInput
  }

  export type MaterialObraUncheckedCreateWithoutMaterialInput = {
    id?: number
    obraId: number
    etapa: $Enums.EtapaTipo
    quantidade: number
    statusPedido?: $Enums.StatusPedido
    dataPedido?: Date | string | null
    dataEntrega?: Date | string | null
  }

  export type MaterialObraCreateOrConnectWithoutMaterialInput = {
    where: MaterialObraWhereUniqueInput
    create: XOR<MaterialObraCreateWithoutMaterialInput, MaterialObraUncheckedCreateWithoutMaterialInput>
  }

  export type MaterialObraCreateManyMaterialInputEnvelope = {
    data: MaterialObraCreateManyMaterialInput | MaterialObraCreateManyMaterialInput[]
    skipDuplicates?: boolean
  }

  export type LembreteMaterialCreateWithoutMaterialInput = {
    etapa: $Enums.EtapaTipo
    dataLembrete: Date | string
    enviado?: boolean
    createdAt?: Date | string
    obra: ObraCreateNestedOneWithoutLembretesInput
  }

  export type LembreteMaterialUncheckedCreateWithoutMaterialInput = {
    id?: number
    obraId: number
    etapa: $Enums.EtapaTipo
    dataLembrete: Date | string
    enviado?: boolean
    createdAt?: Date | string
  }

  export type LembreteMaterialCreateOrConnectWithoutMaterialInput = {
    where: LembreteMaterialWhereUniqueInput
    create: XOR<LembreteMaterialCreateWithoutMaterialInput, LembreteMaterialUncheckedCreateWithoutMaterialInput>
  }

  export type LembreteMaterialCreateManyMaterialInputEnvelope = {
    data: LembreteMaterialCreateManyMaterialInput | LembreteMaterialCreateManyMaterialInput[]
    skipDuplicates?: boolean
  }

  export type MaterialObraUpsertWithWhereUniqueWithoutMaterialInput = {
    where: MaterialObraWhereUniqueInput
    update: XOR<MaterialObraUpdateWithoutMaterialInput, MaterialObraUncheckedUpdateWithoutMaterialInput>
    create: XOR<MaterialObraCreateWithoutMaterialInput, MaterialObraUncheckedCreateWithoutMaterialInput>
  }

  export type MaterialObraUpdateWithWhereUniqueWithoutMaterialInput = {
    where: MaterialObraWhereUniqueInput
    data: XOR<MaterialObraUpdateWithoutMaterialInput, MaterialObraUncheckedUpdateWithoutMaterialInput>
  }

  export type MaterialObraUpdateManyWithWhereWithoutMaterialInput = {
    where: MaterialObraScalarWhereInput
    data: XOR<MaterialObraUpdateManyMutationInput, MaterialObraUncheckedUpdateManyWithoutMaterialInput>
  }

  export type LembreteMaterialUpsertWithWhereUniqueWithoutMaterialInput = {
    where: LembreteMaterialWhereUniqueInput
    update: XOR<LembreteMaterialUpdateWithoutMaterialInput, LembreteMaterialUncheckedUpdateWithoutMaterialInput>
    create: XOR<LembreteMaterialCreateWithoutMaterialInput, LembreteMaterialUncheckedCreateWithoutMaterialInput>
  }

  export type LembreteMaterialUpdateWithWhereUniqueWithoutMaterialInput = {
    where: LembreteMaterialWhereUniqueInput
    data: XOR<LembreteMaterialUpdateWithoutMaterialInput, LembreteMaterialUncheckedUpdateWithoutMaterialInput>
  }

  export type LembreteMaterialUpdateManyWithWhereWithoutMaterialInput = {
    where: LembreteMaterialScalarWhereInput
    data: XOR<LembreteMaterialUpdateManyMutationInput, LembreteMaterialUncheckedUpdateManyWithoutMaterialInput>
  }

  export type ObraCreateWithoutMateriaisPedidosInput = {
    tipoObra: $Enums.TipoObra
    endereco: string
    creaCauResponsavel: string
    cno: string
    createdAt?: Date | string
    updatedAt?: Date | string
    gerente: UsuarioGerenciamentoCreateNestedOneWithoutObrasInput
    responsavel: UsuarioExecucaoCreateNestedOneWithoutObrasResponsavelInput
    etapas?: EtapaObraCreateNestedManyWithoutObraInput
    lembretes?: LembreteMaterialCreateNestedManyWithoutObraInput
  }

  export type ObraUncheckedCreateWithoutMateriaisPedidosInput = {
    id?: number
    tipoObra: $Enums.TipoObra
    endereco: string
    creaCauResponsavel: string
    cno: string
    gerenteId: number
    responsavelId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    etapas?: EtapaObraUncheckedCreateNestedManyWithoutObraInput
    lembretes?: LembreteMaterialUncheckedCreateNestedManyWithoutObraInput
  }

  export type ObraCreateOrConnectWithoutMateriaisPedidosInput = {
    where: ObraWhereUniqueInput
    create: XOR<ObraCreateWithoutMateriaisPedidosInput, ObraUncheckedCreateWithoutMateriaisPedidosInput>
  }

  export type MaterialCreateWithoutItensInput = {
    nome: string
    etapaDefault?: $Enums.EtapaTipo | null
    unidade: string
    lembretes?: LembreteMaterialCreateNestedManyWithoutMaterialInput
  }

  export type MaterialUncheckedCreateWithoutItensInput = {
    id?: number
    nome: string
    etapaDefault?: $Enums.EtapaTipo | null
    unidade: string
    lembretes?: LembreteMaterialUncheckedCreateNestedManyWithoutMaterialInput
  }

  export type MaterialCreateOrConnectWithoutItensInput = {
    where: MaterialWhereUniqueInput
    create: XOR<MaterialCreateWithoutItensInput, MaterialUncheckedCreateWithoutItensInput>
  }

  export type ObraUpsertWithoutMateriaisPedidosInput = {
    update: XOR<ObraUpdateWithoutMateriaisPedidosInput, ObraUncheckedUpdateWithoutMateriaisPedidosInput>
    create: XOR<ObraCreateWithoutMateriaisPedidosInput, ObraUncheckedCreateWithoutMateriaisPedidosInput>
    where?: ObraWhereInput
  }

  export type ObraUpdateToOneWithWhereWithoutMateriaisPedidosInput = {
    where?: ObraWhereInput
    data: XOR<ObraUpdateWithoutMateriaisPedidosInput, ObraUncheckedUpdateWithoutMateriaisPedidosInput>
  }

  export type ObraUpdateWithoutMateriaisPedidosInput = {
    tipoObra?: EnumTipoObraFieldUpdateOperationsInput | $Enums.TipoObra
    endereco?: StringFieldUpdateOperationsInput | string
    creaCauResponsavel?: StringFieldUpdateOperationsInput | string
    cno?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    gerente?: UsuarioGerenciamentoUpdateOneRequiredWithoutObrasNestedInput
    responsavel?: UsuarioExecucaoUpdateOneRequiredWithoutObrasResponsavelNestedInput
    etapas?: EtapaObraUpdateManyWithoutObraNestedInput
    lembretes?: LembreteMaterialUpdateManyWithoutObraNestedInput
  }

  export type ObraUncheckedUpdateWithoutMateriaisPedidosInput = {
    id?: IntFieldUpdateOperationsInput | number
    tipoObra?: EnumTipoObraFieldUpdateOperationsInput | $Enums.TipoObra
    endereco?: StringFieldUpdateOperationsInput | string
    creaCauResponsavel?: StringFieldUpdateOperationsInput | string
    cno?: StringFieldUpdateOperationsInput | string
    gerenteId?: IntFieldUpdateOperationsInput | number
    responsavelId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    etapas?: EtapaObraUncheckedUpdateManyWithoutObraNestedInput
    lembretes?: LembreteMaterialUncheckedUpdateManyWithoutObraNestedInput
  }

  export type MaterialUpsertWithoutItensInput = {
    update: XOR<MaterialUpdateWithoutItensInput, MaterialUncheckedUpdateWithoutItensInput>
    create: XOR<MaterialCreateWithoutItensInput, MaterialUncheckedCreateWithoutItensInput>
    where?: MaterialWhereInput
  }

  export type MaterialUpdateToOneWithWhereWithoutItensInput = {
    where?: MaterialWhereInput
    data: XOR<MaterialUpdateWithoutItensInput, MaterialUncheckedUpdateWithoutItensInput>
  }

  export type MaterialUpdateWithoutItensInput = {
    nome?: StringFieldUpdateOperationsInput | string
    etapaDefault?: NullableEnumEtapaTipoFieldUpdateOperationsInput | $Enums.EtapaTipo | null
    unidade?: StringFieldUpdateOperationsInput | string
    lembretes?: LembreteMaterialUpdateManyWithoutMaterialNestedInput
  }

  export type MaterialUncheckedUpdateWithoutItensInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    etapaDefault?: NullableEnumEtapaTipoFieldUpdateOperationsInput | $Enums.EtapaTipo | null
    unidade?: StringFieldUpdateOperationsInput | string
    lembretes?: LembreteMaterialUncheckedUpdateManyWithoutMaterialNestedInput
  }

  export type ObraCreateWithoutLembretesInput = {
    tipoObra: $Enums.TipoObra
    endereco: string
    creaCauResponsavel: string
    cno: string
    createdAt?: Date | string
    updatedAt?: Date | string
    gerente: UsuarioGerenciamentoCreateNestedOneWithoutObrasInput
    responsavel: UsuarioExecucaoCreateNestedOneWithoutObrasResponsavelInput
    etapas?: EtapaObraCreateNestedManyWithoutObraInput
    materiaisPedidos?: MaterialObraCreateNestedManyWithoutObraInput
  }

  export type ObraUncheckedCreateWithoutLembretesInput = {
    id?: number
    tipoObra: $Enums.TipoObra
    endereco: string
    creaCauResponsavel: string
    cno: string
    gerenteId: number
    responsavelId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    etapas?: EtapaObraUncheckedCreateNestedManyWithoutObraInput
    materiaisPedidos?: MaterialObraUncheckedCreateNestedManyWithoutObraInput
  }

  export type ObraCreateOrConnectWithoutLembretesInput = {
    where: ObraWhereUniqueInput
    create: XOR<ObraCreateWithoutLembretesInput, ObraUncheckedCreateWithoutLembretesInput>
  }

  export type MaterialCreateWithoutLembretesInput = {
    nome: string
    etapaDefault?: $Enums.EtapaTipo | null
    unidade: string
    itens?: MaterialObraCreateNestedManyWithoutMaterialInput
  }

  export type MaterialUncheckedCreateWithoutLembretesInput = {
    id?: number
    nome: string
    etapaDefault?: $Enums.EtapaTipo | null
    unidade: string
    itens?: MaterialObraUncheckedCreateNestedManyWithoutMaterialInput
  }

  export type MaterialCreateOrConnectWithoutLembretesInput = {
    where: MaterialWhereUniqueInput
    create: XOR<MaterialCreateWithoutLembretesInput, MaterialUncheckedCreateWithoutLembretesInput>
  }

  export type ObraUpsertWithoutLembretesInput = {
    update: XOR<ObraUpdateWithoutLembretesInput, ObraUncheckedUpdateWithoutLembretesInput>
    create: XOR<ObraCreateWithoutLembretesInput, ObraUncheckedCreateWithoutLembretesInput>
    where?: ObraWhereInput
  }

  export type ObraUpdateToOneWithWhereWithoutLembretesInput = {
    where?: ObraWhereInput
    data: XOR<ObraUpdateWithoutLembretesInput, ObraUncheckedUpdateWithoutLembretesInput>
  }

  export type ObraUpdateWithoutLembretesInput = {
    tipoObra?: EnumTipoObraFieldUpdateOperationsInput | $Enums.TipoObra
    endereco?: StringFieldUpdateOperationsInput | string
    creaCauResponsavel?: StringFieldUpdateOperationsInput | string
    cno?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    gerente?: UsuarioGerenciamentoUpdateOneRequiredWithoutObrasNestedInput
    responsavel?: UsuarioExecucaoUpdateOneRequiredWithoutObrasResponsavelNestedInput
    etapas?: EtapaObraUpdateManyWithoutObraNestedInput
    materiaisPedidos?: MaterialObraUpdateManyWithoutObraNestedInput
  }

  export type ObraUncheckedUpdateWithoutLembretesInput = {
    id?: IntFieldUpdateOperationsInput | number
    tipoObra?: EnumTipoObraFieldUpdateOperationsInput | $Enums.TipoObra
    endereco?: StringFieldUpdateOperationsInput | string
    creaCauResponsavel?: StringFieldUpdateOperationsInput | string
    cno?: StringFieldUpdateOperationsInput | string
    gerenteId?: IntFieldUpdateOperationsInput | number
    responsavelId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    etapas?: EtapaObraUncheckedUpdateManyWithoutObraNestedInput
    materiaisPedidos?: MaterialObraUncheckedUpdateManyWithoutObraNestedInput
  }

  export type MaterialUpsertWithoutLembretesInput = {
    update: XOR<MaterialUpdateWithoutLembretesInput, MaterialUncheckedUpdateWithoutLembretesInput>
    create: XOR<MaterialCreateWithoutLembretesInput, MaterialUncheckedCreateWithoutLembretesInput>
    where?: MaterialWhereInput
  }

  export type MaterialUpdateToOneWithWhereWithoutLembretesInput = {
    where?: MaterialWhereInput
    data: XOR<MaterialUpdateWithoutLembretesInput, MaterialUncheckedUpdateWithoutLembretesInput>
  }

  export type MaterialUpdateWithoutLembretesInput = {
    nome?: StringFieldUpdateOperationsInput | string
    etapaDefault?: NullableEnumEtapaTipoFieldUpdateOperationsInput | $Enums.EtapaTipo | null
    unidade?: StringFieldUpdateOperationsInput | string
    itens?: MaterialObraUpdateManyWithoutMaterialNestedInput
  }

  export type MaterialUncheckedUpdateWithoutLembretesInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    etapaDefault?: NullableEnumEtapaTipoFieldUpdateOperationsInput | $Enums.EtapaTipo | null
    unidade?: StringFieldUpdateOperationsInput | string
    itens?: MaterialObraUncheckedUpdateManyWithoutMaterialNestedInput
  }

  export type ObraCreateManyGerenteInput = {
    id?: number
    tipoObra: $Enums.TipoObra
    endereco: string
    creaCauResponsavel: string
    cno: string
    responsavelId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UsuarioExecucaoCreateManyEmpresaInput = {
    id?: number
    nome: string
    cpf: string
    endereco: string
    creaCau: string
    telefone?: string | null
    email: string
    dataNascimento?: Date | string | null
    senhaHash: string
    role?: $Enums.Role
  }

  export type ObraUpdateWithoutGerenteInput = {
    tipoObra?: EnumTipoObraFieldUpdateOperationsInput | $Enums.TipoObra
    endereco?: StringFieldUpdateOperationsInput | string
    creaCauResponsavel?: StringFieldUpdateOperationsInput | string
    cno?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    responsavel?: UsuarioExecucaoUpdateOneRequiredWithoutObrasResponsavelNestedInput
    etapas?: EtapaObraUpdateManyWithoutObraNestedInput
    materiaisPedidos?: MaterialObraUpdateManyWithoutObraNestedInput
    lembretes?: LembreteMaterialUpdateManyWithoutObraNestedInput
  }

  export type ObraUncheckedUpdateWithoutGerenteInput = {
    id?: IntFieldUpdateOperationsInput | number
    tipoObra?: EnumTipoObraFieldUpdateOperationsInput | $Enums.TipoObra
    endereco?: StringFieldUpdateOperationsInput | string
    creaCauResponsavel?: StringFieldUpdateOperationsInput | string
    cno?: StringFieldUpdateOperationsInput | string
    responsavelId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    etapas?: EtapaObraUncheckedUpdateManyWithoutObraNestedInput
    materiaisPedidos?: MaterialObraUncheckedUpdateManyWithoutObraNestedInput
    lembretes?: LembreteMaterialUncheckedUpdateManyWithoutObraNestedInput
  }

  export type ObraUncheckedUpdateManyWithoutGerenteInput = {
    id?: IntFieldUpdateOperationsInput | number
    tipoObra?: EnumTipoObraFieldUpdateOperationsInput | $Enums.TipoObra
    endereco?: StringFieldUpdateOperationsInput | string
    creaCauResponsavel?: StringFieldUpdateOperationsInput | string
    cno?: StringFieldUpdateOperationsInput | string
    responsavelId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UsuarioExecucaoUpdateWithoutEmpresaInput = {
    nome?: StringFieldUpdateOperationsInput | string
    cpf?: StringFieldUpdateOperationsInput | string
    endereco?: StringFieldUpdateOperationsInput | string
    creaCau?: StringFieldUpdateOperationsInput | string
    telefone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    dataNascimento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    senhaHash?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    obrasResponsavel?: ObraUpdateManyWithoutResponsavelNestedInput
  }

  export type UsuarioExecucaoUncheckedUpdateWithoutEmpresaInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    cpf?: StringFieldUpdateOperationsInput | string
    endereco?: StringFieldUpdateOperationsInput | string
    creaCau?: StringFieldUpdateOperationsInput | string
    telefone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    dataNascimento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    senhaHash?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    obrasResponsavel?: ObraUncheckedUpdateManyWithoutResponsavelNestedInput
  }

  export type UsuarioExecucaoUncheckedUpdateManyWithoutEmpresaInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    cpf?: StringFieldUpdateOperationsInput | string
    endereco?: StringFieldUpdateOperationsInput | string
    creaCau?: StringFieldUpdateOperationsInput | string
    telefone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    dataNascimento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    senhaHash?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
  }

  export type ObraCreateManyResponsavelInput = {
    id?: number
    tipoObra: $Enums.TipoObra
    endereco: string
    creaCauResponsavel: string
    cno: string
    gerenteId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ObraUpdateWithoutResponsavelInput = {
    tipoObra?: EnumTipoObraFieldUpdateOperationsInput | $Enums.TipoObra
    endereco?: StringFieldUpdateOperationsInput | string
    creaCauResponsavel?: StringFieldUpdateOperationsInput | string
    cno?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    gerente?: UsuarioGerenciamentoUpdateOneRequiredWithoutObrasNestedInput
    etapas?: EtapaObraUpdateManyWithoutObraNestedInput
    materiaisPedidos?: MaterialObraUpdateManyWithoutObraNestedInput
    lembretes?: LembreteMaterialUpdateManyWithoutObraNestedInput
  }

  export type ObraUncheckedUpdateWithoutResponsavelInput = {
    id?: IntFieldUpdateOperationsInput | number
    tipoObra?: EnumTipoObraFieldUpdateOperationsInput | $Enums.TipoObra
    endereco?: StringFieldUpdateOperationsInput | string
    creaCauResponsavel?: StringFieldUpdateOperationsInput | string
    cno?: StringFieldUpdateOperationsInput | string
    gerenteId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    etapas?: EtapaObraUncheckedUpdateManyWithoutObraNestedInput
    materiaisPedidos?: MaterialObraUncheckedUpdateManyWithoutObraNestedInput
    lembretes?: LembreteMaterialUncheckedUpdateManyWithoutObraNestedInput
  }

  export type ObraUncheckedUpdateManyWithoutResponsavelInput = {
    id?: IntFieldUpdateOperationsInput | number
    tipoObra?: EnumTipoObraFieldUpdateOperationsInput | $Enums.TipoObra
    endereco?: StringFieldUpdateOperationsInput | string
    creaCauResponsavel?: StringFieldUpdateOperationsInput | string
    cno?: StringFieldUpdateOperationsInput | string
    gerenteId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EtapaObraCreateManyObraInput = {
    id?: number
    tipo: $Enums.EtapaTipo
    subEtapa?: $Enums.SubEtapaTipo | null
    status?: $Enums.StatusEtapa
    dataPrevistaInicio?: Date | string | null
    dataPrevistaFim?: Date | string | null
    dataRealInicio?: Date | string | null
    dataRealFim?: Date | string | null
    justificativaId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MaterialObraCreateManyObraInput = {
    id?: number
    materialId: number
    etapa: $Enums.EtapaTipo
    quantidade: number
    statusPedido?: $Enums.StatusPedido
    dataPedido?: Date | string | null
    dataEntrega?: Date | string | null
  }

  export type LembreteMaterialCreateManyObraInput = {
    id?: number
    materialId: number
    etapa: $Enums.EtapaTipo
    dataLembrete: Date | string
    enviado?: boolean
    createdAt?: Date | string
  }

  export type EtapaObraUpdateWithoutObraInput = {
    tipo?: EnumEtapaTipoFieldUpdateOperationsInput | $Enums.EtapaTipo
    subEtapa?: NullableEnumSubEtapaTipoFieldUpdateOperationsInput | $Enums.SubEtapaTipo | null
    status?: EnumStatusEtapaFieldUpdateOperationsInput | $Enums.StatusEtapa
    dataPrevistaInicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dataPrevistaFim?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dataRealInicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dataRealFim?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    justificativa?: JustificativaAtrasoUpdateOneWithoutEtapasNestedInput
  }

  export type EtapaObraUncheckedUpdateWithoutObraInput = {
    id?: IntFieldUpdateOperationsInput | number
    tipo?: EnumEtapaTipoFieldUpdateOperationsInput | $Enums.EtapaTipo
    subEtapa?: NullableEnumSubEtapaTipoFieldUpdateOperationsInput | $Enums.SubEtapaTipo | null
    status?: EnumStatusEtapaFieldUpdateOperationsInput | $Enums.StatusEtapa
    dataPrevistaInicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dataPrevistaFim?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dataRealInicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dataRealFim?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    justificativaId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EtapaObraUncheckedUpdateManyWithoutObraInput = {
    id?: IntFieldUpdateOperationsInput | number
    tipo?: EnumEtapaTipoFieldUpdateOperationsInput | $Enums.EtapaTipo
    subEtapa?: NullableEnumSubEtapaTipoFieldUpdateOperationsInput | $Enums.SubEtapaTipo | null
    status?: EnumStatusEtapaFieldUpdateOperationsInput | $Enums.StatusEtapa
    dataPrevistaInicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dataPrevistaFim?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dataRealInicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dataRealFim?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    justificativaId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MaterialObraUpdateWithoutObraInput = {
    etapa?: EnumEtapaTipoFieldUpdateOperationsInput | $Enums.EtapaTipo
    quantidade?: FloatFieldUpdateOperationsInput | number
    statusPedido?: EnumStatusPedidoFieldUpdateOperationsInput | $Enums.StatusPedido
    dataPedido?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dataEntrega?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    material?: MaterialUpdateOneRequiredWithoutItensNestedInput
  }

  export type MaterialObraUncheckedUpdateWithoutObraInput = {
    id?: IntFieldUpdateOperationsInput | number
    materialId?: IntFieldUpdateOperationsInput | number
    etapa?: EnumEtapaTipoFieldUpdateOperationsInput | $Enums.EtapaTipo
    quantidade?: FloatFieldUpdateOperationsInput | number
    statusPedido?: EnumStatusPedidoFieldUpdateOperationsInput | $Enums.StatusPedido
    dataPedido?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dataEntrega?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MaterialObraUncheckedUpdateManyWithoutObraInput = {
    id?: IntFieldUpdateOperationsInput | number
    materialId?: IntFieldUpdateOperationsInput | number
    etapa?: EnumEtapaTipoFieldUpdateOperationsInput | $Enums.EtapaTipo
    quantidade?: FloatFieldUpdateOperationsInput | number
    statusPedido?: EnumStatusPedidoFieldUpdateOperationsInput | $Enums.StatusPedido
    dataPedido?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dataEntrega?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type LembreteMaterialUpdateWithoutObraInput = {
    etapa?: EnumEtapaTipoFieldUpdateOperationsInput | $Enums.EtapaTipo
    dataLembrete?: DateTimeFieldUpdateOperationsInput | Date | string
    enviado?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    material?: MaterialUpdateOneRequiredWithoutLembretesNestedInput
  }

  export type LembreteMaterialUncheckedUpdateWithoutObraInput = {
    id?: IntFieldUpdateOperationsInput | number
    materialId?: IntFieldUpdateOperationsInput | number
    etapa?: EnumEtapaTipoFieldUpdateOperationsInput | $Enums.EtapaTipo
    dataLembrete?: DateTimeFieldUpdateOperationsInput | Date | string
    enviado?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LembreteMaterialUncheckedUpdateManyWithoutObraInput = {
    id?: IntFieldUpdateOperationsInput | number
    materialId?: IntFieldUpdateOperationsInput | number
    etapa?: EnumEtapaTipoFieldUpdateOperationsInput | $Enums.EtapaTipo
    dataLembrete?: DateTimeFieldUpdateOperationsInput | Date | string
    enviado?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EtapaObraCreateManyJustificativaInput = {
    id?: number
    obraId: number
    tipo: $Enums.EtapaTipo
    subEtapa?: $Enums.SubEtapaTipo | null
    status?: $Enums.StatusEtapa
    dataPrevistaInicio?: Date | string | null
    dataPrevistaFim?: Date | string | null
    dataRealInicio?: Date | string | null
    dataRealFim?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EtapaObraUpdateWithoutJustificativaInput = {
    tipo?: EnumEtapaTipoFieldUpdateOperationsInput | $Enums.EtapaTipo
    subEtapa?: NullableEnumSubEtapaTipoFieldUpdateOperationsInput | $Enums.SubEtapaTipo | null
    status?: EnumStatusEtapaFieldUpdateOperationsInput | $Enums.StatusEtapa
    dataPrevistaInicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dataPrevistaFim?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dataRealInicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dataRealFim?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    obra?: ObraUpdateOneRequiredWithoutEtapasNestedInput
  }

  export type EtapaObraUncheckedUpdateWithoutJustificativaInput = {
    id?: IntFieldUpdateOperationsInput | number
    obraId?: IntFieldUpdateOperationsInput | number
    tipo?: EnumEtapaTipoFieldUpdateOperationsInput | $Enums.EtapaTipo
    subEtapa?: NullableEnumSubEtapaTipoFieldUpdateOperationsInput | $Enums.SubEtapaTipo | null
    status?: EnumStatusEtapaFieldUpdateOperationsInput | $Enums.StatusEtapa
    dataPrevistaInicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dataPrevistaFim?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dataRealInicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dataRealFim?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EtapaObraUncheckedUpdateManyWithoutJustificativaInput = {
    id?: IntFieldUpdateOperationsInput | number
    obraId?: IntFieldUpdateOperationsInput | number
    tipo?: EnumEtapaTipoFieldUpdateOperationsInput | $Enums.EtapaTipo
    subEtapa?: NullableEnumSubEtapaTipoFieldUpdateOperationsInput | $Enums.SubEtapaTipo | null
    status?: EnumStatusEtapaFieldUpdateOperationsInput | $Enums.StatusEtapa
    dataPrevistaInicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dataPrevistaFim?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dataRealInicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dataRealFim?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MaterialObraCreateManyMaterialInput = {
    id?: number
    obraId: number
    etapa: $Enums.EtapaTipo
    quantidade: number
    statusPedido?: $Enums.StatusPedido
    dataPedido?: Date | string | null
    dataEntrega?: Date | string | null
  }

  export type LembreteMaterialCreateManyMaterialInput = {
    id?: number
    obraId: number
    etapa: $Enums.EtapaTipo
    dataLembrete: Date | string
    enviado?: boolean
    createdAt?: Date | string
  }

  export type MaterialObraUpdateWithoutMaterialInput = {
    etapa?: EnumEtapaTipoFieldUpdateOperationsInput | $Enums.EtapaTipo
    quantidade?: FloatFieldUpdateOperationsInput | number
    statusPedido?: EnumStatusPedidoFieldUpdateOperationsInput | $Enums.StatusPedido
    dataPedido?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dataEntrega?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    obra?: ObraUpdateOneRequiredWithoutMateriaisPedidosNestedInput
  }

  export type MaterialObraUncheckedUpdateWithoutMaterialInput = {
    id?: IntFieldUpdateOperationsInput | number
    obraId?: IntFieldUpdateOperationsInput | number
    etapa?: EnumEtapaTipoFieldUpdateOperationsInput | $Enums.EtapaTipo
    quantidade?: FloatFieldUpdateOperationsInput | number
    statusPedido?: EnumStatusPedidoFieldUpdateOperationsInput | $Enums.StatusPedido
    dataPedido?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dataEntrega?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MaterialObraUncheckedUpdateManyWithoutMaterialInput = {
    id?: IntFieldUpdateOperationsInput | number
    obraId?: IntFieldUpdateOperationsInput | number
    etapa?: EnumEtapaTipoFieldUpdateOperationsInput | $Enums.EtapaTipo
    quantidade?: FloatFieldUpdateOperationsInput | number
    statusPedido?: EnumStatusPedidoFieldUpdateOperationsInput | $Enums.StatusPedido
    dataPedido?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dataEntrega?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type LembreteMaterialUpdateWithoutMaterialInput = {
    etapa?: EnumEtapaTipoFieldUpdateOperationsInput | $Enums.EtapaTipo
    dataLembrete?: DateTimeFieldUpdateOperationsInput | Date | string
    enviado?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    obra?: ObraUpdateOneRequiredWithoutLembretesNestedInput
  }

  export type LembreteMaterialUncheckedUpdateWithoutMaterialInput = {
    id?: IntFieldUpdateOperationsInput | number
    obraId?: IntFieldUpdateOperationsInput | number
    etapa?: EnumEtapaTipoFieldUpdateOperationsInput | $Enums.EtapaTipo
    dataLembrete?: DateTimeFieldUpdateOperationsInput | Date | string
    enviado?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LembreteMaterialUncheckedUpdateManyWithoutMaterialInput = {
    id?: IntFieldUpdateOperationsInput | number
    obraId?: IntFieldUpdateOperationsInput | number
    etapa?: EnumEtapaTipoFieldUpdateOperationsInput | $Enums.EtapaTipo
    dataLembrete?: DateTimeFieldUpdateOperationsInput | Date | string
    enviado?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use UsuarioGerenciamentoCountOutputTypeDefaultArgs instead
     */
    export type UsuarioGerenciamentoCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UsuarioGerenciamentoCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UsuarioExecucaoCountOutputTypeDefaultArgs instead
     */
    export type UsuarioExecucaoCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UsuarioExecucaoCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ObraCountOutputTypeDefaultArgs instead
     */
    export type ObraCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ObraCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use JustificativaAtrasoCountOutputTypeDefaultArgs instead
     */
    export type JustificativaAtrasoCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = JustificativaAtrasoCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MaterialCountOutputTypeDefaultArgs instead
     */
    export type MaterialCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MaterialCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UsuarioGerenciamentoDefaultArgs instead
     */
    export type UsuarioGerenciamentoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UsuarioGerenciamentoDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UsuarioExecucaoDefaultArgs instead
     */
    export type UsuarioExecucaoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UsuarioExecucaoDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ObraDefaultArgs instead
     */
    export type ObraArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ObraDefaultArgs<ExtArgs>
    /**
     * @deprecated Use JustificativaAtrasoDefaultArgs instead
     */
    export type JustificativaAtrasoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = JustificativaAtrasoDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EtapaObraDefaultArgs instead
     */
    export type EtapaObraArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EtapaObraDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MaterialDefaultArgs instead
     */
    export type MaterialArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MaterialDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MaterialObraDefaultArgs instead
     */
    export type MaterialObraArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MaterialObraDefaultArgs<ExtArgs>
    /**
     * @deprecated Use LembreteMaterialDefaultArgs instead
     */
    export type LembreteMaterialArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = LembreteMaterialDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}